<!DOCTYPE html>






  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#fff">






  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">


<script>
    (function(){
        if(''){
            if (prompt('请输入文章密码') !== ''){
                alert('密码错误！');
                history.back();
            }
        }
    })();
</script>






<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.2.0" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.2.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.ico?v=6.2.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.ico?v=6.2.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.2.0" color="#fff">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '6.2.0',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="其它 多重申明 Ranges 类型检查和自动转换 This表达式 等式 运算符重载 空安全 异常 注解 反射 动态类型">
<meta name="keywords" content="learn,Kotlin">
<meta property="og:type" content="article">
<meta property="og:title" content="Kotlin Learning(6章)">
<meta property="og:url" content="http://www.sanmaoliu.com/2018/05/14/Kotlin-Learning5/index.html">
<meta property="og:site_name" content="三毛六的博客">
<meta property="og:description" content="其它 多重申明 Ranges 类型检查和自动转换 This表达式 等式 运算符重载 空安全 异常 注解 反射 动态类型">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2018-05-14T08:25:44.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Kotlin Learning(6章)">
<meta name="twitter:description" content="其它 多重申明 Ranges 类型检查和自动转换 This表达式 等式 运算符重载 空安全 异常 注解 反射 动态类型">



  <link rel="alternate" href="/atom.xml" title="三毛六的博客" type="application/atom+xml">




  <link rel="canonical" href="http://www.sanmaoliu.com/2018/05/14/Kotlin-Learning5/">



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Kotlin Learning(6章) | 三毛六的博客</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>
	
	<a href="https://github.com/17750669630" class="github-corner" aria-label="View source on Github"><svg width="80" height="80" viewbox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">三毛六的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">你来了呀~ 快看看吧！</p>
      
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>




<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">
    <a href="/tags/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>
  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.sanmaoliu.com/2018/05/14/Kotlin-Learning5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="三毛六">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/assets/img/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="三毛六的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Kotlin Learning(6章)
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-05-14 15:17:09 / 修改时间：16:25:44" itemprop="dateCreated datePublished" datetime="2018-05-14T15:17:09+08:00">2018-05-14</time>
            

            
              

              
            
          </span>

          

          
            
          

          
          
		 <!--以下部分为：字数统计、阅读时长插入代码-->
         <span class="post-time">
	   &nbsp; | &nbsp;
           <span class="post-meta-item-icon">
             <i class="fa fa-calendar-o"></i>
           </span>
           <span class="post-meta-item-text">字数统计:</span>
           <span class="post-count">6,658字</span>

         </span>

      <span class="post-time">
	   &nbsp; | &nbsp;
           <span class="post-meta-item-icon">
             <i class="fa fa-calendar-o"></i>
           </span>
           <span class="post-meta-item-text">阅读时长:</span>
           <span class="post-count">29分</span>

         </span>
		
		<!--以上部分为：字数统计、阅读时长插入代码-->

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><ol>
<li>多重申明</li>
<li>Ranges</li>
<li>类型检查和自动转换</li>
<li>This表达式</li>
<li>等式</li>
<li>运算符重载</li>
<li>空安全</li>
<li>异常</li>
<li>注解</li>
<li>反射</li>
<li>动态类型</li>
</ol>
<a id="more"></a>
<h4 id="多重声明"><a href="#多重声明" class="headerlink" title="多重声明"></a>多重声明</h4><p>有时候可以通过给对象插入多个成员函数做区别是很方便的，比如：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> (name, age) = person</span><br></pre></td></tr></table></figure>
<p>这种语法叫多重声明。多重声明一次创建了多个变量。我们声明了俩个新变量： name age 并且可以独立使用：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">println(name)</span><br><span class="line">println(age)</span><br></pre></td></tr></table></figure>
<p>多重声明被编译成下面的代码：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> name = persion.component1()</span><br><span class="line"><span class="keyword">val</span> age = persion.component2()</span><br></pre></td></tr></table></figure>
<p>component1() component2() 是另一个转换原则的例子。任何类型都可以在多重分配的右边。当然了，也可以有 component3() component4() 等等 </p>
<p>多重声明也可以在 for 循环中用</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ((a, b) <span class="keyword">in</span> collection) &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>参数 a 和 b 是 component1() component2() 的返回值</p>
<h5 id="例子：一个函数返回俩个值"><a href="#例子：一个函数返回俩个值" class="headerlink" title="例子：一个函数返回俩个值"></a>例子：一个函数返回俩个值</h5><p>要是一个函数想返回俩个值。比如，一个对象结果，一个是排序的状态。在 Kotlin中的一个紧凑的方案是声明 data 类并返回实例：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Result</span></span>(<span class="keyword">val</span> result: <span class="built_in">Int</span>, <span class="keyword">val</span> status: Status)</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">function</span><span class="params">(...)</span></span>: Result &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> Result(result, status)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">val</span> (result, status) = function(...)</span><br></pre></td></tr></table></figure>
<p>数据类自动声明 componentN() 函数<br>注意：也可以使用标准类 Pair 并让函数返回 ‘Pair’，但可读性不是很强</p>
<h5 id="例子：多重声明和-Map"><a href="#例子：多重声明和-Map" class="headerlink" title="例子：多重声明和 Map"></a>例子：多重声明和 Map</h5><p>转换 map 的最好办法可能是下面这样：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ((key, value) <span class="keyword">in</span> map) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了让这个可以工作，我们需要</p>
<blockquote>
<p>通过提供 iterator() 函数序列化呈现 map 通过 component1() 和component1() 函数是把元素成对呈现</p>
</blockquote>
<p>事实上，标准库提供了这样的扩展：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;K, V&gt;</span> Map<span class="type">&lt;K, V&gt;</span>.<span class="title">iterator</span><span class="params">()</span></span>: Iterator&lt;Map.Entry&lt;K, V&gt;&gt; = ent</span><br><span class="line">rySet().iterator()</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;K, V&gt;</span> Map.Entry<span class="type">&lt;K, V&gt;</span>.<span class="title">component1</span><span class="params">()</span></span> = getKey()</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;K, V&gt;</span> Map.Entry<span class="type">&lt;K, V&gt;</span>.<span class="title">component2</span><span class="params">()</span></span> = getValue()</span><br></pre></td></tr></table></figure>
<p>因此你可以用 for 循环方便的读取 map (或者其它数据集合)</p>
<h4 id="Ranges"><a href="#Ranges" class="headerlink" title="Ranges"></a>Ranges</h4><p>range 表达式拥有 rangeTo 函数操作符是 .. 。 Range 可以对任何可比较的类型做操作，但对很多原语是优化过的。下面是些例子：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (i <span class="keyword">in</span> <span class="number">1</span>..<span class="number">10</span>) &#123;</span><br><span class="line">	println(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (x !<span class="keyword">in</span> <span class="number">1.0</span>..<span class="number">3.0</span>) println(x)</span><br><span class="line"><span class="keyword">if</span> (str <span class="keyword">in</span> <span class="string">"island"</span>..<span class="string">"isle"</span>) println(str)</span><br></pre></td></tr></table></figure>
<p>数字的范围有个附加的特性：它们可以迭代。编译器会把它转成类似于 java 的 for循环的形式，且不用担心越界：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span>..<span class="number">4</span>) print(i) <span class="comment">// prints "1234"</span></span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">4</span>..<span class="number">1</span>) print(i) <span class="comment">// prints nothing</span></span><br><span class="line"><span class="keyword">for</span> (x <span class="keyword">in</span> <span class="number">1.0</span>..<span class="number">2.0</span>) print(<span class="string">"<span class="variable">$x</span> "</span>) <span class="comment">// prints "1.0 2.0 "</span></span><br></pre></td></tr></table></figure>
<p>如果你想迭代数字并想反过来，这个相当简单，你可以使用 downTo() 函数</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">4</span> downTo <span class="number">1</span>) print(i)</span><br></pre></td></tr></table></figure>
<p>也可以使用指定步数的迭代，这个用到 step()</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span>..<span class="number">4</span> step <span class="number">2</span>) print(i) <span class="comment">// prints "13"</span></span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">4</span> downTo <span class="number">1</span> step <span class="number">2</span>) print(i) <span class="comment">// prints "42"</span></span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.0</span>..<span class="number">2.0</span> step <span class="number">0.3</span>) print(<span class="string">"<span class="variable">$i</span> "</span>) <span class="comment">// prints "1.0 1.3 1.6 1.9 "</span></span><br></pre></td></tr></table></figure>
<h5 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h5><p>在标准库中有俩种接口：Range 和 Progression<br>Range 表示数学范围上的一个间隔。它有俩个端点：start 和 end 。主要的操作符是 contains 通常在 in/!in 操作符内：<br>Progression 表示一个算数级数。它有一个 start 和 end 以及一个非零 increment 。Progression 是Iterable 的一个子类，因此可以使用在 for 循环中，或者 map filter等等。第一个元素是 start 下一个元素都是前一个元素的 increment。 Progression 的迭代与 java/javaScript 的 for 循环相同：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// if increment &gt; 0</span></span><br><span class="line"><span class="keyword">for</span> (int i = start; i &lt;= end; i += increment) &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// if increment &lt; 0</span></span><br><span class="line"><span class="keyword">for</span> (int i = start; i &gt;= end; i += increment) &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="范围指标"><a href="#范围指标" class="headerlink" title="范围指标"></a>范围指标</h5><p>使用例子：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Checking if value of comparable is in range. Optimized for number primitives.</span></span><br><span class="line"><span class="keyword">if</span> (i <span class="keyword">in</span> <span class="number">1</span>..<span class="number">10</span>) println(i)</span><br><span class="line"><span class="keyword">if</span> (x <span class="keyword">in</span> <span class="number">1.0</span>..<span class="number">3.0</span>) println(x)</span><br><span class="line"><span class="keyword">if</span> (str <span class="keyword">in</span> <span class="string">"island"</span>..<span class="string">"isle"</span>) println(str)</span><br><span class="line"><span class="comment">// Iterating over arithmetical progression of numbers. Optimized for number primitives (as indexed for-loop in Java).</span></span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span>..<span class="number">4</span>) print(i) <span class="comment">// prints "1234"</span></span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">4</span>..<span class="number">1</span>) print(i) <span class="comment">// prints nothing</span></span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">4</span> downTo <span class="number">1</span>) print(i) <span class="comment">// prints "4321"</span></span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span>..<span class="number">4</span> step <span class="number">2</span>) print(i) <span class="comment">// prints "13"</span></span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> (<span class="number">1</span>..<span class="number">4</span>).reversed()) print(i) <span class="comment">// prints "4321"</span></span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> (<span class="number">1</span>..<span class="number">4</span>).reversed() step <span class="number">2</span>) print(i) <span class="comment">// prints "42"</span></span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">4</span> downTo <span class="number">1</span> step <span class="number">2</span>) print(i) <span class="comment">// prints "42"</span></span><br><span class="line"><span class="keyword">for</span> (x <span class="keyword">in</span> <span class="number">1.0</span>..<span class="number">2.0</span>) print(<span class="string">"<span class="variable">$x</span> "</span>) <span class="comment">// prints "1.0 2.0 "</span></span><br><span class="line"><span class="keyword">for</span> (x <span class="keyword">in</span> <span class="number">1.0</span>..<span class="number">2.0</span> step <span class="number">0.3</span>) print(<span class="string">"<span class="variable">$x</span> "</span>) <span class="comment">// prints "1.0 1.3 1.6 1.9 "</span></span><br><span class="line"><span class="keyword">for</span> (x <span class="keyword">in</span> <span class="number">2.0</span> downTo <span class="number">1.0</span> step <span class="number">0.3</span>) print(<span class="string">"<span class="variable">$x</span> "</span>) <span class="comment">// prints "2.0 1.7 1.4 1.1 "</span></span><br><span class="line"><span class="keyword">for</span> (str <span class="keyword">in</span> <span class="string">"island"</span>..<span class="string">"isle"</span>) println(str) <span class="comment">// error: string range cannot be iterated over</span></span><br></pre></td></tr></table></figure>
<h5 id="常见的接口的定义"><a href="#常见的接口的定义" class="headerlink" title="常见的接口的定义"></a>常见的接口的定义</h5><p>有俩种基本接口： Range Progression</p>
<p>Range 接口定义了一个范围，或者是数学意义上的一个间隔。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Range</span>&lt;<span class="type">T : Comparable&lt;T</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">val</span> start: T</span><br><span class="line">    <span class="keyword">val</span> end: T</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">contains</span><span class="params">(Element : <span class="type">T</span>)</span></span>: <span class="built_in">Boolean</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Progression 定义了数学上的级数。包括 start end increment 端点。最大的特点就是它可以迭代，因此它是 Iterable 的子类。end 不是必须的。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Progression</span>&lt;<span class="type">N : Number</span>&gt; : <span class="type">Iterable</span>&lt;<span class="type">N</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">val</span> start : N</span><br><span class="line">    <span class="keyword">val</span> end : N</span><br><span class="line">    <span class="keyword">val</span> increment : Number</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与 java 的 for 循环类似：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// if increment &gt; 0</span></span><br><span class="line"><span class="keyword">for</span> (int i = start; i &lt;= end; i += increment) &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// if increment &lt; 0</span></span><br><span class="line"><span class="keyword">for</span> (int i = start; i &gt;= end; i += increment) &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="类的实现"><a href="#类的实现" class="headerlink" title="类的实现"></a>类的实现</h5><p>为避免不需要的重复，让我们先考虑一个数字类型 Int 。其它的数字类型也一样。注意这些类的实例需要用相应的构造函数来创建，使用 rangeTo() downTo()reversed() stop() 实用函数。<br>IntProgression 类很直接也很简单：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntProgression</span></span>(<span class="keyword">override</span> <span class="keyword">val</span> start: <span class="built_in">Int</span>, <span class="keyword">override</span> <span class="keyword">val</span> end: <span class="built_in">Int</span>, <span class="keyword">override</span> <span class="keyword">val</span> increment: <span class="built_in">Int</span> ): Progression&lt;<span class="built_in">Int</span>&gt; &#123;</span><br><span class="line">	<span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">iterator</span><span class="params">()</span></span>: Iterator&lt;<span class="built_in">Int</span>&gt; = IntProgressionIteratorImpl(start, end, increment)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>IntRange 有些狡猾：它实现了 Progression Range 接口，因为它天生以通过 range 迭代(默认增加值是 1 )：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntRange</span></span>(<span class="keyword">override</span> <span class="keyword">val</span> start: <span class="built_in">Int</span>, <span class="keyword">override</span> <span class="keyword">val</span> end: <span class="built_in">Int</span>): Range&lt;<span class="built_in">Int</span>&gt;, Progression&lt;<span class="built_in">Int</span>&gt; &#123;</span><br><span class="line">	<span class="keyword">override</span> <span class="keyword">val</span> increment: <span class="built_in">Int</span></span><br><span class="line">		<span class="keyword">get</span>() = <span class="number">1</span></span><br><span class="line">	<span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">contains</span><span class="params">(element: <span class="type">Int</span>)</span></span>: <span class="built_in">Boolean</span> = start &lt;= element &amp;&amp; element &lt;= end</span><br><span class="line">	<span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">iterator</span><span class="params">()</span></span>: Iterator&lt;<span class="built_in">Int</span>&gt; = IntProgressionIteratorImpl(start, end, increment)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ComparableRange 也很简单：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ComparableRange</span>&lt;<span class="type">T : Comparable&lt;T</span>&gt;&gt;</span>(<span class="keyword">override</span> <span class="keyword">val</span> start: T, <span class="keyword">override</span> <span class="keyword">val</span> end: T): Range&lt;T&gt; &#123;</span><br><span class="line">	<span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">contains</span><span class="params">(element: <span class="type">T</span>)</span></span>: <span class="built_in">Boolean</span> = start &lt;= element &amp;&amp; element &lt;= end</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="一些实用的函数"><a href="#一些实用的函数" class="headerlink" title="一些实用的函数"></a>一些实用的函数</h5><p>rangeTo()<br>rangeTo() 函数仅仅是调用 *Range 的构造函数，比如：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Int</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">rangeTo</span><span class="params">(other: <span class="type">Byte</span>)</span></span>: IntRange = IntRange(<span class="keyword">this</span>, Other)</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">rangeTo</span><span class="params">(other: <span class="type">Int</span>)</span></span>: IntRange = IntRange(<span class="keyword">this</span>, other)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>downTo()<br>downTo() 扩展函数可以为任何数字类型定义，这里有俩个例子：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="built_in">Long</span>.<span class="title">downTo</span><span class="params">(other: <span class="type">Double</span>)</span></span>: DoubleProgression &#123;</span><br><span class="line">	<span class="keyword">return</span> DoubleProgression(<span class="keyword">this</span>, other, -<span class="number">1.0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="built_in">Byte</span>.<span class="title">downTo</span><span class="params">(other: <span class="type">Int</span>)</span></span>: IntProgression &#123;</span><br><span class="line">	<span class="keyword">return</span> IntProgression(<span class="keyword">this</span>, other, -<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>reversed()<br>reversed() 扩展函数是给所有的 <em>Range 和 </em>Progression 类定义的，并且它们都返回反向的级数。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> IntProgression.<span class="title">reversed</span><span class="params">()</span></span>: IntProgression &#123;</span><br><span class="line">	<span class="keyword">return</span> IntProgression(end, start, -increment)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> IntRange.<span class="title">reversed</span><span class="params">()</span></span>: IntProgression &#123;</span><br><span class="line">	<span class="keyword">return</span> IntProgression(end, start, -<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>step()<br>step() 扩展函数是给所有的 <em>Range 和 </em>Progression 类定义的，所有的返回级数都修改了 setp 值。注意 step 值总是正的，否则函数不会改变迭代的方向。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> IntProgression.<span class="title">step</span><span class="params">(step: <span class="type">Int</span>)</span></span>: IntProgression &#123;</span><br><span class="line">    <span class="keyword">if</span> (step &lt;= <span class="number">0</span>) <span class="keyword">throw</span> IllegalArgumentException(<span class="string">"Step must be positive, was: <span class="variable">$step</span>"</span>)</span><br><span class="line">        <span class="keyword">return</span> IntProgression(start, end, <span class="keyword">if</span> (increment &gt; <span class="number">0</span>) step <span class="keyword">else</span> -step)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> IntRange.<span class="title">step</span><span class="params">(step: <span class="type">Int</span>)</span></span>: IntProgression &#123;</span><br><span class="line">    <span class="keyword">if</span> (step &lt;= <span class="number">0</span>) <span class="keyword">throw</span> IllegalArgumentException(<span class="string">"Step must be positive, was: <span class="variable">$step</span>"</span>)</span><br><span class="line">        <span class="keyword">return</span> IntProgression(start, end, step)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="类型检查和转换"><a href="#类型检查和转换" class="headerlink" title="类型检查和转换"></a>类型检查和转换</h4><h5 id="is-is-表达式"><a href="#is-is-表达式" class="headerlink" title="is !is 表达式"></a>is !is 表达式</h5><p>我们可以在运行是通过上面俩个操作符检查一个对象是否是某个特定类：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (obj <span class="keyword">is</span> String) &#123;</span><br><span class="line">	print(obj.length)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (obj !<span class="keyword">is</span> String) &#123; <span class="comment">// same as !(obj is String)</span></span><br><span class="line">	print(<span class="string">"Not a String"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">	print(obj.length)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="智能转换"><a href="#智能转换" class="headerlink" title="智能转换"></a>智能转换</h5><p>在很多情形中，需要使用非明确的类型，因为编译器会跟踪 is 检查静态变量，并在需要的时候自动插入安全转换：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">demo</span><span class="params">(x: <span class="type">Any</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (x <span class="keyword">is</span> String) &#123;</span><br><span class="line">    	print(x.length) <span class="comment">// x is automatically cast to String</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译器足够智能如何转换是安全的，如果不安全将会返回：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x !<span class="keyword">is</span> String) <span class="keyword">return</span></span><br><span class="line">print(x.length) <span class="comment">//x 自动转换为 String</span></span><br></pre></td></tr></table></figure>
<p>或者在 || &amp;&amp; 操作符的右边的值</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// x is automatically cast to string on the right-hand side of`||`</span></span><br><span class="line"><span class="keyword">if</span> (x !<span class="keyword">is</span> String || x.length == <span class="number">0</span>) <span class="keyword">return</span></span><br><span class="line"><span class="comment">// x is automatically cast to string on the right-hand side of`&amp;&amp;`</span></span><br><span class="line"><span class="keyword">if</span> (x <span class="keyword">is</span> String &amp;&amp; x.length &gt; <span class="number">0</span>)</span><br><span class="line">print(x.length) <span class="comment">// x is automatically cast to String</span></span><br></pre></td></tr></table></figure>
<p>这样的转换在 when 表达式和 whie 循环中也会发生</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">when</span> (x) &#123;</span><br><span class="line">    <span class="keyword">is</span> <span class="built_in">Int</span> -&gt; print(x + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">is</span> String -&gt; print(x.length + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">is</span> Array&lt;<span class="built_in">Int</span>&gt; -&gt; print(x.sum())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="“不安全”的转换符"><a href="#“不安全”的转换符" class="headerlink" title="“不安全”的转换符"></a>“不安全”的转换符</h5><p>和 如果转换是不被允许的那么转换符就会抛出一个异常。因此我们称之为不安全的。在kotlin 中 我们用前缀 as 操作符</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> x: String = y <span class="keyword">as</span> String</span><br></pre></td></tr></table></figure>
<p>注意 null 不能被转换为 String 因为它不是 nullable ，也就是说如果 y 是空的，则上面的代码会抛出空异常。<br>为了 java 的转换语句匹配我们得像下面这样：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> x: String?= y <span class="keyword">as</span> String?</span><br></pre></td></tr></table></figure>
<h5 id="“安全”转换符"><a href="#“安全”转换符" class="headerlink" title="“安全”转换符"></a>“安全”转换符</h5><p>为了避免抛出异常，可以用 as? 这个安全转换符，这样失败就会返回 null ：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> x: String ?= y <span class="keyword">as</span>? String</span><br></pre></td></tr></table></figure>
<p>不管 as? 右边的是不是一个非空 String 结果都会转换为可空的。</p>
<h4 id="This-表达式"><a href="#This-表达式" class="headerlink" title="This 表达式"></a>This 表达式</h4><p>为了记录下当前接受者，我们使用 this 表达式：</p>
<blockquote>
<p>在类的成员中，this 表示当前类的对象<br>在扩展函数或扩展字面函数中，this 表示 . 左边接收者参数</p>
</blockquote>
<p>如果 this 没有应用者，则指向的是最内层的闭合范围。为了在其它范围中返回 this，需要使用标签</p>
<h5 id="this使用范围"><a href="#this使用范围" class="headerlink" title="this使用范围"></a>this使用范围</h5><p>为了在范围外部(一个类，或者表达式函数，或者带标签的扩展字面函数)访问 this，我们需要在使用 this@lable 作为 lable</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123; <span class="comment">// implicit label @A</span></span><br><span class="line">    <span class="keyword">inner</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123; <span class="comment">// implicit label @B</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="built_in">Int</span>.<span class="title">foo</span><span class="params">()</span></span> &#123; <span class="comment">// implicit label @foo</span></span><br><span class="line">            <span class="keyword">val</span> a = <span class="keyword">this</span><span class="symbol">@A</span> <span class="comment">// A's this</span></span><br><span class="line">            <span class="keyword">val</span> b = <span class="keyword">this</span><span class="symbol">@B</span> <span class="comment">// B's this</span></span><br><span class="line">            <span class="keyword">val</span> c = <span class="keyword">this</span> <span class="comment">// foo()'s receiver, an Int</span></span><br><span class="line">            <span class="keyword">val</span> c1 = <span class="keyword">this</span><span class="symbol">@foo</span> <span class="comment">// foo()'s receiver, an Int</span></span><br><span class="line">            <span class="keyword">val</span> funLit = <span class="meta">@lambda</span> &#123; String.() -&gt;</span><br><span class="line">                <span class="keyword">val</span> d = <span class="keyword">this</span> <span class="comment">// funLit's receiver</span></span><br><span class="line">                <span class="keyword">val</span> d1 = <span class="keyword">this</span><span class="symbol">@lambda</span> <span class="comment">// funLit's receiver</span></span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">val</span> funLit2 = &#123; (s: String) -&gt;</span><br><span class="line">            <span class="comment">// foo()'s receiver, since enclosing function literal</span></span><br><span class="line">            <span class="comment">// doesn't have any receiver</span></span><br><span class="line">            <span class="keyword">val</span> d1 = <span class="keyword">this</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="等式"><a href="#等式" class="headerlink" title="等式"></a>等式</h4><p>在 kotlin 中有俩中相等：</p>
<blockquote>
<p>参照相等(指向相同的对象) 结构相等</p>
</blockquote>
<h5 id="参照相等"><a href="#参照相等" class="headerlink" title="参照相等"></a>参照相等</h5><p>参照相等是通过 === 操作符判断的(不等是 !== ) a===b 只有 a b 指向同一个对象是判别才成立。<br>另外，你可以使用内联函数 identityEquals() 判断参照相等：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a.identityEquals(b)</span><br><span class="line">a identityEquals b</span><br></pre></td></tr></table></figure>
<h5 id="结构相等"><a href="#结构相等" class="headerlink" title="结构相等"></a>结构相等</h5><p>结构相等是通过 == 判断的。像 a == b 将会翻译成：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a?.equals(b) ?: b === <span class="literal">null</span></span><br></pre></td></tr></table></figure>
<p>如果 a 不是 null 则调用 equals(Any?) 函数，否则检查 b 是否参照等于 null<br>注意完全没有必要为优化你的代码而将 a == null 写成 a === null 编译器会自动帮你做的。</p>
<h4 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h4><p>Kotlin 允许我们实现一些我们自定义类型的运算符实现。这些运算符有固定的表示，和固定的优先级。为实现这样的运算符，我们提供了固定名字的数字函数和扩展函数，比如二元运算符的左值和一元运算符的参数类型。</p>
<h5 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h5><p>这里我们描述了一些常用运算符的重载</p>
<h5 id="一元运算符"><a href="#一元运算符" class="headerlink" title="一元运算符"></a>一元运算符</h5><table>
<thead>
<tr>
<th>表达式</th>
<th style="text-align:center">转换</th>
</tr>
</thead>
<tbody>
<tr>
<td>+a</td>
<td style="text-align:center">a.plus()</td>
</tr>
<tr>
<td>-a</td>
<td style="text-align:center">a.minus()</td>
</tr>
<tr>
<td>!a</td>
<td style="text-align:center">a.not()</td>
</tr>
</tbody>
</table>
<p>这张表解释了当编译器运行时，比如，表达式 +a ，是这样运行的：</p>
<blockquote>
<p>决定 a 的类型，假设是 T 寻找接收者是 T 的无参函数 plus() ，比如数字函数或者扩展函数 如果这样的函数缺失或不明确，则返回错误。 如果函数是当前函数或返回类型是 R 则表达式 +a 是 R 类型。</p>
</blockquote>
<p>注意这些操作符和其它的一样，都被优化为基本类型并且不会产生多余的开销。<br>| 表达式 | 转换 |<br>| - | :-: |<br>| a++ |  a.inc() + see below |<br>| a– |  a.des() + see below |</p>
<p>这些操作符允许修改接收者和返回类型。</p>
<blockquote>
<p>inc()/dec() shouldn’t mutate the receiver object.<br>By “changing the receiver” we mean the receiver-variable, not the receiver object.</p>
</blockquote>
<p>编译器是这样解决有后缀的操作符的比如 a++ :</p>
<blockquote>
<p>决定 a 的类型，假设是 T 寻找无参函数 inc() ，作用在接收者T 如果返回类型是 R ，则必须是 T 的子类</p>
</blockquote>
<p>计算表达式的效果是：</p>
<blockquote>
<p>把 a 的初始值存储在 a0 中 把 a.inc() 的结果作用在 a 上 把 a0 作为表达式的返回值</p>
</blockquote>
<p>a– 的步骤也是一样的<br>++a –a 的解决方式也是一样的</p>
<h5 id="二元操作符"><a href="#二元操作符" class="headerlink" title="二元操作符"></a>二元操作符</h5><table>
<thead>
<tr>
<th>表达式</th>
<th style="text-align:center">转换</th>
</tr>
</thead>
<tbody>
<tr>
<td>a + b</td>
<td style="text-align:center">a.plus(b)</td>
</tr>
<tr>
<td>a - b</td>
<td style="text-align:center">a.minus(b)</td>
</tr>
<tr>
<td>a * b</td>
<td style="text-align:center">a.times(b)</td>
</tr>
<tr>
<td>a / b</td>
<td style="text-align:center">a.div(b)</td>
</tr>
<tr>
<td>a % b</td>
<td style="text-align:center">a.mod(b)</td>
</tr>
<tr>
<td>a..b</td>
<td style="text-align:center">a.rangeTo(b)</td>
</tr>
</tbody>
</table>
<p>编译器只是解决了该表中翻译为列的表达式</p>
<table>
<thead>
<tr>
<th>表达式</th>
<th style="text-align:center">转换</th>
</tr>
</thead>
<tbody>
<tr>
<td>a in b</td>
<td style="text-align:center">b.contains(a)</td>
</tr>
<tr>
<td>a !in b</td>
<td style="text-align:center">!b.contains(a)</td>
</tr>
</tbody>
</table>
<p>in 和 !in 的产生步骤是一样的，但参数顺序是相反的。</p>
<table>
<thead>
<tr>
<th>标志</th>
<th style="text-align:center">转换</th>
</tr>
</thead>
<tbody>
<tr>
<td>a[i]</td>
<td style="text-align:center">a.get(i)</td>
</tr>
<tr>
<td>a[i, j]</td>
<td style="text-align:center">a.get(i, j)</td>
</tr>
<tr>
<td>a[i_1, …, i_n]</td>
<td style="text-align:center">a.get(i_1, … , i_n)</td>
</tr>
<tr>
<td>a[i] = b</td>
<td style="text-align:center">a.set(i, b)</td>
</tr>
<tr>
<td>a[i,j] =b</td>
<td style="text-align:center">a.set(i, j, b)</td>
</tr>
<tr>
<td>a[i_1, … , i_n] = b</td>
<td style="text-align:center">a.set(i_1,… ,o_n,b)</td>
</tr>
</tbody>
</table>
<p>方括号被转换为 get set 函数</p>
<table>
<thead>
<tr>
<th>表达式</th>
<th style="text-align:center">转换</th>
</tr>
</thead>
<tbody>
<tr>
<td>a(i)</td>
<td style="text-align:center">a.invoke(i)</td>
</tr>
<tr>
<td>a(i, j)</td>
<td style="text-align:center">a.invoke(i, j)</td>
</tr>
<tr>
<td>a(i_1, … , i_n)</td>
<td style="text-align:center">a.invoke(i_1, …, i_n)</td>
</tr>
</tbody>
</table>
<p>括号被转换为带有正确参数的 invoke 参数</p>
<table>
<thead>
<tr>
<th>表达式</th>
<th style="text-align:center">转换</th>
</tr>
</thead>
<tbody>
<tr>
<td>a += b</td>
<td style="text-align:center">a.plusAssign(b)</td>
</tr>
<tr>
<td>a -= b</td>
<td style="text-align:center">a.minusAssign(b)</td>
</tr>
<tr>
<td>a *= b</td>
<td style="text-align:center">a.timesAssign(b)</td>
</tr>
<tr>
<td>a /= b</td>
<td style="text-align:center">a.divAssign(b)</td>
</tr>
<tr>
<td>a %= b</td>
<td style="text-align:center">a.modAssign(b)</td>
</tr>
</tbody>
</table>
<p>在分配 a+= b时编译器是下面这样实现的：</p>
<blockquote>
<p>右边列的函数是否可用 对应的二元函数(比如 plus() )是否也可用,不可用在报告错误 确定它的返回值是 Unit 否则报告错误 生成 a.plusAssign(b) 否则试着生成 a=a+b 代码</p>
</blockquote>
<p>Note: assignments are NOT expressions in Kotlin.</p>
<table>
<thead>
<tr>
<th>表达式</th>
<th style="text-align:center">转换</th>
</tr>
</thead>
<tbody>
<tr>
<td>a == b</td>
<td style="text-align:center">a?.equals(b) ?: b.identityEquals(null)</td>
</tr>
<tr>
<td>a != b</td>
<td style="text-align:center">!(a?.equals(b) ?: b.identityEquals(null))</td>
</tr>
</tbody>
</table>
<p>注意 === !== 是不允许重载的<br>== 操作符有俩点特别：</p>
<blockquote>
<p>它被翻译成一个复杂的表达式，用于筛选空值，而且 null == null 是真<br>它需要带有特定签名的函数，而不仅仅是特定名称的函数，下面这样：</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">equals</span><span class="params">(other: <span class="type">Any</span>?)</span></span>: <span class="built_in">Boolean</span></span><br></pre></td></tr></table></figure>
<p>或者用相同的参数列表和返回类型的扩展功能</p>
<table>
<thead>
<tr>
<th>表达式</th>
<th style="text-align:center">转换</th>
</tr>
</thead>
<tbody>
<tr>
<td>a &gt; b</td>
<td style="text-align:center">a.compareTo(b) &gt; 0</td>
</tr>
<tr>
<td>a &lt; b</td>
<td style="text-align:center">a.compareTo(b) &lt; 0</td>
</tr>
<tr>
<td>a &gt;= b</td>
<td style="text-align:center">a.compareTo(b) &gt;= 0</td>
</tr>
<tr>
<td>a &lt;= b</td>
<td style="text-align:center">a.compareTo(b) &lt;= 0</td>
</tr>
</tbody>
</table>
<p>所有的比较都转换为 compareTo 的调用，这个函数需要返回 Int 值</p>
<p>#####命名函数的中缀调用</p>
<p>我们可以通过 中缀函数的调用 来模拟自定义中缀操作符</p>
<h4 id="空安全"><a href="#空安全" class="headerlink" title="空安全"></a>空安全</h4><h5 id="可空类型和非空类型"><a href="#可空类型和非空类型" class="headerlink" title="可空类型和非空类型"></a>可空类型和非空类型</h5><p>Kotlin 类型系统致力于消灭空引用。<br>在许多语言中都存在的一个大陷阱包括 java ，就是访问一个空引用的成员，结果会有空引用异常。在 java 中这就是 NullPointerException 或者叫 NPE<br>Kotlin 类型系统致力与消灭 NullPointerException 异常。唯一可能引起 NPE异常的可能是：</p>
<blockquote>
<p>明确调用 throw NullPointerException() 外部 java 代码引起 一些前后矛盾的初始化(在构造函数中没初始化的成员在其它地方使用)</p>
</blockquote>
<p>在 Kotlin 类型系统中可以为空和不可为空的引用是不同的。比如，普通的String 类型的变量不能为空：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a: String =<span class="string">"abc"</span></span><br><span class="line">a = <span class="literal">null</span> <span class="comment">//编译错误</span></span><br></pre></td></tr></table></figure>
<p>允许为空，我们必须把它声明为可空的变量：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b: String? = <span class="string">"abc"</span></span><br><span class="line">b = <span class="literal">null</span></span><br></pre></td></tr></table></figure>
<p>现在你可以调用 a 的方法，而不用担心 NPE 异常了：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> l = a.length()</span><br></pre></td></tr></table></figure>
<p>但如果你想使用 b 调用同样的方法就有可能报错了：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> l = b.length() <span class="comment">//错误：b 不可为空</span></span><br></pre></td></tr></table></figure>
<p>但我们任然想要调用方法，有些办法可以解决。</p>
<h5 id="在条件中检查-null"><a href="#在条件中检查-null" class="headerlink" title="在条件中检查 null"></a>在条件中检查 null</h5><p>首先，你可以检查 b 是否为空，并且分开处理下面选项：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> l = <span class="keyword">if</span> (b != <span class="literal">null</span>) b.length() <span class="keyword">else</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>编译器会跟踪你检查的信息并允许在 if 中调用 length()。更复杂的条件也是可以的：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (b != <span class="literal">null</span> &amp;&amp; b.length() &gt;<span class="number">0</span>)</span><br><span class="line">	print(<span class="string">"Stirng of length <span class="subst">$&#123;b.length&#125;</span>"</span>)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	print(<span class="string">"Empty string"</span>)</span><br></pre></td></tr></table></figure>
<p>注意只有在 b 是不可变时才可以</p>
<h5 id="安全调用"><a href="#安全调用" class="headerlink" title="安全调用"></a>安全调用</h5><p>第二个选择就是使用安全操作符， ?. :</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b?.length()</span><br></pre></td></tr></table></figure>
<p>如果 b 不为空则返回长度，否则返回空。这个表达式的的类型是 Int?<br>安全调用在链式调用是是很有用的。比如，如果 Bob 是一个雇员可能分配部门(也可能不分配)，如果我们想获取 Bob 的部门名作为名字的前缀，就可以这样做：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bob?.department?.head?.name</span><br></pre></td></tr></table></figure>
<p>这样的调用链在任何一个属性为空都会返回空。</p>
<h5 id="Elvis-操作符"><a href="#Elvis-操作符" class="headerlink" title="Elvis 操作符"></a>Elvis 操作符</h5><p>当我们有一个 r 的可空引用时，我们可以说如果 r 不空则使用它，否则使用使用非空的 x :</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> l: <span class="built_in">Int</span> = <span class="keyword">if</span> (b != <span class="literal">null</span>) b.length() <span class="keyword">else</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>尽管使用 if 表达式我们也可以使用 Elvis 操作符， ?:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> l = b.length()?: -<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>如果 ?: 左边表达式不为空则返回，否则返回右边的表达式。注意右边的表带式只有在左边表达式为空是才会执行<br>注意在 Kotlin 中 throw return 是表达式，所以它们也可以在 Elvis 操作符右边。这是非常有用的，比如检查函数参数是否为空；</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">(node: <span class="type">Node</span>)</span></span>: String? &#123;</span><br><span class="line">    <span class="keyword">val</span> parent = node.getParent() ?: <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    <span class="keyword">val</span> name = node.getName() ?: <span class="keyword">throw</span> IllegalArgumentException(<span class="string">"name expected"</span>)</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="操作符"><a href="#操作符" class="headerlink" title="!! 操作符"></a>!! 操作符</h5><p>第三个选择是 NPE-lovers。我们可以用 b!! ，这会返回一个非空的 b 或者抛出一个 b 为空的 NPE</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> l = b !!.length()</span><br></pre></td></tr></table></figure>
<h5 id="安全转换"><a href="#安全转换" class="headerlink" title="安全转换"></a>安全转换</h5><p>普通的转换可能产生 ClassCastException 异常。另一个选择就是使用安全转换，如果不成功就返回空：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> aInt: <span class="built_in">Int</span>? = a <span class="keyword">as</span>? <span class="built_in">Int</span></span><br></pre></td></tr></table></figure>
<h4 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h4><h5 id="异常类"><a href="#异常类" class="headerlink" title="异常类"></a>异常类</h5><p>所有的异常类都是 Exception 的子类。每个异常都有一个消息，栈踪迹和可选的原因。<br>使用 throw 表达式，抛出异常</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> MyException(<span class="string">"Hi There!"</span>)</span><br></pre></td></tr></table></figure>
<p>使用 try 捕获异常</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	<span class="comment">// some code</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (e: SomeException) &#123;</span><br><span class="line">	<span class="comment">// handler</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">	<span class="comment">// optional finally block</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有可能有不止一个的 catch 块。finally 块可以省略。</p>
<h5 id="try-是一个表达式"><a href="#try-是一个表达式" class="headerlink" title="try 是一个表达式"></a>try 是一个表达式</h5><p>try 可以有返回值：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> a: <span class="built_in">Int</span>? = <span class="keyword">try</span> &#123; parseInt(input) &#125; <span class="keyword">catch</span> (e: NumberFormatException) &#123; <span class="literal">null</span> &#125;</span><br></pre></td></tr></table></figure>
<p>try 返回值要么是 try 块的最后一个表达式，要么是 catch 块的最后一个表达式。 finally 块的内容不会对表达式有任何影响。</p>
<h5 id="检查异常"><a href="#检查异常" class="headerlink" title="检查异常"></a>检查异常</h5><p>Kotlin 中没有异常检查。这是由多种原因造成的，我们这里举个简单的例子下面是 JDK StringBuilder 类实现的一个接口</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Appendable append(CharSequence csq) throws IOException;</span><br></pre></td></tr></table></figure>
<p>这个签名说了什么？ 它说每次我把 string 添加到什么东西(StringBuilder 或者 log console 等等)上时都会捕获 IOExceptions 为什么呢？因为可能涉及到 IO 操作(Writer 也实现了 Appendable)… 所以导致所有实现 Appendable 的接口都得捕获异常</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	log.append(message)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">	<span class="comment">// Must be safe</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样是不利的，参看Effective java<br>Bruce Eckel 在java 需要异常检查吗?说到：</p>
<blockquote>
<p>Examination of small programs leads to the conclusion that requiring exception specifications could both enhance developer productivity and enhance code quality, but experience with large software projects suggests a different result – decreased productivity and little or no increase in code quality.</p>
</blockquote>
<h4 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h4><h5 id="注解声明"><a href="#注解声明" class="headerlink" title="注解声明"></a>注解声明</h5><p>注解是一种将元数据附加到代码中的方法。声明注解需要在类前面使用 annotation关键字：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">annotation</span> <span class="class"><span class="keyword">class</span> <span class="title">fancy</span></span></span><br></pre></td></tr></table></figure>
<h5 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@fancy</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="meta">@fancy</span> <span class="function"><span class="keyword">fun</span> <span class="title">baz</span><span class="params">(<span class="meta">@fancy</span> foo: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    	<span class="keyword">return</span> (<span class="meta">@fancy</span> <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在多数情形中 @ 标识是可选的。只有在注解表达式或本地声明中才必须：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fancy <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    fancy <span class="function"><span class="keyword">fun</span> <span class="title">baz</span><span class="params">(fancy foo: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="meta">@fancy</span> <span class="function"><span class="keyword">fun</span> <span class="title">bar</span><span class="params">()</span></span> &#123; ... &#125;</span><br><span class="line">        	<span class="keyword">return</span> (<span class="meta">@fancy</span> <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果要给构造函数注解，就需要在构造函数声明时添加 constructor 关键字，并且需要在前面添加注解：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> <span class="meta">@inject</span> <span class="keyword">constructor</span> </span>(dependency: MyDependency)</span><br><span class="line">	<span class="comment">//...</span></span><br></pre></td></tr></table></figure>
<p>也可以注解属性访问者：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x: MyDependency?=<span class="literal">null</span></span><br><span class="line">    	<span class="meta">@inject</span> <span class="keyword">set</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h5><p>注解可以有带参数的构造函数。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">annotation</span> <span class="class"><span class="keyword">class</span> <span class="title">special</span></span>(<span class="keyword">val</span> why: String)</span><br><span class="line">special(<span class="string">"example"</span>) <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Lambdas"><a href="#Lambdas" class="headerlink" title="Lambdas"></a>Lambdas</h5><p>注解也可以用在 Lambda 中。这将会应用到 lambda 生成的 invoke() 方法。这对Quasar框架很有用，在这个框架中注解被用来并发控制</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">annotation</span> <span class="class"><span class="keyword">class</span> <span class="title">Suspendable</span></span></span><br><span class="line"><span class="keyword">val</span> f = <span class="meta">@Suspendable</span> &#123; Fiber.sleep(<span class="number">10</span>) &#125;</span><br></pre></td></tr></table></figure>
<h5 id="java-注解"><a href="#java-注解" class="headerlink" title="java 注解"></a>java 注解</h5><p>java 注解在 kotlin 中是完全兼容的：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test</span><br><span class="line"><span class="keyword">import</span> org.junit.Assert.*</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tests</span> </span>&#123;</span><br><span class="line">    Test <span class="function"><span class="keyword">fun</span> <span class="title">simple</span><span class="params">()</span></span> &#123;</span><br><span class="line">    	assertEquals(<span class="number">42</span>, getTheAnswer())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>java 注解也可以通过在导入是重命名实现像修改者那样：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test <span class="keyword">as</span> test</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tests</span> </span>&#123;</span><br><span class="line">    test <span class="function"><span class="keyword">fun</span> <span class="title">simple</span><span class="params">()</span></span> &#123;</span><br><span class="line">    	...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为 java 中注解参数顺序是没定义的，你不能通过传入参数的方法调用普通函数。相反，你需要使用命名参数语法：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Ann &#123;</span><br><span class="line">    int intValue();</span><br><span class="line">    String stringValue(<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//kotlin</span></span><br><span class="line">Ann(intValue = <span class="number">1</span>, stringValue = <span class="string">"abc"</span>) <span class="class"><span class="keyword">class</span> <span class="title">C</span></span></span><br></pre></td></tr></table></figure>
<p>像 java 中那样，值参数是特殊的情形；它的值可以不用明确的名字。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AnnWithValue &#123;</span><br><span class="line">	String value();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//kotlin</span></span><br><span class="line">AnnWithValue(<span class="string">"abc"</span>) <span class="class"><span class="keyword">class</span> <span class="title">C</span></span></span><br></pre></td></tr></table></figure>
<p>如果java 中的 value 参数有数组类型，则在 kotlin 中变成 vararg 参数：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AnnWithArrayValue &#123;</span><br><span class="line">	String[] value();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Kotlin</span></span><br><span class="line">AnnWithArrayValue(<span class="string">"abc"</span>, <span class="string">"foo"</span>, <span class="string">"bar"</span>) <span class="class"><span class="keyword">class</span> <span class="title">C</span></span></span><br></pre></td></tr></table></figure>
<p>如果你需要明确一个类作为一个注解参数，使用 Kotlin 类KClass。Kotlin 编译器会自动把它转为 java 类，因此 java 代码就可以正常看到注解和参数了。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlin.reflect.KClass</span><br><span class="line"><span class="keyword">annotation</span> <span class="class"><span class="keyword">class</span> <span class="title">Ann</span></span>(<span class="keyword">val</span> arg1: KClass&lt;*&gt;, <span class="keyword">val</span> arg2: KClass&lt;<span class="keyword">out</span> Any?&gt;)</span><br><span class="line">Ann(String::<span class="class"><span class="keyword">class</span>, <span class="type">Int::class) class MyClass</span></span></span><br></pre></td></tr></table></figure>
<p>注解实例的值在 kotlin 代码中是暴露属性。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Ann &#123;</span><br><span class="line">	int value();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Kotlin</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">(ann: <span class="type">Ann</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">val</span> i = ann.value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h4><p>反射是一系列语言和库的特性，允许在运行是获取你代码结构。 Kotlin 把函数和属性作为语言的头等类，而且反射它们和使用函数式编程或反应是编程风格很像。</p>
<blockquote>
<p>On the Java platform, the runtime component required for using the reflection features is distributed as a separate JAR file (kotlin-reflect.jar). This is done to reduce the required size of the runtime library for applications that do not use reflection features. If you do use reflection, please make sure that the .jar file is added to the classpath of your project.</p>
</blockquote>
<h5 id="类引用"><a href="#类引用" class="headerlink" title="类引用"></a>类引用</h5><p>最基本的反射特性就是得到运行时的类引用。要获取引用并使之成为静态类可以使用字面类语法：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> c = MyClass::<span class="class"><span class="keyword">class</span></span></span><br></pre></td></tr></table></figure>
<p>引用是一种 KClass类型的值。你可以使用 KClass.properties 和 KClass.extensionProperties 获取类和父类的所有属性引用的列表。<br>注意这与 java 类的引用是不一样的。参看 java interop section</p>
<h5 id="函数引用"><a href="#函数引用" class="headerlink" title="函数引用"></a>函数引用</h5><p>当有一个像下面这样的函数声明时：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">isOdd</span><span class="params">(x: <span class="type">Int</span>)</span></span> =x % <span class="number">2</span> !=<span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>我们可以通过 isOdd(5) 轻松调用，同样我们也可以把它作为一个值传递给其它函数。我们可以使用 :: 操作符</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> numbers = listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">println(numbers.filter( ::isOdd) ) <span class="comment">//prints [1, 3]</span></span><br></pre></td></tr></table></figure>
<p>这里 ::isOdd 是是一个函数类型的值 (Int) -&gt; Boolean<br>注意现在 :: 操作符右边不能用语重载函数。将来，我们计划提供一个语法明确参数类型这样就可以使用明确的重载函数了。<br>如果需要使用一系列类，或者扩展函数，必须是需合格的，并且结果是扩展函数类型，比如。 String::toCharArray 就带来一个 String: String.() -&gt; CharArray 类型的扩展函数。</p>
<h5 id="例子：函数组合"><a href="#例子：函数组合" class="headerlink" title="例子：函数组合"></a>例子：函数组合</h5><p>考虑一下下面的函数：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> compose<span class="type">&lt;A, B, C&gt;</span><span class="params">(f: (<span class="type">B</span>)</span></span> -&gt; C, g: (A) -&gt; B): (A) -&gt; C &#123;</span><br><span class="line">	<span class="keyword">return</span> &#123;x -&gt; f(g(x))&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它返回一个由俩个传递进去的函数的组合。现在你可以把它用在可调用的引用上了：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">length</span><span class="params">(s: <span class="type">String</span>)</span></span> = s.size</span><br><span class="line"><span class="keyword">val</span> oddLength = compose(::isOdd, ::length)</span><br><span class="line"><span class="keyword">val</span> strings = listOf(<span class="string">"a"</span>, <span class="string">"ab"</span>, <span class="string">"abc"</span>)</span><br><span class="line">println(strings.filter(oddLength)) <span class="comment">// Prints "[a, abc]"</span></span><br></pre></td></tr></table></figure>
<h5 id="属性引用"><a href="#属性引用" class="headerlink" title="属性引用"></a>属性引用</h5><p>在 kotlin 中访问顶级类的属性，我们也可以使用 :: 操作符：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    println(::x.<span class="keyword">get</span>())</span><br><span class="line">    ::x.<span class="keyword">set</span>(<span class="number">2</span>)</span><br><span class="line">    println(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>::x 表达式评估为 KProperty 类型的属性，它允许我们使用 get() 读它的值或者使用名字取回它的属性。更多请参看docs on the KProperty class<br>对于可变的属性比如 var y =1 , ::y 返回类型为 [KMutableProperty]，它有 set() 方法<br>访问一个类的属性成员，我们这样修饰：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>(<span class="keyword">val</span> p: <span class="built_in">Int</span>)</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> prop = A::p</span><br><span class="line">    println(prop.<span class="keyword">get</span>(A(<span class="number">1</span>))) <span class="comment">// prints "1"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于扩展属性：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> String.lastChar: <span class="built_in">Char</span></span><br><span class="line">	<span class="keyword">get</span>() = <span class="keyword">this</span>[size - <span class="number">1</span>]</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">	println(String::lastChar.<span class="keyword">get</span>(<span class="string">"abc"</span>)) <span class="comment">// prints "c"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="与-java-反射调用"><a href="#与-java-反射调用" class="headerlink" title="与 java 反射调用"></a>与 java 反射调用</h5><p>在 java 平台上，标准库包括反射类的扩展，提供了到 java 反射对象的映射(参看kotlin.reflect.jvm 包)。比如，想找到一个备用字段或者 java getter 方法，你可以这样写：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlin.reflect.jvm.*</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>(<span class="keyword">val</span> p: <span class="built_in">Int</span>)</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">	println(A::p.javaGetter) <span class="comment">// prints "public final int A.getP()"</span></span><br><span class="line">	println(A::p.javaField) <span class="comment">// prints "private final int A.p"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="构造函数引用"><a href="#构造函数引用" class="headerlink" title="构造函数引用"></a>构造函数引用</h5><p>构造函数可以像方法或属性那样引用。只需要使用 :: 操作符并加上类名。下面的函数是一个没有参数并且返回类型是 Foo :</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">calss Foo</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">function</span><span class="params">(factory : ()</span></span> -&gt; Foo) &#123;</span><br><span class="line">	<span class="keyword">val</span> x: Foo = factory()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以像下面这样使用：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function(:: Foo)</span><br></pre></td></tr></table></figure>
<h4 id="动态类型"><a href="#动态类型" class="headerlink" title="动态类型"></a>动态类型</h4><p>作为静态类型的语言，kotlin任然拥有与无类型或弱类型语言的调用，比如javaScript。为了方便使用， dynamic 应而生：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> dyn: <span class="keyword">dynamic</span> = ...</span><br></pre></td></tr></table></figure>
<p>dynamic 类型关闭了 kotlin 的类型检查：</p>
<blockquote>
<p>这样的类型可以分配任意变量或者在任意的地方作为参数传递 任何值都可以分配为 dynamic 类型，或者作为参数传递给任何接受 dynamic 类型参数的函数 这样的类型不做 null 检查</p>
</blockquote>
<p>dynamic 最奇特的特性就是可以在 dynamic 变量上调用任何属性或任何方法： (The most peculiar feature of dynamic is that we are allowed to call any property or function with any parameters on a dynamic variable:)</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dyn.whatever(<span class="number">1</span>, <span class="string">"foo"</span>, dyn) <span class="comment">// 'whatever' is not defined anywhere</span></span><br><span class="line">dyn.whatever(*array(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))</span><br></pre></td></tr></table></figure>
<p>在 javaScript 平台上这样的代码会编译为 ‘as is’: dyn.whatever(1) 在 kotlin 中变成了 javaScript 中的代码 (On the JavaScript platform this code will be compiled “as is”: dyn.whatever(1) in Kotlin becomes dyn.whatever(1) in the generated JavaScript code.)<br>动态调用可以返回 dynamic 作为结果，因此我们可以轻松实现链式调用：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dyn.foo().bar.bat(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>当给动态调用传递一个 lambda 表达式时，所有的参数默认都是 dynamic ：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dyn.foo &#123;</span><br><span class="line">	x -&gt; x.bar() <span class="comment">// x is dynamic</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/learn/" rel="tag"><i class="fa fa-tag"></i> learn</a>
          
            <a href="/tags/Kotlin/" rel="tag"><i class="fa fa-tag"></i> Kotlin</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/05/14/设计模式：单例模式/" rel="next" title="设计模式：单例模式">
                <i class="fa fa-chevron-left"></i> 设计模式：单例模式
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/05/15/设计模式：简介/" rel="prev" title="设计模式：简介">
                设计模式：简介 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
		<div class="sidebar-inner">

		  

		  
			<ul class="sidebar-nav motion-element">
			  <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
				文章目录
			  </li>
			  <li class="sidebar-nav-overview" data-target="site-overview-wrap">
				站点概览
			  </li>
			</ul>
		  

			  <section class="site-overview-wrap sidebar-panel">
				<div class="site-overview">
				  <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
					
					  <img class="site-author-image" itemprop="image" src="/assets/img/head.jpg" alt="三毛六">
					
					  <p class="site-author-name" itemprop="name">三毛六</p>
					  <p class="site-description motion-element" itemprop="description">编程学习，经验分享。<br>生活记录，文章摘抄。<br>随缘更新，欢迎收藏。</p>
				  </div>

				  
					<nav class="site-state motion-element">
					  
						<div class="site-state-item site-state-posts">
						
						  <a href="/archives/">
						
							<span class="site-state-item-count">44</span>
							<span class="site-state-item-name">日志</span>
						  </a>
						</div>
					  

					  

					  
						
						
						<div class="site-state-item site-state-tags">
						  <a href="/tags/index.html">
							
							
							  
							
							  
							
							  
							
							  
							
							  
							
							  
							
							  
							
							  
							
							  
							
							  
							
							  
							
							  
							
							  
							
							  
							
							  
							
							  
							
							  
							
							  
							
							  
							
							  
							
							  
							
							  
							
							  
							
							  
							
							  
							
							  
							
							  
							
							  
							
							  
							
							  
							
							<span class="site-state-item-count">30</span>
							<span class="site-state-item-name">标签</span>
						  </a>
						</div>
					  
					</nav>
				  

				  
					<div class="feed-link motion-element">
					  <a href="/atom.xml" rel="alternate">
						<i class="fa fa-rss"></i>
						RSS
					  </a>
					</div>
				  

				  
					<div class="links-of-author motion-element">
					  
						<span class="links-of-author-item">
						  <a href="https://github.com/17750669630" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i>GitHub</a>
						  
						</span>
					  
						<span class="links-of-author-item">
						  <a href="mailto:1164999589@qq.com" target="_blank" title="E-Mail"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
						  
						</span>
					  
						<span class="links-of-author-item">
						  <a href="https://blog.csdn.net/lp1164999589" target="_blank" title="CSDN"><i class="fa fa-fw fa-globe"></i>CSDN</a>
						  
						</span>
					  
						<span class="links-of-author-item">
						  <a href="https://weibo.com/lp1164999589" target="_blank" title="weibo"><i class="fa fa-fw fa-weibo"></i>weibo</a>
						  
						</span>
					  
					</div>
				  

				  
				  

				  
				  

				  
					
				  
				  

				</div>
			  </section>

			  
			  <!--noindex-->
				<section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
				  <div class="post-toc">

					
					  
					

					
					  <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#其它"><span class="nav-number">1.</span> <span class="nav-text">其它</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#多重声明"><span class="nav-number">1.1.</span> <span class="nav-text">多重声明</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#例子：一个函数返回俩个值"><span class="nav-number">1.1.1.</span> <span class="nav-text">例子：一个函数返回俩个值</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#例子：多重声明和-Map"><span class="nav-number">1.1.2.</span> <span class="nav-text">例子：多重声明和 Map</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Ranges"><span class="nav-number">1.2.</span> <span class="nav-text">Ranges</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#工作原理"><span class="nav-number">1.2.1.</span> <span class="nav-text">工作原理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#范围指标"><span class="nav-number">1.2.2.</span> <span class="nav-text">范围指标</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#常见的接口的定义"><span class="nav-number">1.2.3.</span> <span class="nav-text">常见的接口的定义</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#类的实现"><span class="nav-number">1.2.4.</span> <span class="nav-text">类的实现</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#一些实用的函数"><span class="nav-number">1.2.5.</span> <span class="nav-text">一些实用的函数</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#类型检查和转换"><span class="nav-number">1.3.</span> <span class="nav-text">类型检查和转换</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#is-is-表达式"><span class="nav-number">1.3.1.</span> <span class="nav-text">is !is 表达式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#智能转换"><span class="nav-number">1.3.2.</span> <span class="nav-text">智能转换</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#“不安全”的转换符"><span class="nav-number">1.3.3.</span> <span class="nav-text">“不安全”的转换符</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#“安全”转换符"><span class="nav-number">1.3.4.</span> <span class="nav-text">“安全”转换符</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#This-表达式"><span class="nav-number">1.4.</span> <span class="nav-text">This 表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#this使用范围"><span class="nav-number">1.4.1.</span> <span class="nav-text">this使用范围</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#等式"><span class="nav-number">1.5.</span> <span class="nav-text">等式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#参照相等"><span class="nav-number">1.5.1.</span> <span class="nav-text">参照相等</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#结构相等"><span class="nav-number">1.5.2.</span> <span class="nav-text">结构相等</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#运算符重载"><span class="nav-number">1.6.</span> <span class="nav-text">运算符重载</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#转换"><span class="nav-number">1.6.1.</span> <span class="nav-text">转换</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#一元运算符"><span class="nav-number">1.6.2.</span> <span class="nav-text">一元运算符</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#二元操作符"><span class="nav-number">1.6.3.</span> <span class="nav-text">二元操作符</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#空安全"><span class="nav-number">1.7.</span> <span class="nav-text">空安全</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#可空类型和非空类型"><span class="nav-number">1.7.1.</span> <span class="nav-text">可空类型和非空类型</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#在条件中检查-null"><span class="nav-number">1.7.2.</span> <span class="nav-text">在条件中检查 null</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#安全调用"><span class="nav-number">1.7.3.</span> <span class="nav-text">安全调用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Elvis-操作符"><span class="nav-number">1.7.4.</span> <span class="nav-text">Elvis 操作符</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#操作符"><span class="nav-number">1.7.5.</span> <span class="nav-text">!! 操作符</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#安全转换"><span class="nav-number">1.7.6.</span> <span class="nav-text">安全转换</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#异常"><span class="nav-number">1.8.</span> <span class="nav-text">异常</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#异常类"><span class="nav-number">1.8.1.</span> <span class="nav-text">异常类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#try-是一个表达式"><span class="nav-number">1.8.2.</span> <span class="nav-text">try 是一个表达式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#检查异常"><span class="nav-number">1.8.3.</span> <span class="nav-text">检查异常</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#注解"><span class="nav-number">1.9.</span> <span class="nav-text">注解</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#注解声明"><span class="nav-number">1.9.1.</span> <span class="nav-text">注解声明</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#用法"><span class="nav-number">1.9.2.</span> <span class="nav-text">用法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#构造函数"><span class="nav-number">1.9.3.</span> <span class="nav-text">构造函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Lambdas"><span class="nav-number">1.9.4.</span> <span class="nav-text">Lambdas</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#java-注解"><span class="nav-number">1.9.5.</span> <span class="nav-text">java 注解</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#反射"><span class="nav-number">1.10.</span> <span class="nav-text">反射</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#类引用"><span class="nav-number">1.10.1.</span> <span class="nav-text">类引用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#函数引用"><span class="nav-number">1.10.2.</span> <span class="nav-text">函数引用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#例子：函数组合"><span class="nav-number">1.10.3.</span> <span class="nav-text">例子：函数组合</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#属性引用"><span class="nav-number">1.10.4.</span> <span class="nav-text">属性引用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#与-java-反射调用"><span class="nav-number">1.10.5.</span> <span class="nav-text">与 java 反射调用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#构造函数引用"><span class="nav-number">1.10.6.</span> <span class="nav-text">构造函数引用</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#动态类型"><span class="nav-number">1.11.</span> <span class="nav-text">动态类型</span></a></li></ol></li></ol></div>
					

				  </div>
				</section>
			  <!--/noindex-->
			  

			  
		  
				
					<div class="audio-wrapper">
						<audio loop="loop" preload="none" id="audioPlay">
							<source src="/music/刘惜君 - 那时候的我.mp3" type="audio/mp3">
							<!--<source src="https://coding.net/u/sanmaoliu/p/PrivatePhoto/git/raw/master/刘惜君那时候的我.mp3" type="audio/mp3">-->
						</audio>
						<div class="audio-left">
						<img src="/images/play.png" id="audioPlayer">
						</div>
						<div class="audio-right">
							<p style="max-width: 536px;">刘惜君-那时候的我</p>
							<div class="progress-bar-bg" id="progressBarBg"><span id="progressDot"></span>
								<div class="progress-bar" id="progressBar"></div>
							</div>
							<div class="audio-time"><span class="audio-length-current" id="audioCurTime">00:00</span><span class="audio-length-total" id="audioTotalTime">03:52</span></div>
						</div>
					</div>
							
				
				

			<!--<audio id="audio" src="/music/刘惜君 - 那时候的我.mp3" controls autoplay="true" width=230 height=86></audio>-->
			<!--网易云音乐模块 iframe-->
			<!--<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=255204&auto=0&height=66"></iframe>-->
			<!--网易云音乐模块 flash-->
			<!--<embed src="//music.163.com/style/swf/widget.swf?sid=255204&type=2&auto=0&width=200&height=32" width="200" height="52"  allowNetworking="all"></embed>-->
		</div>
		
	<script type="text/javascript" src="http://ajax.aspnetcdn.com/ajax/jQuery/jquery-1.8.0.js"></script>
	<script type="text/javascript">
	$(document).ready(function () {
	// 控制音频文件名显示宽度

	var maxW = $('.audio-right').width();
	$('.audio-right p').css({
		"max-width": maxW
	});

	initAudioEvent();
	});

	/**
	 * 初始化音频控制事件
	 */
	function initAudioEvent() {
		var audio = $('audio')[0];
		$('#audioPlay').volume = 0.1;

		// 点击播放/暂停图片时，控制音乐的播放与暂停
		$('#audioPlayer').click(function () {
			// 监听音频播放时间并更新进度条
			audio.addEventListener('timeupdate', function () {
				updateProgress(audio);
			}, false);

			// 监听播放完成事件
			audio.addEventListener('ended', function () {
				audioEnded();
			}, false);

			// 改变播放/暂停图片
			if (audio.paused) {
				// 开始播放当前点击的音频
				audio.play();
				$('#audioPlayer').attr('src', '/images/pause.png');
			} else {
				audio.pause();
				$('#audioPlayer').attr('src', '/images/play.png');
			}
		});

		
		
		// 点击进度条跳到指定点播放
		// PS：此处不要用click，否则下面的拖动进度点事件有可能在此处触发，此时e.offsetX的值非常小，会导致进度条弹回开始处（简直不能忍！！）
		$('#progressBarBg').on('mousedown', function (e) {
			// 只有音乐开始播放后才可以调节，已经播放过但暂停了的也可以
			if (!audio.paused) {
				var pgsWidth = $('.progress-bar-bg').width();
				var rate = e.offsetX / pgsWidth;
				audio.currentTime = audio.duration * rate;
				updateProgress(audio);
			}
			else if (audio.paused) {
				audio.addEventListener('timeupdate', function () {
					updateProgress(audio);
				}, false);

				// 监听播放完成事件
				audio.addEventListener('ended', function () {
					audioEnded();
				}, false);

				
				var pgsWidth = $('.progress-bar-bg').width();
				var rate = e.offsetX / pgsWidth;
				
				$('#progressBar').css('width', rate * 100 + '%');
				$('#progressDot').css('left', rate * 100 + '%');
				$('#audioCurTime').html(transTime(232 * rate));
				
				//audio.currentTime = audio.duration * rate;
				audio.currentTime = 232 * rate;
				
				// 改变播放/暂停图片
				// 开始播放当前点击的音频
				audio.play();
				$('#audioPlayer').attr('src', '/images/pause.png');
	
			}
		});
		
		
		
	}

	/**
	 * 更新进度条与当前播放时间
	 * @param {object} audio - audio对象
	 */
	function updateProgress(audio) {
		var value = audio.currentTime / audio.duration;
		$('#progressBar').css('width', value * 100 + '%');
		$('#progressDot').css('left', value * 100 + '%');
		$('#audioCurTime').html(transTime(audio.currentTime));
	}

	/**
	 * 播放完成时把进度调回开始的位置
	 */
	function audioEnded() {
		$('#progressBar').css('width', 0);
		$('#progressDot').css('left', 0);
		$('#audioCurTime').html('00:00');
		$('#audioPlayer').attr('src', '/images/play.png');
	}

	/**
	 * 音频播放时间换算
	 * @param {number} value - 音频当前播放时间，单位秒
	 */
	function transTime(value) {
		var time = "";
		var h = parseInt(value / 3600);
		value %= 3600;
		var m = parseInt(value / 60);
		var s = parseInt(value % 60);
		if (h > 0) {
			time = formatTime(h + ":" + m + ":" + s);
		} else {
			time = formatTime(m + ":" + s);
		}

		return time;
	}

	/**
	 * 格式化时间显示，补零对齐
	 * eg：2:4  -->  02:04
	 * @param {string} value - 形如 h:m:s 的字符串 
	 */
	function formatTime(value) {
		var time = "";
		var s = value.split(':');
		var i = 0;
		for (; i < s.length - 1; i++) {
			time += s[i].length == 1 ? ("0" + s[i]) : s[i];
			time += ":";
		}
		time += s[i].length == 1 ? ("0" + s[i]) : s[i];

		return time;
	}
	</script>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">三毛六</span>

  

  
</div>



<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
  本站访客数:261343<span id="busuanzi_value_site_uv"></span>
</span>
</div>


<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共48.2k字</span>
</div>

        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>














  













  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="true"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.2.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.2.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.2.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.2.0"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.2.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.2.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.2.0"></script>



  



	





  





  










  





  

  

  

  

  
  

  

  

  

  

  


	
	<script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>
	
	
	
	
	<!-- 页面点击小红心 -->
	

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/tororo.model.json"},"react":{"opacityDefault":1,"opacityOnHover":1},"display":{"position":"left","width":150,"height":300,"vOffset":-120,"mobileShow":false},"log":false,"tagMode":false});</script></body>
</html>



<script type="text/javascript">
/* 鼠标点击出现社会主义核心价值观 */
var a_idx = 0;
jQuery(document).ready(function($) {
	var random=Math.floor(Math.random()*20+1);
    var cls='change'+random;
	$("body").attr("class", cls);

    $("body").click(function(e) {
		
	var a = new Array("富强", "民主", "文明", "和谐", "自由", "平等", "公正" ,"法治", "爱国", "敬业", "诚信", "友善");
	var $i = $("<span/>").text(a[a_idx]);
			a_idx = (a_idx + 1) % a.length;
	var x = e.pageX,
			y = e.pageY;
			$i.css({
				"z-index": 999,
				"top": y - 20,
				"left": x,
				"position": "absolute",
				"font-weight": "bold",
				"color": "#ff6651",
				"-webkit-user-select": "none",
				"-moz-user-select": "none",
				"-ms-user-select": "none",
				"user-select": "none"
			});
			$("body").append($i);
			$i.animate({
				"top": y - 180,
				"opacity": 0
			},
			1500,
			function() {
				$i.remove();
			});
			
			
    });
});



</script>

