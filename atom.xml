<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>三毛六的博客</title>
  <icon>https://www.gravatar.com/avatar/7bdda10fd64420096550231235845b7c</icon>
  <subtitle>你来了呀~ 快看看吧！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.sanmaoliu.com/"/>
  <updated>2018-04-28T08:27:22.000Z</updated>
  <id>http://www.sanmaoliu.com/</id>
  
  <author>
    <name>三毛六</name>
    <email>1164999589@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hello World</title>
    <link href="http://www.sanmaoliu.com/2019/07/08/hello-world/"/>
    <id>http://www.sanmaoliu.com/2019/07/08/hello-world/</id>
    <published>2019-07-08T03:08:23.133Z</published>
    <updated>2018-04-28T08:27:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><a id="more"></a><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;Quick-Start&quot;&gt;&lt;a href=&quot;#Quick-Start&quot; class=&quot;headerlink&quot; title=&quot;Quick Start&quot;&gt;&lt;/a&gt;Quick Start&lt;/h2&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>小记</title>
    <link href="http://www.sanmaoliu.com/2018/12/18/%E5%B0%8F%E8%AE%B0/"/>
    <id>http://www.sanmaoliu.com/2018/12/18/小记/</id>
    <published>2018-12-18T13:02:00.000Z</published>
    <updated>2018-12-18T13:04:04.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="最近太忙了，什么也没有更新，内网APP做的差不多了"><a href="#最近太忙了，什么也没有更新，内网APP做的差不多了" class="headerlink" title="最近太忙了，什么也没有更新，内网APP做的差不多了"></a>最近太忙了，什么也没有更新，内网APP做的差不多了</h3><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;最近太忙了，什么也没有更新，内网APP做的差不多了&quot;&gt;&lt;a href=&quot;#最近太忙了，什么也没有更新，内网APP做的差不多了&quot; class=&quot;headerlink&quot; title=&quot;最近太忙了，什么也没有更新，内网APP做的差不多了&quot;&gt;&lt;/a&gt;最近太忙了，什么也没有更新，内网APP做的差不多了&lt;/h3&gt;
    
    </summary>
    
    
      <category term="diray" scheme="http://www.sanmaoliu.com/tags/diray/"/>
    
  </entry>
  
  <entry>
    <title>根据宽度实现屏幕适配</title>
    <link href="http://www.sanmaoliu.com/2018/07/01/%E6%A0%B9%E6%8D%AE%E5%AE%BD%E5%BA%A6%E5%AE%9E%E7%8E%B0%E5%B1%8F%E5%B9%95%E9%80%82%E9%85%8D/"/>
    <id>http://www.sanmaoliu.com/2018/07/01/根据宽度实现屏幕适配/</id>
    <published>2018-07-01T06:51:54.000Z</published>
    <updated>2018-07-12T07:03:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>根据宽度实现高度等比例实现屏幕适配的方法</p><a id="more"></a><p><strong>梳理需求</strong></p><p>首先来梳理下我们的需求，一般我们设计图都是以固定的尺寸来设计的。比如以分辨率1920px <em> 1080px来设计，以density为3来标注，也就是屏幕其实是640dp </em> 360dp。如果我们想在所有设备上显示完全一致，其实是不现实的，因为屏幕高宽比不是固定的，16:9、4:3甚至其他宽高比层出不穷，宽高比不同，显示完全一致就不可能了。但是通常下，我们只需要以宽或高一个维度去适配，比如我们Feed是上下滑动的，只需要保证在所有设备中宽的维度上显示一致即可，再比如一个不支持上下滑动的页面，那么需要保证在高这个维度上都显示一致，尤其不能存在某些设备上显示不全的情况。同时考虑到现在基本都是以dp为单位去做的适配，如果新的方案不支持dp，那么迁移成本也非常高。</p><p>因此，总结下大致需求如下：</p><ol><li>支持以宽或者高一个维度去适配，保持该维度上和设计图一致；</li><li>支持dp和sp单位，控制迁移成本到最小。</li></ol><p><strong>找兼容突破口</strong></p><p>从dp和px的转换公式 ：px = dp * density</p><p>可以看出，如果设计图宽为360dp，想要保证在所有设备计算得出的px值都正好是屏幕宽度的话，我们只能修改 density 的值。</p><p>通过阅读源码，我们可以得知，density 是 DisplayMetrics 中的成员变量，而 DisplayMetrics 实例通过 Resources#getDisplayMetrics 可以获得，而Resouces通过Activity或者Application的Context获得。</p><p>先来熟悉下 DisplayMetrics 中和适配相关的几个变量：</p><ul><li>DisplayMetrics#density 就是上述的density</li><li>DisplayMetrics#densityDpi 就是上述的dpi</li><li>DisplayMetrics#scaledDensity 字体的缩放因子，正常情况下和density相等，但是调节系统字体大小后会改变这个值</li></ul><p><strong>那么是不是所有的dp和px的转换都是通过 DisplayMetrics 中相关的值来计算的呢？</strong></p><p>首先来看看布局文件中dp的转换，最终都是调用 TypedValue#applyDimension(int unit, float value, DisplayMetrics metrics) 来进行转换:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">float</span> <span class="title">applyDimension</span><span class="params">(<span class="keyword">int</span> unit,<span class="keyword">float</span> value,DispayMetrics metrics)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (unit) &#123;</span><br><span class="line">        <span class="keyword">case</span> COMPLEX_UNIT_PX:</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        <span class="keyword">case</span> COMPLEX_UNIT_DIP:</span><br><span class="line">            <span class="keyword">return</span> value * metrics.density;</span><br><span class="line">        <span class="keyword">case</span> COMPLEX_UNIT_SP:</span><br><span class="line">            <span class="keyword">return</span> value * metrics.scaledDensity;</span><br><span class="line">        <span class="comment">//.... 其他无关</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终方案</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScreenAdaptation</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">float</span> sNoncompatDensity;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">float</span> sNoncompatScaledDensity;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setCustomDensity</span><span class="params">(@NonNull Activity activity, @NonNull <span class="keyword">final</span> Application application)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> DisplayMetrics appDisplayMetrics = application.getResources().getDisplayMetrics();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sNoncompatDensity == <span class="number">0</span>) &#123;</span><br><span class="line">            sNoncompatDensity = appDisplayMetrics.density;</span><br><span class="line">            sNoncompatScaledDensity = appDisplayMetrics.scaledDensity;</span><br><span class="line">            application.registerComponentCallbacks(<span class="keyword">new</span> ComponentCallbacks() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onConfigurationChanged</span><span class="params">(Configuration newConfig)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (newConfig != <span class="keyword">null</span> &amp;&amp; newConfig.fontScale &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        sNoncompatScaledDensity = application.getResources().getDisplayMetrics().scaledDensity;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLowMemory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">float</span> targetDensity = appDisplayMetrics.widthPixels / <span class="number">360</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">float</span> targetScaledDensity = targetDensity * (sNoncompatScaledDensity / sNoncompatDensity);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> targetDensityDpi = (<span class="keyword">int</span>) (<span class="number">160</span> * targetDensity);</span><br><span class="line"></span><br><span class="line">        appDisplayMetrics.density = targetDensity;</span><br><span class="line">        appDisplayMetrics.scaledDensity = targetScaledDensity;</span><br><span class="line">        appDisplayMetrics.densityDpi = targetDensityDpi;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> DisplayMetrics activityDisplayMetrics = activity.getResources().getDisplayMetrics();</span><br><span class="line">        activityDisplayMetrics.density = targetDensity;</span><br><span class="line">        activityDisplayMetrics.scaledDensity = targetScaledDensity;</span><br><span class="line">        activityDisplayMetrics.densityDpi = targetDensityDpi;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    ScreenAdaptation.setCustomDensity(<span class="keyword">this</span>,getApplication());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;根据宽度实现高度等比例实现屏幕适配的方法&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://www.sanmaoliu.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>adb failed to start daemon 的解决办法</title>
    <link href="http://www.sanmaoliu.com/2018/06/23/adb%20failed%20to%20start%20daemon%20%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
    <id>http://www.sanmaoliu.com/2018/06/23/adb failed to start daemon 的解决办法/</id>
    <published>2018-06-23T02:15:59.000Z</published>
    <updated>2018-06-29T02:17:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>adb failed to start daemon 的解决办法</p><a id="more"></a><p>Terminal里面运行adb nodaemon server 就解决的了</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;adb failed to start daemon 的解决办法&lt;/p&gt;
    
    </summary>
    
    
      <category term="adb" scheme="http://www.sanmaoliu.com/tags/adb/"/>
    
  </entry>
  
  <entry>
    <title>recyclerview移动到指定的position</title>
    <link href="http://www.sanmaoliu.com/2018/06/20/recyclerview%E7%A7%BB%E5%8A%A8%E5%88%B0%E6%8C%87%E5%AE%9A%E7%9A%84position/"/>
    <id>http://www.sanmaoliu.com/2018/06/20/recyclerview移动到指定的position/</id>
    <published>2018-06-20T02:02:21.000Z</published>
    <updated>2018-06-29T02:27:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>下拉刷新后最后一项调到最顶部</p><p><img src="https://coding.net/u/sanmaoliu/p/pictures/git/raw/master/imageview.gif" alt></p><a id="more"></a><p>方法实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//目标项是否在最后一个可见项之后</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">boolean</span> mShouldScroll;</span><br><span class="line">   <span class="comment">//记录目标项位置</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> mToPosition;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//滑动到指定位置</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">smoothMoveToPosition</span><span class="params">(RecyclerView mRecyclerView, <span class="keyword">final</span> <span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (mRecyclerView != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">// 第一个可见位置</span></span><br><span class="line">           <span class="keyword">int</span> firstItem = mRecyclerView.getChildLayoutPosition(mRecyclerView.getChildAt(<span class="number">0</span>));</span><br><span class="line">           <span class="comment">// 最后一个可见位置</span></span><br><span class="line">           <span class="keyword">int</span> lastItem = mRecyclerView.getChildLayoutPosition(mRecyclerView.getChildAt(mRecyclerView.getChildCount() -</span><br><span class="line">                   <span class="number">1</span>));</span><br><span class="line">           <span class="keyword">if</span> (position &lt; firstItem) &#123;</span><br><span class="line">               <span class="comment">// 第一种可能:跳转位置在第一个可见位置之前</span></span><br><span class="line">               mRecyclerView.smoothScrollToPosition(position);</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (position &lt;= lastItem) &#123;</span><br><span class="line">               <span class="comment">// 第二种可能:跳转位置在第一个可见位置之后</span></span><br><span class="line">               <span class="keyword">int</span> movePosition = position - firstItem;</span><br><span class="line">               <span class="keyword">if</span> (movePosition &gt;= <span class="number">0</span> &amp;&amp; movePosition &lt; mRecyclerView.getChildCount()) &#123;</span><br><span class="line">                   <span class="keyword">int</span> top = mRecyclerView.getChildAt(movePosition).getTop();</span><br><span class="line">                   mRecyclerView.smoothScrollBy(<span class="number">0</span>, top);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">// 第三种可能:跳转位置在最后可见项之后</span></span><br><span class="line">               mRecyclerView.smoothScrollToPosition(position);</span><br><span class="line">               mToPosition = position;</span><br><span class="line">               mShouldScroll = <span class="keyword">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mIRecyclerView.addOnScrollListener(<span class="keyword">new</span> RecyclerView.OnScrollListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onScrollStateChanged</span><span class="params">(RecyclerView recyclerView, <span class="keyword">int</span> newState)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">super</span>.onScrollStateChanged(recyclerView, newState);</span><br><span class="line">                <span class="keyword">if</span> (mShouldScroll) &#123;</span><br><span class="line">                    mShouldScroll = <span class="keyword">false</span>;</span><br><span class="line">                    smoothMoveToPosition(mIRecyclerView, mToPosition);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">数据返回后</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">returnList</span><span class="params">(<span class="keyword">final</span> List&lt;ItemBean&gt; beans)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> List&lt;ItemBean&gt; listNull = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++)</span><br><span class="line">            listNull.add(<span class="keyword">new</span> ItemBean(<span class="string">""</span>, <span class="string">""</span>, <span class="string">""</span>));</span><br><span class="line">        list.addAll(listNull);</span><br><span class="line">        adapter.notifyDataSetChanged();</span><br><span class="line">        smoothMoveToPosition(mIRecyclerView, list.size() - listNull.size() + <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;下拉刷新后最后一项调到最顶部&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://coding.net/u/sanmaoliu/p/pictures/git/raw/master/imageview.gif&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://www.sanmaoliu.com/tags/Android/"/>
    
      <category term="recyclerView" scheme="http://www.sanmaoliu.com/tags/recyclerView/"/>
    
  </entry>
  
  <entry>
    <title>recyclerview实现runLayoutAnimation</title>
    <link href="http://www.sanmaoliu.com/2018/06/18/recyclerview%E6%AF%8F%E6%AC%A1%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE%E5%90%8E%E5%90%AF%E5%8A%A8%E5%B8%83%E5%B1%80%E5%8A%A8%E7%94%BB/"/>
    <id>http://www.sanmaoliu.com/2018/06/18/recyclerview每次获取数据后启动布局动画/</id>
    <published>2018-06-18T01:41:46.000Z</published>
    <updated>2018-06-29T02:08:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>如题，就是每次获取玩数据之后重新调用一次布局动画。</p><a id="more"></a><p>下面两个放在res下面anim文件夹下面哦</p><p>item_animation_from_top.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">set</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">android:duration</span>=<span class="string">"500"</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">translate</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:fromYDelta</span>=<span class="string">"-50%"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:interpolator</span>=<span class="string">"@android:anim/accelerate_decelerate_interpolator"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:toYDelta</span>=<span class="string">"0"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">alpha</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:fromAlpha</span>=<span class="string">"0.0"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:interpolator</span>=<span class="string">"@android:anim/accelerate_decelerate_interpolator"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:toAlpha</span>=<span class="string">"1.0"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br></pre></td></tr></table></figure><p>layout_animation_from_bottom.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">layoutAnimation</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">                 <span class="attr">android:animation</span>=<span class="string">"@anim/item_animation_from_top"</span></span></span><br><span class="line"><span class="tag">                 <span class="attr">android:animationOrder</span>=<span class="string">"normal"</span></span></span><br><span class="line"><span class="tag">                 <span class="attr">android:delay</span>=<span class="string">"15%"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>实现函数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//布局动画</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">runLayoutAnimation</span><span class="params">(<span class="keyword">final</span> RecyclerView recyclerView)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Context context = recyclerView.getContext();</span><br><span class="line">    <span class="keyword">final</span> LayoutAnimationController controller = AnimationUtils.loadLayoutAnimation(</span><br><span class="line">        context,R.anim.layout_animation_from_bottom);</span><br><span class="line">    recyclerView.setLayoutAnimation(controller);</span><br><span class="line">    recyclerView.getAdapter().notifyDataSetChanged();</span><br><span class="line">    recyclerView.scheduleLayoutAnimation();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">returnList</span><span class="params">(<span class="keyword">final</span> List&lt;ItemBean&gt; beans)</span> </span>&#123;</span><br><span class="line">        .......</span><br><span class="line">        list.addAll(beans);</span><br><span class="line">        runLayoutAnimation(mIRecyclerView);</span><br><span class="line">        adapter.notifyDataSetChanged();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如题，就是每次获取玩数据之后重新调用一次布局动画。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://www.sanmaoliu.com/tags/Android/"/>
    
      <category term="recyclerView" scheme="http://www.sanmaoliu.com/tags/recyclerView/"/>
    
  </entry>
  
  <entry>
    <title>jsoup获取不到完整内容</title>
    <link href="http://www.sanmaoliu.com/2018/06/15/jsoup%E7%BD%91%E9%A1%B5%E8%BF%87%E5%A4%A7%E6%89%BE%E4%B8%8D%E5%88%B0%E5%86%85%E5%AE%B9/"/>
    <id>http://www.sanmaoliu.com/2018/06/15/jsoup网页过大找不到内容/</id>
    <published>2018-06-15T03:07:45.000Z</published>
    <updated>2018-06-15T03:11:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>遇到不能完整获取响应内容时，一般有以下几个原因。</p><ol><li>网络异常，造成读取不全。这个很少发生，因为jsoup会报告exception</li><li>网络超时，此时可以设置 connection.timeout(n) 增加超时时间。</li><li>一切看起来都正常，也没有异常发生。 但是获取的数据就是少了一截。（究竟是为什么呢？进来就告诉你）</li></ol><a id="more"></a><p>仔细分析获取到的数据，发现得到数据都是1024k。</p><p>如果获取到的数据不超过1024k，程序正常，得到的数据也正常。</p><p>一旦数据超过1024k时，数据就只有预期得到数据的前1024k字节了。</p><p>仔细查找jsoup的api 发现，默认设置下，jsoup最大获取的响应长度正好时1M。</p><p>所以这个时候只要设置 connection.maxBodySize(0)，设置为0，就可以得到不限响应长度的数据了。</p><p>完整代码就是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Document = Jsoup.connect(url)  </span><br><span class="line">    .header(<span class="string">"Accept-Encoding"</span>, <span class="string">"gzip, deflate"</span>)  </span><br><span class="line">    .userAgent(<span class="string">"Mozilla/5.0 (Windows NT 6.1; WOW64; rv:23.0) Gecko/20100101 Firefox/23.0"</span>)  </span><br><span class="line">    .maxBodySize(<span class="number">0</span>)  </span><br><span class="line">    .timeout(<span class="number">600000</span>)  </span><br><span class="line">    .get();</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;遇到不能完整获取响应内容时，一般有以下几个原因。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;网络异常，造成读取不全。这个很少发生，因为jsoup会报告exception&lt;/li&gt;
&lt;li&gt;网络超时，此时可以设置 connection.timeout(n) 增加超时时间。&lt;/li&gt;
&lt;li&gt;一切看起来都正常，也没有异常发生。 但是获取的数据就是少了一截。（究竟是为什么呢？进来就告诉你）&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://www.sanmaoliu.com/tags/Android/"/>
    
      <category term="jsoup" scheme="http://www.sanmaoliu.com/tags/jsoup/"/>
    
  </entry>
  
  <entry>
    <title>ImageViewer应用1</title>
    <link href="http://www.sanmaoliu.com/2018/06/11/ImageViewer1/"/>
    <id>http://www.sanmaoliu.com/2018/06/11/ImageViewer1/</id>
    <published>2018-06-11T08:17:45.000Z</published>
    <updated>2018-06-11T08:17:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>ImageViewer</p><ol><li>Glide v4实现图片旋转</li><li>Glide v4实现高斯模糊</li><li>如果宽度大于长度则旋转</li></ol><a id="more"></a><h4 id="Glide-v4实现图片旋转"><a href="#Glide-v4实现图片旋转" class="headerlink" title="Glide v4实现图片旋转"></a>Glide v4实现图片旋转</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> android.content.Context;</span><br><span class="line"><span class="keyword">import</span> android.graphics.Bitmap;</span><br><span class="line"><span class="keyword">import</span> android.graphics.Matrix;</span><br><span class="line"><span class="keyword">import</span> android.support.annotation.NonNull;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;</span><br><span class="line"><span class="keyword">import</span> com.bumptech.glide.load.resource.bitmap.BitmapTransformation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.security.MessageDigest;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span>:2018/6/9 at 15:57</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: Glide实现图片旋转</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RotateTransformation</span> <span class="keyword">extends</span> <span class="title">BitmapTransformation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> rotateRotationAngle = <span class="number">0f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RotateTransformation</span><span class="params">(Context context, <span class="keyword">float</span> rotateRotationAngle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.rotateRotationAngle = rotateRotationAngle;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Bitmap <span class="title">transform</span><span class="params">(BitmapPool pool, Bitmap toTransform, <span class="keyword">int</span> outWidth, <span class="keyword">int</span> outHeight)</span> <span class="keyword">throws</span></span></span><br><span class="line"><span class="function">            OutOfMemoryError </span>&#123;</span><br><span class="line">        Matrix matrix = <span class="keyword">new</span> Matrix();</span><br><span class="line">        matrix.postRotate(rotateRotationAngle);</span><br><span class="line">        <span class="keyword">return</span> Bitmap.createBitmap(toTransform, <span class="number">0</span>, <span class="number">0</span>, toTransform.getWidth(), toTransform.getHeight(), matrix, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateDiskCacheKey</span><span class="params">(@NonNull MessageDigest messageDigest)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Glide.with(getActivity())</span><br><span class="line">.load(resource)</span><br><span class="line">.apply(<span class="keyword">new</span> RequestOptions().transform(<span class="keyword">new</span> RotateTransformation(getContext(), <span class="number">90f</span>)))</span><br><span class="line">.into();</span><br></pre></td></tr></table></figure><h4 id="Glide-v4实现高斯模糊"><a href="#Glide-v4实现高斯模糊" class="headerlink" title="Glide v4实现高斯模糊"></a>Glide v4实现高斯模糊</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> android.content.Context;</span><br><span class="line"><span class="keyword">import</span> android.graphics.Bitmap;</span><br><span class="line"><span class="keyword">import</span> android.graphics.Canvas;</span><br><span class="line"><span class="keyword">import</span> android.graphics.Color;</span><br><span class="line"><span class="keyword">import</span> android.graphics.Paint;</span><br><span class="line"><span class="keyword">import</span> android.graphics.PorterDuff;</span><br><span class="line"><span class="keyword">import</span> android.graphics.PorterDuffColorFilter;</span><br><span class="line"><span class="keyword">import</span> android.support.annotation.FloatRange;</span><br><span class="line"><span class="keyword">import</span> android.support.annotation.NonNull;</span><br><span class="line"><span class="keyword">import</span> android.support.v8.renderscript.Allocation;</span><br><span class="line"><span class="keyword">import</span> android.support.v8.renderscript.Element;</span><br><span class="line"><span class="keyword">import</span> android.support.v8.renderscript.RenderScript;</span><br><span class="line"><span class="keyword">import</span> android.support.v8.renderscript.ScriptIntrinsicBlur;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;</span><br><span class="line"><span class="keyword">import</span> com.bumptech.glide.load.resource.bitmap.BitmapTransformation;</span><br><span class="line"><span class="keyword">import</span> com.bumptech.glide.request.target.Target;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.security.MessageDigest;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span>:2018/6/9 at 12:07</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: glide实现高斯模糊</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlurTransformation</span> <span class="keyword">extends</span> <span class="title">BitmapTransformation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_RADIUS = <span class="number">25.0f</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> MAX_RADIUS = <span class="number">25.0f</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_SAMPLING = <span class="number">1.0f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Context mContext;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> mSampling = DEFAULT_SAMPLING;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> mRadius;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mColor;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateDiskCacheKey</span><span class="params">(@NonNull MessageDigest messageDigest)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> Context mContext;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">float</span> mRadius = DEFAULT_RADIUS;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> mColor = Color.TRANSPARENT;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">(Context mContext)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.mContext = mContext;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getRadius</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> mRadius;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">setRadius</span><span class="params">(<span class="keyword">float</span> radius)</span> </span>&#123;</span><br><span class="line">            mRadius = radius;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getColor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> mColor;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">setColor</span><span class="params">(<span class="keyword">int</span> color)</span> </span>&#123;</span><br><span class="line">            mColor = color;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> BlurTransformation <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> BlurTransformation(mContext, mRadius, mColor);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context Context</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> radius The blur's radius.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> color The color filter for blurring.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BlurTransformation</span><span class="params">(Context context, @FloatRange(from = <span class="number">0.0</span>f)</span> <span class="keyword">float</span> radius, <span class="keyword">int</span> color) </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context);</span><br><span class="line">        mContext = context;</span><br><span class="line">        <span class="keyword">if</span> (radius &gt; MAX_RADIUS) &#123;</span><br><span class="line">            mSampling = radius / <span class="number">25.0f</span>;</span><br><span class="line">            mRadius = MAX_RADIUS;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mRadius = radius;</span><br><span class="line">        &#125;</span><br><span class="line">        mColor = color;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context Context</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> radius The blur's radius.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BlurTransformation</span><span class="params">(Context context, @FloatRange(from = <span class="number">0.0</span>f)</span> <span class="keyword">float</span> radius) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(context, radius, Color.TRANSPARENT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BlurTransformation</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(context, DEFAULT_RADIUS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Transforms the given &#123;<span class="doctag">@link</span> Bitmap&#125; based on the given dimensions and returns the transformed</span></span><br><span class="line"><span class="comment">     * result.</span></span><br><span class="line"><span class="comment">     * &lt;p/&gt;</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * The provided Bitmap, toTransform, should not be recycled or returned to the pool. Glide will automatically</span></span><br><span class="line"><span class="comment">     * recycle and/or reuse toTransform if the transformation returns a different Bitmap. Similarly implementations</span></span><br><span class="line"><span class="comment">     * should never recycle or return Bitmaps that are returned as the result of this method. Recycling or returning</span></span><br><span class="line"><span class="comment">     * the provided and/or the returned Bitmap to the pool will lead to a variety of runtime exceptions and drawing</span></span><br><span class="line"><span class="comment">     * errors. See #408 for an example. If the implementation obtains and discards intermediate Bitmaps, they may</span></span><br><span class="line"><span class="comment">     * safely be returned to the BitmapPool and/or recycled.</span></span><br><span class="line"><span class="comment">     * &lt;/p&gt;</span></span><br><span class="line"><span class="comment">     * &lt;p/&gt;</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * outWidth and outHeight will never be &#123;<span class="doctag">@link</span> Target#SIZE_ORIGINAL&#125;, this</span></span><br><span class="line"><span class="comment">     * class converts them to be the size of the Bitmap we're going to transform before calling this method.</span></span><br><span class="line"><span class="comment">     * &lt;/p&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pool        A &#123;<span class="doctag">@link</span> BitmapPool&#125; that can be used to obtain and</span></span><br><span class="line"><span class="comment">     *                    return intermediate &#123;<span class="doctag">@link</span> Bitmap&#125;s used in this transformation. For every</span></span><br><span class="line"><span class="comment">     *                    &#123;<span class="doctag">@link</span> Bitmap&#125; obtained from the pool during this transformation, a</span></span><br><span class="line"><span class="comment">     *                    &#123;<span class="doctag">@link</span> Bitmap&#125; must also be returned.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> toTransform The &#123;<span class="doctag">@link</span> Bitmap&#125; to transform.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> outWidth    The ideal width of the transformed bitmap (the transformed width does not need to match exactly).</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> outHeight   The ideal height of the transformed bitmap (the transformed heightdoes not need to match</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Bitmap <span class="title">transform</span><span class="params">(BitmapPool pool, Bitmap toTransform, <span class="keyword">int</span> outWidth, <span class="keyword">int</span> outHeight)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> needScaled = mSampling == DEFAULT_SAMPLING;</span><br><span class="line">        <span class="keyword">int</span> originWidth = toTransform.getWidth();</span><br><span class="line">        <span class="keyword">int</span> originHeight = toTransform.getHeight();</span><br><span class="line">        <span class="keyword">int</span> width, height;</span><br><span class="line">        <span class="keyword">if</span> (needScaled) &#123;</span><br><span class="line">            width = originWidth;</span><br><span class="line">            height = originHeight;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            width = (<span class="keyword">int</span>) (originWidth / mSampling);</span><br><span class="line">            height = (<span class="keyword">int</span>) (originHeight / mSampling);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//find a re-use bitmap</span></span><br><span class="line">        Bitmap bitmap = pool.get(width, height, Bitmap.Config.ARGB_8888);</span><br><span class="line">        <span class="keyword">if</span> (bitmap == <span class="keyword">null</span>) &#123;</span><br><span class="line">            bitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Canvas canvas = <span class="keyword">new</span> Canvas(bitmap);</span><br><span class="line">        <span class="keyword">if</span> (mSampling != DEFAULT_SAMPLING) &#123;</span><br><span class="line">            canvas.scale(<span class="number">1</span> / mSampling, <span class="number">1</span> / mSampling);</span><br><span class="line">        &#125;</span><br><span class="line">        Paint paint = <span class="keyword">new</span> Paint();</span><br><span class="line">        paint.setFlags(Paint.FILTER_BITMAP_FLAG | Paint.ANTI_ALIAS_FLAG);</span><br><span class="line">        PorterDuffColorFilter filter =</span><br><span class="line">                <span class="keyword">new</span> PorterDuffColorFilter(mColor, PorterDuff.Mode.SRC_ATOP);</span><br><span class="line">        paint.setColorFilter(filter);</span><br><span class="line">        canvas.drawBitmap(toTransform, <span class="number">0</span>, <span class="number">0</span>, paint);</span><br><span class="line"><span class="comment">// TIPS: Glide will take care of returning our original Bitmap to the BitmapPool for us,</span></span><br><span class="line"><span class="comment">// we needn't to recycle it.</span></span><br><span class="line"><span class="comment">//        toTransform.recycle();  &lt;--- Just for tips. by Ligboy</span></span><br><span class="line"></span><br><span class="line">        RenderScript rs = RenderScript.create(mContext);</span><br><span class="line">        Allocation input = Allocation.createFromBitmap(rs, bitmap, Allocation.MipmapControl.MIPMAP_NONE,</span><br><span class="line">                Allocation.USAGE_SCRIPT);</span><br><span class="line">        Allocation output = Allocation.createTyped(rs, input.getType());</span><br><span class="line">        ScriptIntrinsicBlur blur = ScriptIntrinsicBlur.create(rs, Element.U8_4(rs));</span><br><span class="line"></span><br><span class="line">        blur.setInput(input);</span><br><span class="line">        blur.setRadius(mRadius);</span><br><span class="line">        blur.forEach(output);</span><br><span class="line">        output.copyTo(bitmap);</span><br><span class="line"></span><br><span class="line">        rs.destroy();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (needScaled) &#123;</span><br><span class="line">            <span class="keyword">return</span> bitmap;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Bitmap scaled = Bitmap.createScaledBitmap(bitmap, originWidth, originHeight, <span class="keyword">true</span>);</span><br><span class="line">            bitmap.recycle();</span><br><span class="line">            <span class="keyword">return</span> scaled;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Glide.with(getActivity())</span><br><span class="line">        .load(resource)</span><br><span class="line">        .apply(<span class="keyword">new</span> RequestOptions().transform(<span class="keyword">new</span></span><br><span class="line">                BlurTransformation(getContext(),</span><br><span class="line">                <span class="number">100</span>)))</span><br><span class="line">        .into();</span><br></pre></td></tr></table></figure><h4 id="如果宽度大于长度则旋转"><a href="#如果宽度大于长度则旋转" class="headerlink" title="如果宽度大于长度则旋转"></a>如果宽度大于长度则旋转</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Glide.with(getActivity())</span><br><span class="line">      .asBitmap()</span><br><span class="line">      .load(s)</span><br><span class="line">      .into(<span class="keyword">new</span> SimpleTarget&lt;Bitmap&gt;(Target.SIZE_ORIGINAL, Target.SIZE_ORIGINAL) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResourceReady</span><span class="params">(@NonNull Bitmap resource, @Nullable Transition&lt;? <span class="keyword">super</span> Bitmap&gt; transition)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> (resource.getWidth() &gt; resource.getHeight()) &#123;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ImageViewer&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Glide v4实现图片旋转&lt;/li&gt;
&lt;li&gt;Glide v4实现高斯模糊&lt;/li&gt;
&lt;li&gt;如果宽度大于长度则旋转&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://www.sanmaoliu.com/tags/Android/"/>
    
      <category term="App" scheme="http://www.sanmaoliu.com/tags/App/"/>
    
  </entry>
  
  <entry>
    <title>ImageViewer应用</title>
    <link href="http://www.sanmaoliu.com/2018/06/11/ImageViewer/"/>
    <id>http://www.sanmaoliu.com/2018/06/11/ImageViewer/</id>
    <published>2018-06-11T06:31:11.000Z</published>
    <updated>2018-06-11T06:32:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>做了一个类似抖音的recycleview效果</p><p><img src="https://coding.net/u/sanmaoliu/p/pictures/git/raw/master/ImageViewer.gif" alt></p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;做了一个类似抖音的recycleview效果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://coding.net/u/sanmaoliu/p/pictures/git/raw/master/ImageViewer.gif&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://www.sanmaoliu.com/tags/Android/"/>
    
      <category term="App" scheme="http://www.sanmaoliu.com/tags/App/"/>
    
  </entry>
  
  <entry>
    <title>css更改body：before的内容</title>
    <link href="http://www.sanmaoliu.com/2018/06/07/css%E6%9B%B4%E6%94%B9body%EF%BC%9Abefore%E7%9A%84%E5%86%85%E5%AE%B9/"/>
    <id>http://www.sanmaoliu.com/2018/06/07/css更改body：before的内容/</id>
    <published>2018-06-07T09:47:59.000Z</published>
    <updated>2018-06-07T09:58:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>刚开始是设置body的样式来显示背景图片，设置background-attachment: fixed;让它固定不动，但是在iPad和某些移动终端没有效果，还是会随滚动条进行滚动。</p><p>然后就找到办法使用body:before来进行设置。</p><p>为了实现刷新时切换壁纸，:before又不能捕获，后来我终于找到了办法来实现</p><a id="more"></a><h4 id="1-CSS样式"><a href="#1-CSS样式" class="headerlink" title="1. CSS样式"></a>1. CSS样式</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//通过更改类来实现背景图片的切换，因为：before不好捕捉</span><br><span class="line"><span class="selector-class">.change1</span><span class="selector-pseudo">:before</span>&#123;</span><br><span class="line"><span class="attribute">content</span>: <span class="string">' '</span>;</span><br><span class="line"><span class="attribute">position</span>: fixed;</span><br><span class="line"><span class="attribute">z-index</span>: -<span class="number">1</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line"><span class="attribute">background</span>: <span class="built_in">url</span>(https://coding.net/u/sanmaoliu/p/pictures/git/raw/master/back1.jpg) center <span class="number">0</span> no-repeat;</span><br><span class="line"><span class="attribute">background-size</span>: cover;</span><br><span class="line"><span class="attribute">background-position</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.change2</span><span class="selector-pseudo">:before</span>&#123;</span><br><span class="line"><span class="attribute">content</span>: <span class="string">' '</span>;</span><br><span class="line"><span class="attribute">position</span>: fixed;</span><br><span class="line"><span class="attribute">z-index</span>: -<span class="number">1</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line"><span class="attribute">background</span>: <span class="built_in">url</span>(https://coding.net/u/sanmaoliu/p/pictures/git/raw/master/back2.jpg) center <span class="number">0</span> no-repeat;</span><br><span class="line"><span class="attribute">background-size</span>: cover;</span><br><span class="line"><span class="attribute">background-position</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">....搞了二十个壁纸</span><br></pre></td></tr></table></figure><h4 id="2-切换壁纸代码实现"><a href="#2-切换壁纸代码实现" class="headerlink" title="2. 切换壁纸代码实现"></a>2. 切换壁纸代码实现</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">jQuery(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params">$</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> random=<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*<span class="number">20</span>+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">var</span> cls=<span class="string">'change'</span>+random;</span><br><span class="line">$(<span class="string">"body"</span>).attr(<span class="string">"class"</span>, cls);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这样就能实现了，完美兼容了我的iPad。嘻嘻</p><p><a href="http://www.aishitelu.com/" target="_blank" rel="noopener">来我的博客主页看效果 ^。^</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;刚开始是设置body的样式来显示背景图片，设置background-attachment: fixed;让它固定不动，但是在iPad和某些移动终端没有效果，还是会随滚动条进行滚动。&lt;/p&gt;
&lt;p&gt;然后就找到办法使用body:before来进行设置。&lt;/p&gt;
&lt;p&gt;为了实现刷新时切换壁纸，:before又不能捕获，后来我终于找到了办法来实现&lt;/p&gt;
    
    </summary>
    
    
      <category term="CSS" scheme="http://www.sanmaoliu.com/tags/CSS/"/>
    
      <category term="jQuery" scheme="http://www.sanmaoliu.com/tags/jQuery/"/>
    
  </entry>
  
  <entry>
    <title>我所使用的MVP框架4</title>
    <link href="http://www.sanmaoliu.com/2018/06/06/%E6%88%91%E6%89%80%E4%BD%BF%E7%94%A8%E7%9A%84MVP%E6%A1%86%E6%9E%B64/"/>
    <id>http://www.sanmaoliu.com/2018/06/06/我所使用的MVP框架4/</id>
    <published>2018-06-06T07:30:09.000Z</published>
    <updated>2018-06-06T12:36:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>这个配置的方法是在CoreBaseMVP借鉴而来。Rxjava给它升级到了2.X的版本。本章包含以下内容。</p><ol><li>MVP实现原理梳理</li></ol><a id="more"></a><h4 id="1-MVP实现原理梳理"><a href="#1-MVP实现原理梳理" class="headerlink" title="1. MVP实现原理梳理"></a>1. MVP实现原理梳理</h4><ul><li><p>BasePresenter中，因为使用了泛型类构造，我们容易得到Model和View的实现类。进而实现attachVM和detachVM，mRxManager用来做整体的观察者模式的控制。</p></li><li><p>在Fragement的onViewCreated中，我们调用attachVM，在Fragement的onDestroy中，调用detachVM。</p></li><li><p>在BaseFragmen中也使用泛型类，这次因为泛型类参数因为是继承的关系，所以我们通过反射的方式找到他们，通过调用Presenter的方法实现数据获取和处理。</p></li><li><p>切记不可在initUI时候直接调用Presenter的方法，这时会造成Presenter层Model对象找不到的错误。调用需要放在监听方法或者initData中。</p><h3 id="Fragmentation配合MVP实现单Activity多Fragment是真香。"><a href="#Fragmentation配合MVP实现单Activity多Fragment是真香。" class="headerlink" title="Fragmentation配合MVP实现单Activity多Fragment是真香。"></a>Fragmentation配合MVP实现单Activity多Fragment是真香。</h3></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这个配置的方法是在CoreBaseMVP借鉴而来。Rxjava给它升级到了2.X的版本。本章包含以下内容。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;MVP实现原理梳理&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="MVP" scheme="http://www.sanmaoliu.com/tags/MVP/"/>
    
      <category term="Frame" scheme="http://www.sanmaoliu.com/tags/Frame/"/>
    
  </entry>
  
  <entry>
    <title>文件重命名，如果名称存在则先删除再重命名</title>
    <link href="http://www.sanmaoliu.com/2018/06/06/%E6%96%87%E4%BB%B6%E9%87%8D%E5%91%BD%E5%90%8D%EF%BC%8C%E5%A6%82%E6%9E%9C%E5%90%8D%E7%A7%B0%E5%AD%98%E5%9C%A8%E5%88%99%E5%85%88%E5%88%A0%E9%99%A4%E5%86%8D%E9%87%8D%E5%91%BD%E5%90%8D/"/>
    <id>http://www.sanmaoliu.com/2018/06/06/文件重命名，如果名称存在则先删除再重命名/</id>
    <published>2018-06-06T07:14:09.000Z</published>
    <updated>2018-06-06T07:24:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>在网证的项目，一所人证需要上传捕捉的头像照片。然后将文件命名为authImg.jpg。认证成功后将文件重命名为headImg，如果headImg已经存在，则删除后重命名。<br><a id="more"></a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 删除单个文件</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> fileName 要删除的文件的文件名</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> 单个文件删除成功返回true，否则返回false</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">deleteFile</span><span class="params">(String fileName)</span> </span>&#123;</span><br><span class="line">      File file = <span class="keyword">new</span> File(fileName);</span><br><span class="line">      <span class="comment">// 如果文件路径所对应的文件存在，并且是一个文件，则直接删除</span></span><br><span class="line">      <span class="keyword">if</span> (file.exists() &amp;&amp; file.isFile()) &#123;</span><br><span class="line">          <span class="keyword">if</span> (file.delete()) &#123;</span><br><span class="line">              System.out.println(<span class="string">"删除单个文件"</span> + fileName + <span class="string">"成功！"</span>);</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              System.out.println(<span class="string">"删除单个文件"</span> + fileName + <span class="string">"失败！"</span>);</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          System.out.println(<span class="string">"删除单个文件失败："</span> + fileName + <span class="string">"不存在！"</span>);</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 文件重命名</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> oldFile 原来的文件</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> newFile 新文件</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">renameFile</span><span class="params">(String oldFile, String newFile)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (!oldFile.equals(newFile)) &#123;<span class="comment">//新的文件名和以前文件名不同时,才有必要进行重命名</span></span><br><span class="line">          File oldfile = <span class="keyword">new</span> File(oldFile);</span><br><span class="line">          File newfile = <span class="keyword">new</span> File(newFile);</span><br><span class="line">          <span class="keyword">if</span> (!oldfile.exists()) &#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">//重命名文件不存在</span></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (newfile.exists())<span class="comment">//若在该目录下已经有一个文件和新文件名相同，则不允许重命名</span></span><br><span class="line">              deleteFile(newFile);</span><br><span class="line">          <span class="keyword">return</span> oldfile.renameTo(newfile);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          System.out.println(<span class="string">"新文件名和旧文件名相同..."</span>);</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在网证的项目，一所人证需要上传捕捉的头像照片。然后将文件命名为authImg.jpg。认证成功后将文件重命名为headImg，如果headImg已经存在，则删除后重命名。&lt;br&gt;
    
    </summary>
    
    
      <category term="file" scheme="http://www.sanmaoliu.com/tags/file/"/>
    
  </entry>
  
  <entry>
    <title>Activity，Fragment生命周期</title>
    <link href="http://www.sanmaoliu.com/2018/06/06/Activity%EF%BC%8CFragment%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>http://www.sanmaoliu.com/2018/06/06/Activity，Fragment生命周期/</id>
    <published>2018-06-06T06:51:56.000Z</published>
    <updated>2018-06-06T07:10:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>本章内容包括</p><ol><li><p>Activity生命周期</p></li><li><p>Activity缓存方法</p></li><li><p>Fragment生命周期和activity的关系</p></li><li><p>Fragment生命周期</p><a id="more"></a><h4 id="1-Activity生命周期"><a href="#1-Activity生命周期" class="headerlink" title="1. Activity生命周期"></a>1. Activity生命周期</h4></li></ol><ul><li><p>启动Activity:<br>onCreate()—&gt;onStart()—&gt;onResume()，Activity进入运行状态。</p></li><li><p>Activity退居后台:<br>当前Activity转到新的Activity界面或按Home键回到主屏：<br>onPause()—&gt;onStop()，进入停滞状态。</p></li><li><p>Activity返回前台:<br>onRestart()—&gt;onStart()—&gt;onResume()，再次回到运行状态。</p></li><li><p>Activity退居后台，且系统内存不足，<br>系统会杀死这个后台状态的Activity（此时这个Activity引用仍然处在任务栈中，只是这个时候引用指向的对象已经为null），若再次回到这个Activity,则会走onCreate()–&gt;onStart()—&gt;onResume()(将重新走一次Activity的初始化生命周期)</p></li><li><p>锁屏：onPause()-&gt;onStop()</p></li><li><p>解锁：onStart()-&gt;onResume()</p></li><li><p>更多流程分支，请参照以下生命周期流程图</p><p><img src="https://coding.net/u/sanmaoliu/p/pictures/git/raw/master/Activity生命周期.png" alt></p></li></ul><h4 id="2-Activity缓存方法"><a href="#2-Activity缓存方法" class="headerlink" title="2. Activity缓存方法"></a>2. Activity缓存方法</h4><p>有a、b两个Activity，当从a进入b之后一段时间，可能系统会把a回收，这时候按back，执行的不是a的onRestart而是onCreate方法，a被重新创建一次，这是a中的临时数据和状态可能就丢失了。</p><p>可以用Activity中的onSaveInstanceState()回调方法保存临时数据和状态，这个方法一定会在活动被回收之前调用。方法中有一个Bundle参数，putString()、putInt()等方法需要传入两个参数，一个键一个值。数据保存之后会在onCreate中恢复，onCreate也有一个Bundle类型的参数。</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里，当Acivity第一次被创建的时候为空</span></span><br><span class="line">    <span class="comment">//所以我们需要判断一下</span></span><br><span class="line">    <span class="keyword">if</span>( savedInstanceState != <span class="keyword">null</span> )&#123;</span><br><span class="line">        savedInstanceState.getString(<span class="string">"anAnt"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onSaveInstanceState</span><span class="params">(Bundle outState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onSaveInstanceState(outState);</span><br><span class="line"></span><br><span class="line">    outState.putString(<span class="string">"anAnt"</span>,<span class="string">"Android"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一、onSaveInstanceState (Bundle outState)</p><p>当某个activity变得“容易”被系统销毁时，该activity的onSaveInstanceState就会被执行，除非该activity是被用户主动销毁的，例如当用户按BACK键的时候。</p><p>注意上面的双引号，何为“容易”？言下之意就是该activity还没有被销毁，而仅仅是一种可能性。这种可能性有哪些？通过重写一个activity的所有生命周期的onXXX方法，包括onSaveInstanceState和onRestoreInstanceState方法，我们可以清楚地知道当某个activity（假定为activity A）显示在当前task的最上层时，其onSaveInstanceState方法会在什么时候被执行，有这么几种情况：</p><p>1、当用户按下HOME键时。</p><p>这是显而易见的，系统不知道你按下HOME后要运行多少其他的程序，自然也不知道activity A是否会被销毁，故系统会调用onSaveInstanceState，让用户有机会保存某些非永久性的数据。以下几种情况的分析都遵循该原则</p><p>2、长按HOME键，选择运行其他的程序时。</p><p>3、按下电源按键（关闭屏幕显示）时。</p><p>4、从activity A中启动一个新的activity时。</p><p>5、屏幕方向切换时，例如从竖屏切换到横屏时。（如果不指定configchange属性）<br>在屏幕切换之前，系统会销毁activity A，在屏幕切换之后系统又会自动地创建activity A，所以onSaveInstanceState一定会被执行</p><p>总而言之，onSaveInstanceState的调用遵循一个重要原则，即当系统“未经你许可”时销毁了你的activity，则onSaveInstanceState会被系统调用，这是系统的责任，因为它必须要提供一个机会让你保存你的数据（当然你不保存那就随便你了）。另外，需要注意的几点：</p><p>1.布局中的每一个View默认实现了onSaveInstanceState()方法，这样的话，这个UI的任何改变都会自动地存储和在activity重新创建的时候自动地恢复。但是这种情况只有在你为这个UI提供了唯一的ID之后才起作用，如果没有提供ID，app将不会存储它的状态。</p><p>2.由于默认的onSaveInstanceState()方法的实现帮助UI存储它的状态，所以如果你需要覆盖这个方法去存储额外的状态信息，你应该在执行任何代码之前都调用父类的onSaveInstanceState()方法（super.onSaveInstanceState()）。<br>既然有现成的可用，那么我们到底还要不要自己实现onSaveInstanceState()?这得看情况了，如果你自己的派生类中有变量影响到UI，或你程序的行为，当然就要把这个变量也保存了，那么就需要自己实现，否则就不需要。</p><p>3.由于onSaveInstanceState()方法调用的不确定性，你应该只使用这个方法去记录activity的瞬间状态（UI的状态）。不应该用这个方法去存储持久化数据。当用户离开这个activity的时候应该在onPause()方法中存储持久化数据（例如应该被存储到数据库中的数据）。</p><p>4.onSaveInstanceState()如果被调用，这个方法会在onStop()前被触发，但系统并不保证是否在onPause()之前或者之后触发。</p><p>二、onRestoreInstanceState (Bundle outState)</p><p>至于onRestoreInstanceState方法，需要注意的是，onSaveInstanceState方法和onRestoreInstanceState方法“不一定”是成对的被调用的，（本人注：我昨晚调试时就发现原来不一定成对被调用的！）</p><p>onRestoreInstanceState被调用的前提是，activity A“确实”被系统销毁了，而如果仅仅是停留在有这种可能性的情况下，则该方法不会被调用，例如，当正在显示activity A的时候，用户按下HOME键回到主界面，然后用户紧接着又返回到activity A，这种情况下activity A一般不会因为内存的原因被系统销毁，故activity A的onRestoreInstanceState方法不会被执行</p><p>另外，onRestoreInstanceState的bundle参数也会传递到onCreate方法中，你也可以选择在onCreate方法中做数据还原。<br>还有onRestoreInstanceState在onstart之后执行。<br>至于这两个函数的使用，给出示范代码（留意自定义代码在调用super的前或后）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSaveInstanceState</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        savedInstanceState.putBoolean(<span class="string">"MyBoolean"</span>, <span class="keyword">true</span>);</span><br><span class="line">        savedInstanceState.putDouble(<span class="string">"myDouble"</span>, <span class="number">1.9</span>);</span><br><span class="line">        savedInstanceState.putInt(<span class="string">"MyInt"</span>, <span class="number">1</span>);</span><br><span class="line">        savedInstanceState.putString(<span class="string">"MyString"</span>, <span class="string">"Welcome back to Android"</span>);</span><br><span class="line">        <span class="comment">// etc.</span></span><br><span class="line">        <span class="keyword">super</span>.onSaveInstanceState(savedInstanceState);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onRestoreInstanceState</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onRestoreInstanceState(savedInstanceState);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> myBoolean = savedInstanceState.getBoolean(<span class="string">"MyBoolean"</span>);</span><br><span class="line">        <span class="keyword">double</span> myDouble = savedInstanceState.getDouble(<span class="string">"myDouble"</span>);</span><br><span class="line">        <span class="keyword">int</span> myInt = savedInstanceState.getInt(<span class="string">"MyInt"</span>);</span><br><span class="line">        String myString = savedInstanceState.getString(<span class="string">"MyString"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-Fragment的生命周期和activity如何的一个关系"><a href="#3-Fragment的生命周期和activity如何的一个关系" class="headerlink" title="3. Fragment的生命周期和activity如何的一个关系"></a>3. Fragment的生命周期和activity如何的一个关系</h4><p><img src="https://coding.net/u/sanmaoliu/p/pictures/git/raw/master/Fragement和Activity简洁版.jpg" alt></p><p><strong>为什么在Service中创建子线程而不是Activity中</strong></p><p>这是因为Activity很难对Thread进行控制，当Activity被销毁之后，就没有任何其它的办法可以再重新获取到之前创建的子线程的实例。而且在一个Activity中创建的子线程，另一个Activity无法对其进行操作。但是Service就不同了，所有的Activity都可以与Service进行关联，然后可以很方便地操作其中的方法，即使Activity被销毁了，之后只要重新与Service建立关联，就又能够获取到原有的Service中Binder的实例。因此，使用Service来处理后台任务，Activity就可以放心地finish，完全不需要担心无法对后台任务进行控制的情况。</p><p><strong>Intent的使用方法，可以传递哪些数据类型。</strong></p><p>通过查询Intent/Bundle的API文档，我们可以获知，Intent/Bundle支持传递基本类型的数据和基本类型的数组数据，以及String/CharSequence类型的数据和String/CharSequence类型的数组数据。而对于其它类型的数据貌似无能为力，其实不然，我们可以在Intent/Bundle的API中看到Intent/Bundle还可以传递Parcelable（包裹化，邮包）和Serializable（序列化）类型的数据，以及它们的数组/列表数据。</p><p>所以要让非基本类型和非String/CharSequence类型的数据通过Intent/Bundle来进行传输，我们就需要在数据类型中实现Parcelable接口或是Serializable接口。</p><h4 id="4-Fragment生命周期"><a href="#4-Fragment生命周期" class="headerlink" title="4. Fragment生命周期"></a>4. Fragment生命周期</h4><p><img src="https://coding.net/u/sanmaoliu/p/pictures/git/raw/master/完整的生命周期.png" alt><br>注意和Activity的相比的区别,按照执行顺序</p><ul><li>onAttach(),onDetach()</li><li>onCreateView(),onDestroyView()</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本章内容包括&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Activity生命周期&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Activity缓存方法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Fragment生命周期和activity的关系&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Fragment生命周期&lt;/p&gt;
    
    </summary>
    
    
      <category term="Fragment" scheme="http://www.sanmaoliu.com/tags/Fragment/"/>
    
      <category term="Activity" scheme="http://www.sanmaoliu.com/tags/Activity/"/>
    
      <category term="Lifecycle" scheme="http://www.sanmaoliu.com/tags/Lifecycle/"/>
    
  </entry>
  
  <entry>
    <title>gradle下载过慢</title>
    <link href="http://www.sanmaoliu.com/2018/06/01/gradle%E4%B8%8B%E8%BD%BD%E8%BF%87%E6%85%A2/"/>
    <id>http://www.sanmaoliu.com/2018/06/01/gradle下载过慢/</id>
    <published>2018-06-01T07:25:58.000Z</published>
    <updated>2018-06-06T07:27:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>这个安装包一直再google()下载不下来</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//banner https://github.com/youth5201314/banner</span></span><br><span class="line">implementation <span class="string">'com.youth.banner:banner:1.4.10'</span></span><br></pre></td></tr></table></figure><p>然后改成这个</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">allprojects &#123;</span><br><span class="line">  repositories &#123;</span><br><span class="line">      <span class="comment">//google()</span></span><br><span class="line">      jcenter()</span><br><span class="line">      maven &#123;</span><br><span class="line">          url <span class="string">'http://maven.aliyun.com/nexus/content/groups/public'</span></span><br><span class="line">      &#125;</span><br><span class="line">      maven &#123; url <span class="string">"https://jitpack.io"</span> &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以后一律用这个了，下载超级快。抱住阿里爸爸~  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这个安装包一直再google()下载不下来&lt;/p&gt;
&lt;figure class=&quot;highlight groovy&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>保存Bitmap到文件，图片转换成Base64编码的字符串。</title>
    <link href="http://www.sanmaoliu.com/2018/06/01/%E4%BF%9D%E5%AD%98Bitmap%E5%88%B0%E6%96%87%E4%BB%B6%EF%BC%8C%E5%9B%BE%E7%89%87%E8%BD%AC%E6%8D%A2%E6%88%90Base64%E7%BC%96%E7%A0%81%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%82/"/>
    <id>http://www.sanmaoliu.com/2018/06/01/保存Bitmap到文件，图片转换成Base64编码的字符串。/</id>
    <published>2018-06-01T07:05:12.000Z</published>
    <updated>2018-06-06T06:53:42.000Z</updated>
    
    <content type="html"><![CDATA[<ol><li>保存Bitmap到文件</li><li>图片转换成Base64编码的字符串</li></ol><a id="more"></a><h5 id="保存Bitmap到文件"><a href="#保存Bitmap到文件" class="headerlink" title="保存Bitmap到文件"></a>保存Bitmap到文件</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">saveBitmap</span><span class="params">(Bitmap btImage, String fileName)</span> </span>&#123;</span><br><span class="line">        FileOutputStream out;</span><br><span class="line">        <span class="keyword">if</span> (Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED)) &#123;<span class="comment">// 判断是否可以对SDcard进行操作</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 获取SDCard指定目录下</span></span><br><span class="line">                showLog(<span class="string">"xxx "</span> + getContext().getFilesDir() + <span class="string">"/auth/image/"</span>);</span><br><span class="line">                String sdCardDir = getContext().getFilesDir() + <span class="string">"/auth/image/"</span>;</span><br><span class="line">                File dirFile = <span class="keyword">new</span> File(sdCardDir);  <span class="comment">//目录转化成文件夹</span></span><br><span class="line">                <span class="keyword">if</span> (!dirFile.exists()) &#123;              <span class="comment">//如果不存在，那就建立这个文件夹</span></span><br><span class="line">                    dirFile.mkdirs();</span><br><span class="line">                &#125;                          <span class="comment">//文件夹有啦，就可以保存图片啦</span></span><br><span class="line">                File file = <span class="keyword">new</span> File(sdCardDir, fileName);<span class="comment">// 在SDcard的目录下创建图片文,以当前时间为其命名</span></span><br><span class="line">                out = <span class="keyword">new</span> FileOutputStream(file);</span><br><span class="line">                btImage.compress(Bitmap.CompressFormat.JPEG, <span class="number">90</span>, out);</span><br><span class="line">                out.flush();</span><br><span class="line">                out.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//showToast("保存已经至" + Environment.getExternalStorageDirectory() + "/auth/image/");</span></span><br><span class="line">            <span class="keyword">return</span> getContext().getFilesDir() + <span class="string">"/auth/image/"</span> + fileName;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="图片转换成Base64编码的字符串"><a href="#图片转换成Base64编码的字符串" class="headerlink" title="图片转换成Base64编码的字符串"></a>图片转换成Base64编码的字符串</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 将图片转换成Base64编码的字符串</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> path</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> base64编码的字符串</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">imageToBase64</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (TextUtils.isEmpty(path)) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       InputStream is = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">byte</span>[] data;</span><br><span class="line">       String result = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           is = <span class="keyword">new</span> FileInputStream(path);</span><br><span class="line">           <span class="comment">//创建一个字符流大小的数组。</span></span><br><span class="line">           data = <span class="keyword">new</span> <span class="keyword">byte</span>[is.available()];</span><br><span class="line">           <span class="comment">//写入数组</span></span><br><span class="line">           is.read(data);</span><br><span class="line">           <span class="comment">//用默认的编码格式进行编码</span></span><br><span class="line">           result = Base64.encodeToString(data, Base64.DEFAULT);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (<span class="keyword">null</span> != is) &#123;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   is.close();</span><br><span class="line">               &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;保存Bitmap到文件&lt;/li&gt;
&lt;li&gt;图片转换成Base64编码的字符串&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://www.sanmaoliu.com/tags/Android/"/>
    
      <category term="bitmap" scheme="http://www.sanmaoliu.com/tags/bitmap/"/>
    
      <category term="base64" scheme="http://www.sanmaoliu.com/tags/base64/"/>
    
  </entry>
  
  <entry>
    <title>android振动器(Vibrator)</title>
    <link href="http://www.sanmaoliu.com/2018/05/31/android%E6%8C%AF%E5%8A%A8%E5%99%A8-Vibrator/"/>
    <id>http://www.sanmaoliu.com/2018/05/31/android振动器-Vibrator/</id>
    <published>2018-05-31T12:00:39.000Z</published>
    <updated>2018-06-11T06:33:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>Vibrator三个常用的方法</p><ul><li><p>void android.os.Vibrator.vibrate(long milliseconds)震动milliseconds秒钟</p></li><li><p>void android.os.Vibrator.cancel()关闭手机震动</p></li><li><p>void android.os.Vibrator.vibrate(long[] pattern, int repeat)指定手机以pattern指定的震动模式；比如vibrate(new int[]{400,800,1200,1600},2)表示在数组索引为2这个时间点开始循环来震动；这些循环的震动的时间点就是数组的数值，震动在这些时间点交替启动、关闭振动器。</p></li></ul><a id="more"></a><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 授予程序访问振动器的权限 --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span>   </span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">"android.permission.VIBRATE"</span>/&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.android.xiong.vibratortest;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;  </span><br><span class="line"><span class="keyword">import</span> android.os.Vibrator;  </span><br><span class="line"><span class="keyword">import</span> android.app.Activity;  </span><br><span class="line"><span class="keyword">import</span> android.app.Service;  </span><br><span class="line"><span class="keyword">import</span> android.view.Menu;  </span><br><span class="line"><span class="keyword">import</span> android.view.MotionEvent;  </span><br><span class="line"><span class="keyword">import</span> android.widget.Toast;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;  </span><br><span class="line">    Vibrator vibrator;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);  </span><br><span class="line">        setContentView(R.layout.activity_main);  </span><br><span class="line">        <span class="comment">// 获取系统的Vibrator服务  </span></span><br><span class="line">        vibrator = (Vibrator) getSystemService(Service.VIBRATOR_SERVICE);  </span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 重写onTouchEvent方法，单用户触碰触摸时触发该方法  </span></span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;  </span><br><span class="line">        Toast.makeText(<span class="keyword">this</span>, <span class="string">"手机震动"</span>, Toast.LENGTH_LONG).show();  </span><br><span class="line">        <span class="comment">// 控制手机震动2秒  </span></span><br><span class="line">        vibrator.vibrate(<span class="number">2000</span>);  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onTouchEvent(event);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onCreateOptionsMenu</span><span class="params">(Menu menu)</span> </span>&#123;  </span><br><span class="line">        <span class="comment">// Inflate the menu; this adds items to the action bar if it is present.  </span></span><br><span class="line">        getMenuInflater().inflate(R.menu.main, menu);  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Vibrator三个常用的方法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;void android.os.Vibrator.vibrate(long milliseconds)震动milliseconds秒钟&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;void android.os.Vibrator.cancel()关闭手机震动&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;void android.os.Vibrator.vibrate(long[] pattern, int repeat)指定手机以pattern指定的震动模式；比如vibrate(new int[]{400,800,1200,1600},2)表示在数组索引为2这个时间点开始循环来震动；这些循环的震动的时间点就是数组的数值，震动在这些时间点交替启动、关闭振动器。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Vibrator" scheme="http://www.sanmaoliu.com/tags/Vibrator/"/>
    
  </entry>
  
  <entry>
    <title>我所使用的MVP框架3</title>
    <link href="http://www.sanmaoliu.com/2018/05/29/%E6%88%91%E6%89%80%E4%BD%BF%E7%94%A8%E7%9A%84MVP%E6%A1%86%E6%9E%B63/"/>
    <id>http://www.sanmaoliu.com/2018/05/29/我所使用的MVP框架3/</id>
    <published>2018-05-29T12:20:34.000Z</published>
    <updated>2018-06-06T07:30:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>这个配置的方法是在CoreBaseMVP借鉴而来。Rxjava给它升级到了2.X的版本。本章包含以下内容。</p><ol><li>Contract接口实现</li></ol><a id="more"></a><h4 id="1-Contract接口实现"><a href="#1-Contract接口实现" class="headerlink" title="1. Contract接口实现"></a>1. Contract接口实现</h4><p>Contract.java(这里举例使用一个空的Contract)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.herocheer.common.mvp.BaseModel;</span><br><span class="line"><span class="keyword">import</span> com.herocheer.common.mvp.BasePresenter;</span><br><span class="line"><span class="keyword">import</span> com.herocheer.common.mvp.BaseView;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span>:2018/5/29 at 20:15</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: Contract</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Contract</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">MainModel</span> <span class="keyword">extends</span> <span class="title">BaseModel</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">MainView</span> <span class="keyword">extends</span> <span class="title">BaseView</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">MainPresenter</span> <span class="keyword">extends</span> <span class="title">BasePresenter</span>&lt;<span class="title">MainModel</span>, <span class="title">MainView</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用泛型类声明BasePresenter，在presenter中我们可以轻易获得view层和model层的对象。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这个配置的方法是在CoreBaseMVP借鉴而来。Rxjava给它升级到了2.X的版本。本章包含以下内容。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Contract接口实现&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="MVP" scheme="http://www.sanmaoliu.com/tags/MVP/"/>
    
      <category term="Frame" scheme="http://www.sanmaoliu.com/tags/Frame/"/>
    
  </entry>
  
  <entry>
    <title>我所使用的MVP框架2</title>
    <link href="http://www.sanmaoliu.com/2018/05/28/%E6%88%91%E6%89%80%E4%BD%BF%E7%94%A8%E7%9A%84MVP%E6%A1%86%E6%9E%B62/"/>
    <id>http://www.sanmaoliu.com/2018/05/28/我所使用的MVP框架2/</id>
    <published>2018-05-28T08:32:38.000Z</published>
    <updated>2018-05-28T09:15:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>这个配置的方法是在CoreBaseMVP借鉴而来。Rxjava给它升级到了2.X的版本。本章包含以下内容。</p><ol><li>BaseActivity和BaseFragment</li><li>LogUtils和ToastUtils</li><li>RxBus</li></ol><a id="more"></a><h4 id="1-BaseActivity和BaseFragment"><a href="#1-BaseActivity和BaseFragment" class="headerlink" title="1. BaseActivity和BaseFragment"></a>1. BaseActivity和BaseFragment</h4><p>BaseActivity.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> android.app.Activity;</span><br><span class="line"><span class="keyword">import</span> android.content.Context;</span><br><span class="line"><span class="keyword">import</span> android.content.Intent;</span><br><span class="line"><span class="keyword">import</span> android.content.pm.ActivityInfo;</span><br><span class="line"><span class="keyword">import</span> android.os.Build;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.widget.Toast;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.herocheer.common.untils.LogUtils;</span><br><span class="line"><span class="keyword">import</span> com.herocheer.common.untils.TUtils;</span><br><span class="line"><span class="keyword">import</span> com.herocheer.common.untils.ToastUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> butterknife.ButterKnife;</span><br><span class="line"><span class="keyword">import</span> butterknife.Unbinder;</span><br><span class="line"><span class="keyword">import</span> me.yokeyword.fragmentation.SupportActivity;</span><br><span class="line"><span class="keyword">import</span> me.yokeyword.fragmentation.anim.DefaultHorizontalAnimator;</span><br><span class="line"><span class="keyword">import</span> me.yokeyword.fragmentation.anim.FragmentAnimator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span>:2018/5/18 at 15:46</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseActivity</span> &lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">BasePresenter</span>, <span class="title">E</span> <span class="keyword">extends</span> <span class="title">BaseModel</span>&gt; <span class="keyword">extends</span> <span class="title">SupportActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> String TAG;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T mPresenter;</span><br><span class="line">    <span class="keyword">public</span> E mModel;</span><br><span class="line">    <span class="keyword">protected</span> Context mContext;</span><br><span class="line">    Unbinder binder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);</span><br><span class="line">        init(savedInstanceState);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        TAG = getClass().getSimpleName();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.setContentView(<span class="keyword">this</span>.getLayoutId());</span><br><span class="line">        binder = ButterKnife.bind(<span class="keyword">this</span>);</span><br><span class="line">        mContext = <span class="keyword">this</span>;</span><br><span class="line">        mPresenter = TUtils.getT(<span class="keyword">this</span>, <span class="number">0</span>);</span><br><span class="line">        mModel = TUtils.getT(<span class="keyword">this</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">instanceof</span> BaseView) mPresenter.attachVM(<span class="keyword">this</span>, mModel);</span><br><span class="line">        <span class="keyword">this</span>.initView(savedInstanceState);</span><br><span class="line">        AppManager.getAppManager().addActivity(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">        AppManager.getAppManager().finishActivity(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (binder != <span class="keyword">null</span>) binder.unbind();</span><br><span class="line">        <span class="keyword">if</span> (mPresenter != <span class="keyword">null</span>) mPresenter.detachVM();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onResume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onResume();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reload</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Intent intent = getIntent();</span><br><span class="line">        overridePendingTransition(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        intent.addFlags(Intent.FLAG_ACTIVITY_NO_ANIMATION);</span><br><span class="line">        finish();</span><br><span class="line">        overridePendingTransition(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        startActivity(intent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">getLayoutId</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">initView</span><span class="params">(Bundle savedInstanceState)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 任意Fragment的onBackPressedSupport()返回true，该方法都不会被回调</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onBackPressedSupport</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onBackPressedSupport();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FragmentAnimator <span class="title">onCreateFragmentAnimator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 设置横向(和安卓4.x动画相同)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DefaultHorizontalAnimator();</span><br><span class="line">        <span class="comment">// 设置无动画</span></span><br><span class="line"><span class="comment">//        return new DefaultNoAnimator();</span></span><br><span class="line">        <span class="comment">// 设置自定义动画</span></span><br><span class="line">        <span class="comment">// return new FragmentAnimator(enter,exit,popEnter,popExit);</span></span><br><span class="line">        <span class="comment">// 默认竖向(和安卓5.0以上的动画相同)</span></span><br><span class="line"><span class="comment">//        return super.onCreateFragmentAnimator();</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 跳转页面,无extra简易型</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tarActivity 目标页面</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startActivity</span><span class="params">(Class&lt;? extends Activity&gt; tarActivity, Bundle options)</span> </span>&#123;</span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, tarActivity);</span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN) &#123;</span><br><span class="line">            startActivity(intent, options);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            startActivity(intent);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startActivity</span><span class="params">(Class&lt;? extends Activity&gt; tarActivity)</span> </span>&#123;</span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, tarActivity);</span><br><span class="line">        startActivity(intent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showToast</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        ToastUtils.showToast(<span class="keyword">this</span>, msg, Toast.LENGTH_SHORT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showLog</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        LogUtils.i(TAG, msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过TUtils反射的方法找到Presenter和Model</li><li>注册Butterknife</li><li>简化Toast和Log</li><li>AppManager的调用，Activity入栈和清空</li></ul><p>TUtils.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.ParameterizedType;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span>:2018/5/18 at 15:09</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 利用反射进行MVP框架的配置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TUtils</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">getT</span><span class="params">(Object o, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> ((Class&lt;T&gt;) ((ParameterizedType) (o.getClass()</span><br><span class="line">                    .getGenericSuperclass())).getActualTypeArguments()[i])</span><br><span class="line">                    .newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException | ClassCastException | IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; forName(String className) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Class.forName(className);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BaseFragment.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> android.app.Activity;</span><br><span class="line"><span class="keyword">import</span> android.content.Context;</span><br><span class="line"><span class="keyword">import</span> android.content.pm.ActivityInfo;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.support.annotation.Nullable;</span><br><span class="line"><span class="keyword">import</span> android.support.v7.widget.Toolbar;</span><br><span class="line"><span class="keyword">import</span> android.view.LayoutInflater;</span><br><span class="line"><span class="keyword">import</span> android.view.View;</span><br><span class="line"><span class="keyword">import</span> android.view.ViewGroup;</span><br><span class="line"><span class="keyword">import</span> android.widget.Toast;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.herocheer.common.untils.LogUtils;</span><br><span class="line"><span class="keyword">import</span> com.herocheer.common.untils.TUtils;</span><br><span class="line"><span class="keyword">import</span> com.herocheer.common.untils.ToastUtils;</span><br><span class="line"><span class="keyword">import</span> com.herocheer.ips.R;</span><br><span class="line"><span class="keyword">import</span> com.herocheer.ips.fragment.HomeFragment;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> butterknife.ButterKnife;</span><br><span class="line"><span class="keyword">import</span> butterknife.Unbinder;</span><br><span class="line"><span class="keyword">import</span> me.yokeyword.fragmentation.SupportFragment;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span>:2018/5/21 at 17:13</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: BaseFragment</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseFragment</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">BasePresenter</span>, <span class="title">E</span> <span class="keyword">extends</span> <span class="title">BaseModel</span>&gt; <span class="keyword">extends</span> <span class="title">SupportFragment</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> String TAG;</span><br><span class="line">    <span class="keyword">protected</span> OnBackToFirstListener _mBackToFirstListener;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T mPresenter;</span><br><span class="line">    <span class="keyword">public</span> E mModel;</span><br><span class="line">    <span class="keyword">protected</span> Context mContext;</span><br><span class="line">    <span class="keyword">protected</span> Activity mActivity;</span><br><span class="line">    Unbinder binder;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initToolbarNav</span><span class="params">(Toolbar toolbar)</span> </span>&#123;</span><br><span class="line">        toolbar.setNavigationIcon(R.drawable.ic_arrow_back_white_24dp);</span><br><span class="line">        toolbar.setNavigationOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAttach</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        mActivity = (Activity) context;</span><br><span class="line">        mContext = context;</span><br><span class="line">        <span class="keyword">super</span>.onAttach(context);</span><br><span class="line">        <span class="keyword">if</span> (context <span class="keyword">instanceof</span> OnBackToFirstListener) &#123;</span><br><span class="line">            _mBackToFirstListener = (OnBackToFirstListener) context;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> View <span class="title">onCreateView</span><span class="params">(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle</span></span></span><br><span class="line"><span class="function"><span class="params">            savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (getLayoutView() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> getLayoutView();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> inflater.inflate(getLayoutId(), <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onViewCreated</span><span class="params">(View view, @Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        mActivity.setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);</span><br><span class="line">        TAG = getClass().getSimpleName();</span><br><span class="line">        binder = ButterKnife.bind(<span class="keyword">this</span>, view);</span><br><span class="line">        mPresenter = TUtils.getT(<span class="keyword">this</span>, <span class="number">0</span>);</span><br><span class="line">        mModel = TUtils.getT(<span class="keyword">this</span>, <span class="number">1</span>);</span><br><span class="line">        initUI(view, savedInstanceState);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">instanceof</span> BaseView) mPresenter.attachVM(<span class="keyword">this</span>, mModel);</span><br><span class="line">        getBundle(getArguments());</span><br><span class="line">        initData();</span><br><span class="line">        <span class="keyword">super</span>.onViewCreated(view, savedInstanceState);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroyView</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroyView();</span><br><span class="line">        <span class="keyword">if</span> (binder != <span class="keyword">null</span>) binder.unbind();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDetach</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDetach();</span><br><span class="line">        _mBackToFirstListener = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">        <span class="keyword">if</span> (mPresenter != <span class="keyword">null</span>) mPresenter.detachVM();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        @Override</span></span><br><span class="line"><span class="comment">        public FragmentAnimator onCreateFragmentAnimator() &#123;</span></span><br><span class="line"><span class="comment">            FragmentAnimator fragmentAnimator = _mActivity.getFragmentAnimator();</span></span><br><span class="line"><span class="comment">            fragmentAnimator.setEnter(0);</span></span><br><span class="line"><span class="comment">            fragmentAnimator.setExit(0);</span></span><br><span class="line"><span class="comment">            return fragmentAnimator;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">getLayoutId</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> View <span class="title">getLayoutView</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 得到Activity传进来的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getBundle</span><span class="params">(Bundle bundle)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化控件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">initUI</span><span class="params">(View view, @Nullable Bundle savedInstanceState)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在监听器之前把数据准备好</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initData</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理回退事件</span></span><br><span class="line"><span class="comment">     * 如果是孩子fragment需要重写onBackPressedSupport()&#123;_mBackToFirstListener.onBackToFirstFragment();return true;&#125;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onBackPressedSupport</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (getChildFragmentManager().getBackStackEntryCount() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            popChild();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">instanceof</span> HomeFragment) &#123;   <span class="comment">// 如果是 第一个Fragment 则退出app</span></span><br><span class="line">                _mActivity.finish();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;                                    <span class="comment">// 如果不是,则回到第一个Fragment</span></span><br><span class="line">                _mBackToFirstListener.onBackToFirstFragment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//return super.onBackPressedSupport();</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OnBackToFirstListener</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">onBackToFirstFragment</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showToast</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        ToastUtils.showToast(mContext, msg, Toast.LENGTH_SHORT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showLog</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        LogUtils.i(TAG, msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-LogUtils和ToastUtils"><a href="#2-LogUtils和ToastUtils" class="headerlink" title="2.LogUtils和ToastUtils"></a>2.LogUtils和ToastUtils</h4><p>LogUtils.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogUtils</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> isDebug = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> String mTag = <span class="string">"LogUtils"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//for error log</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">error</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isDebug) &#123;</span><br><span class="line">            Log.e(mTag, msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//for warming log</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">warn</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isDebug) &#123;</span><br><span class="line">            Log.w(mTag, msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//for info log</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isDebug) &#123;</span><br><span class="line">            Log.i(mTag, msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//for debug log</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">debug</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isDebug) &#123;</span><br><span class="line">            Log.d(mTag, msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//for verbose log</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">verbose</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isDebug) &#123;</span><br><span class="line">            Log.v(mTag, msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//for error log</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">e</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isDebug) &#123;</span><br><span class="line">            Log.e(mTag, msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//for warming log</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">w</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isDebug) &#123;</span><br><span class="line">            Log.w(mTag, msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//for info log</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">i</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isDebug) &#123;</span><br><span class="line">            Log.i(mTag, msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//for debug log</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">d</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isDebug) &#123;</span><br><span class="line">            Log.d(mTag, msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//for verbose log</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">v</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isDebug) &#123;</span><br><span class="line">            Log.v(mTag, msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//for warming log</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">w</span><span class="params">(String tag, String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isDebug) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tag == <span class="keyword">null</span> || <span class="string">""</span>.equalsIgnoreCase(tag.trim())) &#123;</span><br><span class="line">                tag = mTag;</span><br><span class="line">            &#125;</span><br><span class="line">            Log.w(tag, msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//for info log</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">i</span><span class="params">(String tag, String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isDebug) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tag == <span class="keyword">null</span> || <span class="string">""</span>.equalsIgnoreCase(tag.trim())) &#123;</span><br><span class="line">                tag = mTag;</span><br><span class="line">            &#125;</span><br><span class="line">            Log.i(tag, msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//for debug log</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">d</span><span class="params">(String tag, String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isDebug) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tag == <span class="keyword">null</span> || <span class="string">""</span>.equalsIgnoreCase(tag.trim())) &#123;</span><br><span class="line">                tag = mTag;</span><br><span class="line">            &#125;</span><br><span class="line">            Log.d(tag, msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//for verbose log</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">v</span><span class="params">(String tag, String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isDebug) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tag == <span class="keyword">null</span> || <span class="string">""</span>.equalsIgnoreCase(tag.trim())) &#123;</span><br><span class="line">                tag = mTag;</span><br><span class="line">            &#125;</span><br><span class="line">            Log.v(tag, msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//for verbose log</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">e</span><span class="params">(String tag, String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isDebug) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tag == <span class="keyword">null</span> || <span class="string">""</span>.equalsIgnoreCase(tag.trim())) &#123;</span><br><span class="line">                tag = mTag;</span><br><span class="line">            &#125;</span><br><span class="line">            Log.e(tag, msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setDebug</span><span class="params">(<span class="keyword">boolean</span> isDebug)</span> </span>&#123;</span><br><span class="line">        LogUtils.isDebug = isDebug;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isDebug</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isDebug;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 点击Log跳转到指定源码位置</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tag</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">showLog</span><span class="params">(String tag, String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isDebug) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tag == <span class="keyword">null</span> || <span class="string">""</span>.equalsIgnoreCase(tag.trim())) &#123;</span><br><span class="line">                tag = mTag;</span><br><span class="line">            &#125;</span><br><span class="line">            StackTraceElement[] stackTraceElement = Thread.currentThread()</span><br><span class="line">                    .getStackTrace();</span><br><span class="line">            <span class="keyword">int</span> currentIndex = -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; stackTraceElement.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (stackTraceElement[i].getMethodName().compareTo(<span class="string">"showLog"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                    currentIndex = i + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (currentIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                String fullClassName = stackTraceElement[currentIndex].getClassName();</span><br><span class="line">                String className = fullClassName.substring(fullClassName</span><br><span class="line">                        .lastIndexOf(<span class="string">"."</span>) + <span class="number">1</span>);</span><br><span class="line">                String methodName = stackTraceElement[currentIndex].getMethodName();</span><br><span class="line">                String lineNumber = String</span><br><span class="line">                        .valueOf(stackTraceElement[currentIndex].getLineNumber());</span><br><span class="line"></span><br><span class="line">                Log.i(tag, msg + <span class="string">"\n  ----&gt;at "</span> + className + <span class="string">"."</span> + methodName + <span class="string">"("</span></span><br><span class="line">                        + className + <span class="string">".java:"</span> + lineNumber + <span class="string">")"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Log.i(tag, msg);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ToastUtils.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> android.content.Context;</span><br><span class="line"><span class="keyword">import</span> android.widget.Toast;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ToastUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Toast mToast;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 非阻塞试显示Toast,防止出现连续点击Toast时的显示问题</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">showToast</span><span class="params">(Context context, CharSequence text, <span class="keyword">int</span> duration)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mToast == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mToast = Toast.makeText(context, text, duration);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mToast.setText(text);</span><br><span class="line">            mToast.setDuration(duration);</span><br><span class="line">        &#125;</span><br><span class="line">        mToast.show();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">showToast</span><span class="params">(Context context, CharSequence text)</span> </span>&#123;</span><br><span class="line">        showToast(context, text, Toast.LENGTH_SHORT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-RxBus"><a href="#3-RxBus" class="headerlink" title="3. RxBus"></a>3. RxBus</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.reactivex.Observable;</span><br><span class="line"><span class="keyword">import</span> io.reactivex.android.schedulers.AndroidSchedulers;</span><br><span class="line"><span class="keyword">import</span> io.reactivex.annotations.NonNull;</span><br><span class="line"><span class="keyword">import</span> io.reactivex.functions.Consumer;</span><br><span class="line"><span class="keyword">import</span> io.reactivex.subjects.PublishSubject;</span><br><span class="line"><span class="keyword">import</span> io.reactivex.subjects.Subject;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span>:2018/5/18 at 16:07</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: RxBus实现跨模块消息传递</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RxBus</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> RxBus instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ConcurrentHashMap: 线程安全集合</span></span><br><span class="line"><span class="comment">     *   Subject 同时充当了Observer和Observable的角色</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"rawtypes"</span>)</span><br><span class="line">    <span class="keyword">private</span> ConcurrentHashMap&lt;Object, List&lt;Subject&gt;&gt; subjectMapper = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> RxBus <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">null</span> == instance) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> RxBus();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">RxBus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 订阅事件源</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> observable</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> consumer</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RxBus <span class="title">onEvent</span><span class="params">(Observable&lt;?&gt; observable, Consumer&lt;Object&gt; consumer)</span> </span>&#123;</span><br><span class="line">        observable.observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">                .subscribe(consumer, <span class="keyword">new</span> Consumer&lt;Throwable&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Throwable throwable)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        throwable.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        <span class="keyword">return</span> getInstance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册事件源</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tag key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>&#125;)</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Observable&lt;T&gt; <span class="title">register</span><span class="params">(@NonNull Object tag)</span> </span>&#123;</span><br><span class="line">        List&lt;Subject&gt; subjectList = subjectMapper.get(tag);</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">null</span> == subjectList) &#123;</span><br><span class="line">            subjectList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            subjectMapper.put(tag, subjectList);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Subject&lt;T&gt; subject = PublishSubject.create();</span><br><span class="line">        subjectList.add(subject);</span><br><span class="line">        <span class="comment">// LogUtils.log("register" + tag + " size:" + subjectList.size());</span></span><br><span class="line">        <span class="keyword">return</span> subject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 取消整个tag的监听</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tag key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"rawtypes"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unregister</span><span class="params">(@NonNull Object tag)</span> </span>&#123;</span><br><span class="line">        List&lt;Subject&gt; subjectList = subjectMapper.get(tag);</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">null</span> != subjectList) &#123;</span><br><span class="line">            subjectMapper.remove(tag);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 取消tag里某个observable的监听</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tag key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> observable 要删除的observable</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"rawtypes"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> RxBus <span class="title">unregister</span><span class="params">(@NonNull Object tag,</span></span></span><br><span class="line"><span class="function"><span class="params">                            @NonNull Observable&lt;?&gt; observable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">null</span> == observable) &#123;</span><br><span class="line">            <span class="keyword">return</span> getInstance();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;Subject&gt; subjectList = subjectMapper.get(tag);</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">null</span> != subjectList) &#123;</span><br><span class="line">            <span class="comment">// 从subjectList中删去observable</span></span><br><span class="line">            subjectList.remove((Subject&lt;?&gt;) observable);</span><br><span class="line">            <span class="comment">// 若此时subjectList为空则从subjectMapper中删去</span></span><br><span class="line">            <span class="keyword">if</span>(isEmpty(subjectList)) &#123;</span><br><span class="line">                subjectMapper.remove(tag);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> getInstance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 触发事件</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> content</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">post</span><span class="params">(@NonNull Object content)</span> </span>&#123;</span><br><span class="line">        post(content.getClass().getName(), content);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 触发事件</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tag key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> content</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"unchecked"</span>, <span class="string">"rawtypes"</span>&#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">post</span><span class="params">(@NonNull Object tag, @NonNull Object content)</span> </span>&#123;</span><br><span class="line">        List&lt;Subject&gt; subjectList = subjectMapper.get(tag);</span><br><span class="line">        <span class="keyword">if</span>(!isEmpty(subjectList)) &#123;</span><br><span class="line">            <span class="keyword">for</span>(Subject subject : subjectList) &#123;</span><br><span class="line">                subject.onNext(content);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断集合是否为空</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> collection 集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"rawtypes"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">(Collection&lt;Subject&gt; collection)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span> == collection || collection.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RxBus使用也要在mRxManager中add，这样方便统一销毁。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这个配置的方法是在CoreBaseMVP借鉴而来。Rxjava给它升级到了2.X的版本。本章包含以下内容。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;BaseActivity和BaseFragment&lt;/li&gt;
&lt;li&gt;LogUtils和ToastUtils&lt;/li&gt;
&lt;li&gt;RxBus&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="MVP" scheme="http://www.sanmaoliu.com/tags/MVP/"/>
    
      <category term="Frame" scheme="http://www.sanmaoliu.com/tags/Frame/"/>
    
  </entry>
  
  <entry>
    <title>我所使用的MVP框架1</title>
    <link href="http://www.sanmaoliu.com/2018/05/28/%E6%88%91%E6%89%80%E4%BD%BF%E7%94%A8%E7%9A%84MVP%E6%A1%86%E6%9E%B61/"/>
    <id>http://www.sanmaoliu.com/2018/05/28/我所使用的MVP框架1/</id>
    <published>2018-05-28T07:49:26.000Z</published>
    <updated>2018-05-28T08:31:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>这个配置的方法是在CoreBaseMVP借鉴而来。Rxjava给它升级到了2.X的版本。本章包含以下内容。</p><ol><li>AppContext和AppManager</li><li>BaseModel和BaseView</li><li>BasePresenter和与RxManager</li></ol><a id="more"></a><h4 id="1-AppContext和AppManager"><a href="#1-AppContext和AppManager" class="headerlink" title="1. AppContext和AppManager"></a>1. AppContext和AppManager</h4><p>AppContext.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.app.Application;</span><br><span class="line"><span class="keyword">import</span> me.yokeyword.fragmentation.Fragmentation;</span><br><span class="line"><span class="keyword">import</span> me.yokeyword.fragmentation.helper.ExceptionHandler;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span>:2018/5/18 at 15:12</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 获取应用实例和Fragmentation栈视图</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppContext</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AppContext instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AppContext <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate();</span><br><span class="line">        instance = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">        Fragmentation.builder()</span><br><span class="line">                <span class="comment">// 设置 栈视图 模式为 （默认）悬浮球模式   SHAKE: 摇一摇唤出  NONE：隐藏， 仅在Debug环境生效</span></span><br><span class="line">                .stackViewMode(Fragmentation.BUBBLE)</span><br><span class="line">                <span class="comment">//.stackViewMode(Fragmentation.SHAKE)</span></span><br><span class="line">                .debug(<span class="keyword">true</span>) <span class="comment">// 实际场景建议.debug(BuildConfig.DEBUG)</span></span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 可以获取到&#123;<span class="doctag">@link</span> me.yokeyword.fragmentation.exception.AfterSaveStateTransactionWarning&#125;</span></span><br><span class="line"><span class="comment">                 * 在遇到After onSaveInstanceState时，不会抛出异常，会回调到下面的ExceptionHandler</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                .handleException(<span class="keyword">new</span> ExceptionHandler() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onException</span><span class="params">(Exception e)</span> </span>&#123;</span><br><span class="line">                        <span class="comment">// 以Bugtags为例子: 把捕获到的 Exception 传到 Bugtags 后台。</span></span><br><span class="line">                        <span class="comment">// Bugtags.sendException(e);</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                .install();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用AppContext.getInstance()获取当前App的Context，在一些不便获取Context的时候调用。</p><p>记得更改AndroidManifest.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">application</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">"com.herocheer.common.mvp.AppContext"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:allowBackup</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:icon</span>=<span class="string">"@mipmap/ic_launcher"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:label</span>=<span class="string">"@string/app_name"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:roundIcon</span>=<span class="string">"@mipmap/ic_launcher_round"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:supportsRtl</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:theme</span>=<span class="string">"@style/AppTheme.NoActionBar"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Fragmentation相关参见博客相关介绍。实现单Activity多Fragement模式。</p><p>AppManager.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> android.app.Activity;</span><br><span class="line"><span class="keyword">import</span> android.app.ActivityManager;</span><br><span class="line"><span class="keyword">import</span> android.content.Context;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span>:2018/5/18 at 15:49</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 控制Activity栈</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppManager</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Stack&lt;Activity&gt; activityStack;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AppManager instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">AppManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 单一实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AppManager <span class="title">getAppManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> AppManager();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加Activity到堆栈</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addActivity</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (activityStack == <span class="keyword">null</span>) &#123;</span><br><span class="line">            activityStack = <span class="keyword">new</span> Stack&lt;Activity&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        activityStack.add(activity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取当前Activity（堆栈中最后一个压入的）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Activity <span class="title">currentActivity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Activity activity = activityStack.lastElement();</span><br><span class="line">        <span class="keyword">return</span> activity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 结束当前Activity（堆栈中最后一个压入的）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">finishActivity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Activity activity = activityStack.lastElement();</span><br><span class="line">        finishActivity(activity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 结束指定的Activity</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">finishActivity</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (activity != <span class="keyword">null</span>) &#123;</span><br><span class="line">            activityStack.remove(activity);</span><br><span class="line">            activity.finish();</span><br><span class="line">            activity = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 结束指定类名的Activity</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">finishActivity</span><span class="params">(Class&lt;?&gt; cls)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Activity activity : activityStack) &#123;</span><br><span class="line">            <span class="keyword">if</span> (activity.getClass().equals(cls)) &#123;</span><br><span class="line">                finishActivity(activity);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 结束所有Activity</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">finishAllActivity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, size = activityStack.size(); i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != activityStack.get(i)) &#123;</span><br><span class="line">                activityStack.get(i).finish();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        activityStack.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 退出应用程序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AppExit</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            finishAllActivity();</span><br><span class="line">            ActivityManager activityMgr =</span><br><span class="line">                    (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);</span><br><span class="line">            <span class="keyword">assert</span> activityMgr != <span class="keyword">null</span>;</span><br><span class="line">            activityMgr.killBackgroundProcesses(context.getPackageName());</span><br><span class="line">            System.exit(<span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAppExit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> activityStack == <span class="keyword">null</span> || activityStack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AppExit(Context context)的方法需要添加权限<uses-permission android:name="android.permission.KILL_BACKGROUND_PROCESSES"></uses-permission></p><h4 id="2-BaseModel和BaseView"><a href="#2-BaseModel和BaseView" class="headerlink" title="2. BaseModel和BaseView"></a>2. BaseModel和BaseView</h4><p>BaseModel.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span>:2018/5/18 at 15:03</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: BaseModel</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BaseModel</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BaseView.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span>:2018/5/18 at 15:03</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: BaseView</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BaseView</span> </span>&#123;</span><br><span class="line">    <span class="function">Context <span class="title">getContext</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showError</span><span class="params">(String msg)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两个类没啥好说的getContext()是为了在Presenter中方便获取环境</p><p>showError()是为了在View层进行统一错误处理。</p><h4 id="3-BasePresenter和RxManager"><a href="#3-BasePresenter和RxManager" class="headerlink" title="3. BasePresenter和RxManager"></a>3. BasePresenter和RxManager</h4><p>BasePresenter.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.herocheer.common.RxManager;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span>:2018/5/18 at 15:04</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: BasePresenter</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BasePresenter</span>&lt;<span class="title">M</span>, <span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> M mModel;</span><br><span class="line">    <span class="keyword">public</span> T mView;</span><br><span class="line">    <span class="keyword">public</span> RxManager mRxManager = <span class="keyword">new</span> RxManager();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attachVM</span><span class="params">(T v, M m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mView = v;</span><br><span class="line">        <span class="keyword">this</span>.mModel = m;</span><br><span class="line">        <span class="keyword">this</span>.onStart();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">detachVM</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mRxManager.clear();</span><br><span class="line">        mView = <span class="keyword">null</span>;</span><br><span class="line">        mModel = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用了泛型类将MVP三层联系在一起RxManager做统一的观察者销毁。</p><p>RxManager.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.reactivex.Observable;</span><br><span class="line"><span class="keyword">import</span> io.reactivex.android.schedulers.AndroidSchedulers;</span><br><span class="line"><span class="keyword">import</span> io.reactivex.disposables.CompositeDisposable;</span><br><span class="line"><span class="keyword">import</span> io.reactivex.disposables.Disposable;</span><br><span class="line"><span class="keyword">import</span> io.reactivex.functions.Consumer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span>:2018/5/18 at 16:05</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RxManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> RxBus mRxBus = RxBus.getInstance();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 管理观察源</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Observable&lt;?&gt;&gt; mObservableMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 管理订阅者</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> CompositeDisposable mCompositeSubscription = <span class="keyword">new</span> CompositeDisposable();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">on</span><span class="params">(String eventName, Consumer&lt;Object&gt; consumer)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 注册</span></span><br><span class="line">        Observable&lt;?&gt; mObservable = mRxBus.register(eventName);</span><br><span class="line"></span><br><span class="line">        mObservableMap.put(eventName, mObservable);</span><br><span class="line"></span><br><span class="line">        mCompositeSubscription</span><br><span class="line">                .add(mObservable.observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">                        .subscribe(consumer, <span class="keyword">new</span> Consumer&lt;Throwable&gt;() &#123;</span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Throwable throwable)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                                throwable.printStackTrace();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加订阅者到mCompositeSubscription</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> m 要添加的订阅者</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Disposable m)</span> </span>&#123;</span><br><span class="line">        mCompositeSubscription.add(m);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 取消所有注册</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 取消订阅</span></span><br><span class="line">        mCompositeSubscription.dispose();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Observable&lt;?&gt;&gt; entry : mObservableMap.entrySet()) &#123;</span><br><span class="line">            <span class="comment">// 取消注册</span></span><br><span class="line">            mRxBus.unregister(entry.getKey(), entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 触发事件</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tag</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> content</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">post</span><span class="params">(Object tag, Object content)</span> </span>&#123;</span><br><span class="line">        mRxBus.post(tag, content);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这个配置的方法是在CoreBaseMVP借鉴而来。Rxjava给它升级到了2.X的版本。本章包含以下内容。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;AppContext和AppManager&lt;/li&gt;
&lt;li&gt;BaseModel和BaseView&lt;/li&gt;
&lt;li&gt;BasePresenter和与RxManager&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="MVP" scheme="http://www.sanmaoliu.com/tags/MVP/"/>
    
      <category term="Frame" scheme="http://www.sanmaoliu.com/tags/Frame/"/>
    
  </entry>
  
  <entry>
    <title>gradle备份</title>
    <link href="http://www.sanmaoliu.com/2018/05/25/gradle%E5%A4%87%E4%BB%BD/"/>
    <id>http://www.sanmaoliu.com/2018/05/25/gradle备份/</id>
    <published>2018-05-25T09:03:48.000Z</published>
    <updated>2018-05-28T07:16:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>备份一份最近使用的build.gradle<br>嘻嘻<br><a id="more"></a><br> <figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">apply <span class="string">plugin:</span> <span class="string">'com.android.application'</span></span><br><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">    compileSdkVersion <span class="number">27</span></span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        applicationId <span class="string">"com.xxx.xxx.xxxxx"</span></span><br><span class="line">        minSdkVersion <span class="number">21</span></span><br><span class="line">        targetSdkVersion <span class="number">27</span></span><br><span class="line">        versionCode <span class="number">1</span></span><br><span class="line">        versionName <span class="string">"1.0"</span></span><br><span class="line">        testInstrumentationRunner <span class="string">"android.support.test.runner.AndroidJUnitRunner"</span></span><br><span class="line">    &#125;</span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            minifyEnabled <span class="literal">false</span></span><br><span class="line">            proguardFiles getDefaultProguardFile(<span class="string">'proguard-android.txt'</span>), <span class="string">'proguard-rules.pro'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    implementation fileTree(<span class="string">include:</span> [<span class="string">'*.jar'</span>], <span class="string">dir:</span> <span class="string">'libs'</span>)</span><br><span class="line">    implementation <span class="string">'com.android.support:appcompat-v7:27.1.1'</span></span><br><span class="line">    implementation <span class="string">'com.android.support:recyclerview-v7:27.1.1'</span></span><br><span class="line">    implementation <span class="string">'com.android.support:design:27.1.1'</span></span><br><span class="line">    implementation <span class="string">'com.android.support.constraint:constraint-layout:1.1.0'</span></span><br><span class="line">    implementation <span class="string">'com.android.support:support-v4:27.1.1'</span></span><br><span class="line">    testImplementation <span class="string">'junit:junit:4.12'</span></span><br><span class="line">    androidTestImplementation <span class="string">'com.android.support.test:runner:1.0.2'</span></span><br><span class="line">    androidTestImplementation <span class="string">'com.android.support.test.espresso:espresso-core:3.0.2'</span></span><br><span class="line">    <span class="comment">//RxJava依赖</span></span><br><span class="line">    implementation <span class="string">'io.reactivex.rxjava2:rxjava:2.1.12'</span></span><br><span class="line">    implementation <span class="string">'io.reactivex.rxjava2:rxandroid:2.0.2'</span></span><br><span class="line">    <span class="comment">//Retrofit依赖</span></span><br><span class="line">    implementation <span class="string">'com.squareup.retrofit2:retrofit:2.4.0'</span></span><br><span class="line">    implementation <span class="string">'com.squareup.okhttp3:okhttp:3.10.0'</span></span><br><span class="line">    implementation <span class="string">'com.squareup.okhttp3:logging-interceptor:3.10.0'</span></span><br><span class="line">    implementation <span class="string">'com.squareup.retrofit2:converter-gson:2.3.0'</span></span><br><span class="line">    implementation <span class="string">'com.squareup.retrofit2:adapter-rxjava:2.3.0'</span></span><br><span class="line">    implementation <span class="string">'com.jakewharton.retrofit:retrofit2-rxjava2-adapter:1.0.0'</span></span><br><span class="line">    <span class="comment">//Glide依赖</span></span><br><span class="line">    implementation <span class="string">'com.github.bumptech.glide:glide:4.6.1'</span></span><br><span class="line">    annotationProcessor <span class="string">'com.github.bumptech.glide:compiler:4.6.1'</span></span><br><span class="line">    <span class="comment">//fragmentation</span></span><br><span class="line">    implementation <span class="string">'me.yokeyword:fragmentation:1.3.4'</span></span><br><span class="line">    <span class="comment">//fragmentation左划返回支持</span></span><br><span class="line">    <span class="comment">//implementation 'me.yokeyword:fragmentation-swipeback:1.3.4'</span></span><br><span class="line">    <span class="comment">//base-adapter https://github.com/hongyangAndroid/baseAdapter 张鸿洋的recycleview适配</span></span><br><span class="line">    implementation <span class="string">'com.zhy:base-rvadapter:3.0.3'</span></span><br><span class="line">    <span class="comment">//IRecyclerView https://github.com/Aspsine/IRecyclerView</span></span><br><span class="line">    implementation <span class="string">'com.github.Aspsine:IRecyclerView:0.0.5'</span></span><br><span class="line">    <span class="comment">//Butter Knife依赖</span></span><br><span class="line">    implementation <span class="string">'com.jakewharton:butterknife:8.8.1'</span></span><br><span class="line">    annotationProcessor <span class="string">'com.jakewharton:butterknife-compiler:8.8.1'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;备份一份最近使用的build.gradle&lt;br&gt;嘻嘻&lt;br&gt;
    
    </summary>
    
    
      <category term="gradle" scheme="http://www.sanmaoliu.com/tags/gradle/"/>
    
  </entry>
  
  <entry>
    <title>Fragmentation的学习4</title>
    <link href="http://www.sanmaoliu.com/2018/05/22/Fragmentation%E7%9A%84%E5%AD%A6%E4%B9%A04/"/>
    <id>http://www.sanmaoliu.com/2018/05/22/Fragmentation的学习4/</id>
    <published>2018-05-22T02:14:37.000Z</published>
    <updated>2018-05-22T07:07:22.000Z</updated>
    
    <content type="html"><![CDATA[<ol><li>startForResult</li><li>启动模式</li><li>同级未加入回退栈的Fragments</li></ol><a id="more"></a><h4 id="1-startForResult"><a href="#1-startForResult" class="headerlink" title="1. startForResult"></a>1. startForResult</h4><p>Fragmentation提供了类似Activity的启动方法:</p><p>启动新的Fragment，并能接收到新Fragment的数据返回：<code>startForResult(SupportFragment fragment,int requestCode)</code></p><p>下面是DetailFragment  <code>startForResult</code>  ModifyTitleFragment的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DetailFragment</span> <span class="keyword">extends</span> <span class="title">SupportFragment</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">goDetail</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="comment">// 启动</span></span><br><span class="line">      startForResult(ModifyDetailFragment.newInstance(mTitle), REQ_CODE);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 目标Fragment调用setFragmentResult()后，在其出栈时，会回调该方法</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFragmentResult</span><span class="params">(<span class="keyword">int</span> requestCode, <span class="keyword">int</span> resultCode, Bundle data)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>.onFragmentResult(requestCode, resultCode, data);</span><br><span class="line">      <span class="keyword">if</span> (requestCode == REQ_CODE &amp;&amp; resultCode == RESULT_OK ) &#123;</span><br><span class="line">          <span class="comment">// 在此通过Bundle data 获取返回的数据</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ModifyTitleFragment</span> <span class="keyword">extends</span> <span class="title">SupportFragment</span></span>&#123;</span><br><span class="line">    <span class="comment">// 设置传给上个Fragment的数据</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setResult</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Bundle bundle = <span class="keyword">new</span> Bundle();</span><br><span class="line">        bundle.putString(<span class="string">"title"</span>, <span class="string">"xxxx"</span>);</span><br><span class="line">        setFramgentResult(RESULT_OK, bundle);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="2-启动模式"><a href="#2-启动模式" class="headerlink" title="2. 启动模式"></a>2. 启动模式</h4><p>以某种启动模式启动Fragment：<code>start(SupportFragment fragment, int launchMode)</code></p><p>下面是以SingleTask模式重新启动一个已存在的Fragment的标准代码：<br>比如：HomeFragment-&gt;B Fragment-&gt;C Fragment，C Fragment以SingleTask模式重新启动HomeFragment<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 任意同栈内的Fragment中：</span></span><br><span class="line">    HomeFragment fragment = findFragment(HomeFragment.class);</span><br><span class="line">    Bundle newBundle = <span class="keyword">new</span> Bundle();</span><br><span class="line">    ...</span><br><span class="line">    fragment.putNewBundle(newBundle);</span><br><span class="line">    <span class="comment">// 在栈内的HomeFragment以SingleTask模式启动（即在其之上的Fragment会出栈）</span></span><br><span class="line">    start(fragment, SupportFragment.SINGLETASK);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HomeFragment</span> <span class="keyword">extends</span> <span class="title">SupportFragment</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onNewBundle</span><span class="params">(Bundle newBundle)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 在此可以接收到SINGLETASK/SINGTOP启动模式传递的数据  类似Activity中的onNewIntent()</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="3-同级未加入回退栈的Fragments"><a href="#3-同级未加入回退栈的Fragments" class="headerlink" title="3. 同级未加入回退栈的Fragments"></a>3. 同级未加入回退栈的Fragments</h4><p><code>ViewPager</code>、<code>FragmentTabHost</code>、及库提供的<code>loadMultiRootFragment()</code>均属于这种情况</p><p><strong>记住一个原则： 避免在未加入回退栈的层级内去<code>start()</code>其它Fragment， 比如<code>ViewPager</code>、<code>loadMultiRootFragment()</code>、<code>FragmentTabHost</code>内部的Fragment不可以直接<code>start</code>，这种情况下其内的栈应该保持干净，如果想启动其它Fragment，应该由它们的父Fragment或子Fragment去<code>start</code></strong></p><p>装载TabFragments</p><p>装载同级Fragment，我们需要用到<code>loadMultipleRootFragment(int containerId, int showPosition, SupportFragment... fragments)</code>，其中参数分别对应容器id，需要show的Fragment下标位置，SupportFragment的数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">SupportActivity</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.multi_activity_main);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (findFragment(MultiFirstFragment.class) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mFragments[FIRST] = MultiFirstFragment.newInstance();</span><br><span class="line">            mFragments[SECOND] = MultiSecondFragment.newInstance();</span><br><span class="line">            mFragments[THIRD] = MultiThirdFragment.newInstance();</span><br><span class="line"></span><br><span class="line">            loadMultipleRootFragment(R.id.fl_container, FIRST,</span><br><span class="line">                    mFragments[FIRST],</span><br><span class="line">                    mFragments[SECOND],</span><br><span class="line">                    mFragments[THIRD]</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 这里库已经做了Fragment恢复工作，不需要额外的处理</span></span><br><span class="line">            <span class="comment">// 这里我们需要拿到mFragments的引用，用下面的方法查找更方便些，也可以通过getSupportFragmentManager.getFragments()自行进行判断查找(效率更高些)</span></span><br><span class="line">            mFragments[FIRST] = findFragment(MultiFirstFragment.class);</span><br><span class="line">            mFragments[SECOND] = findFragment(MultiSecondFragment.class);</span><br><span class="line">            mFragments[THIRD] = findFragment(MultiThirdFragment.class);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>切换TabFragment</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一个参数为需要show的Fragment，第二个为需要hide的Fragment</span></span><br><span class="line">showHideFragment(needShowFragment, needHideFragment);</span><br></pre></td></tr></table></figure><p>优化：懒加载</p><p>通常我们会使用懒加载来兼顾性能和优化内存，详见懒加载。</p>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;startForResult&lt;/li&gt;
&lt;li&gt;启动模式&lt;/li&gt;
&lt;li&gt;同级未加入回退栈的Fragments&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="Fragmentation" scheme="http://www.sanmaoliu.com/tags/Fragmentation/"/>
    
      <category term="Fragment" scheme="http://www.sanmaoliu.com/tags/Fragment/"/>
    
  </entry>
  
  <entry>
    <title>Fragmentation的学习3</title>
    <link href="http://www.sanmaoliu.com/2018/05/22/Fragmentation%E7%9A%84%E5%AD%A6%E4%B9%A03/"/>
    <id>http://www.sanmaoliu.com/2018/05/22/Fragmentation的学习3/</id>
    <published>2018-05-22T01:47:15.000Z</published>
    <updated>2018-05-22T02:13:58.000Z</updated>
    
    <content type="html"><![CDATA[<ol><li>懒加载</li><li>优化Animation性能</li><li>转场动画</li><li>Back键监听机制</li></ol><a id="more"></a><h4 id="1-懒加载"><a href="#1-懒加载" class="headerlink" title="1. 懒加载"></a>1. 懒加载</h4><p>在使用Fragment过程中，有些场景需要懒加载，比如FragmentAdapter的懒加载、同级Fragment切换的懒加载，库中自0.8版本提供了<code>onLazyInitView(Bundle saveInstanceState)</code>方法使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyFragment</span> <span class="keyword">extends</span> <span class="title">BaseFragment</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 懒加载</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLazyInitView</span><span class="params">(@Nullable Bundle savedInstanceState)</span></span>&#123;</span><br><span class="line">        <span class="comment">// todo</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-优化Animation性能"><a href="#2-优化Animation性能" class="headerlink" title="2. 优化Animation性能"></a>2. 优化Animation性能</h4><p>在复杂Fragment页面，第一次start时，会导致该Fragment因复杂初始化和动画的同时进行，导致动画卡顿问题，库中提供一个解决方案：<code>onEnterAnimationEnd(Bundle saveInstanceState)</code>的回调方法。</p><p>该方法会在转场动画结束后调用，如果没有动画则在onActivityCreated时调用，此时在<code>onEnterAnimtionEnd(Bundle saveInstanceState)</code>里初始化复杂数据，可以避免保证Fragment动画的流畅。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> View <span class="title">onCreateView</span><span class="params">(...)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 这里仅给toolbar设置标题，返回箭头等轻量UI的操作</span></span><br><span class="line">    initView();</span><br><span class="line">    <span class="keyword">return</span> view;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onEnterAnimationEnd</span><span class="params">(Bundle saveInstanceState)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 这里设置Listener、各种Adapter、请求数据等等</span></span><br><span class="line">    initLazyView();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>此外，竖直动画在视觉上会比横向动画更流畅</p></blockquote><h4 id="3-转场动画"><a href="#3-转场动画" class="headerlink" title="3. 转场动画"></a>3. 转场动画</h4><p><strong>通过SupportActivity设置全局Fragment的转场动画</strong><br>当然如果不满足你的需求，可以自定义。你只需要通过复写SupportActivity的<code>onCreateFragmentAnimator()</code>，就可以轻松为该Activity下所有的Fragment设置转场动画，或者使用<code>setFragmentAnimator()</code>来动态改变动画。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> FragmentAnimator <span class="title">onCreateFragmentAnimator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 设置横向(和安卓4.x动画相同)</span></span><br><span class="line">        <span class="comment">// return new DefaultHorizontalAnimator();</span></span><br><span class="line">        <span class="comment">// 设置无动画</span></span><br><span class="line">        <span class="comment">// return new DefaultNoAnimator();</span></span><br><span class="line">        <span class="comment">// 设置自定义动画</span></span><br><span class="line">        <span class="comment">// return new FragmentAnimator(enter,exit,popEnter,popExit);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 默认竖向(和安卓5.0以上的动画相同)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onCreateFragmentAnimator();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>为Fragment单独设置转场动画</strong><br>如果某个Fragment不想使用Activity全局设置的动画，则可以通过复写Fragment内的<code>onCreateFragmentAnimator()</code>仅为该Fragment设置动画，，或者使用<code>setFragmentAnimator()</code>来动态改变动画。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过</span></span><br><span class="line">setFragmentAnimator(FragmentAnimator);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者复写</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> FragmentAnimator <span class="title">onCreateFragmentAnimator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取在SupportActivity里设置的全局动画对象，进行修改</span></span><br><span class="line">    FragmentAnimator fragmentAnimator = <span class="keyword">super</span>.onCreateFragmentAnimation();</span><br><span class="line">    fragmentAnimator.setEnter(<span class="number">0</span>);</span><br><span class="line">    fragmentAnimator.setExit(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> fragmentAnimator;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 也可以直接通过</span></span><br><span class="line">    <span class="comment">// return new FragmentAnimator(enter,exit,popEnter,popExit)设置一个全新的动画</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>为启动方Fragment和目标方Fragment 单独设置转场动画</strong><br>下面的方法可以让启动的Fragment和目标Fragment拥有临时动画，优先级大于上面的FragmentAnimator设置；</p><blockquote><p>场景：当你想以某个特殊动画启动一个Fragment的小弹窗时，可以使用下面方法，它不影响Fragment本身的FragmentAnimator<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">extraTransaction().setCustomAnimations(targetFragmentEnter, currentFragmentPopExit, currentFragmentPopEnter, targetFragmentExit).start(targetFragment);</span><br></pre></td></tr></table></figure></p></blockquote><p><strong>MD过渡动画：SharedElement</strong><br>Fragmentation支持SharedElement（5.0+），示例代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Build.VERSION.SDK_INT &gt; Build.VERSION_CODES.LOLLIPOP) &#123;</span><br><span class="line">     setExitTransition(<span class="keyword">new</span> Fade());</span><br><span class="line">     fragment.setEnterTransition(<span class="keyword">new</span> Fade());</span><br><span class="line">     fragment.setSharedElementReturnTransition(<span class="keyword">new</span> DetailTransition());</span><br><span class="line">     fragment.setSharedElementEnterTransition(<span class="keyword">new</span> DetailTransition());</span><br><span class="line">     <span class="comment">// 25.1.0以下的support包,Material过渡动画只有在进栈时有,返回时没有;</span></span><br><span class="line">     <span class="comment">// 25.1.0+的support包，SharedElement正常</span></span><br><span class="line">     fragment.extraTransaction()</span><br><span class="line">             .addSharedElement(((FirstHomeAdapter.VH) vh).img, getString(R.string.image_transition))</span><br><span class="line">             .addSharedElement(((FirstHomeAdapter.VH) vh).tvTitle, <span class="string">"tv"</span>)</span><br><span class="line">             .start();</span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">    start(fragment);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>动画的优化</strong><br>在复杂Fragment页面，第一次start时，会导致该Fragment因复杂初始化和动画的同时进行，导致动画卡顿问题，库中提供一个解决方案：onEnterAnimationEnd()的回调方法，具体使用移步Fragmentation的学习2</p><h4 id="4-Back键监听机制"><a href="#4-Back键监听机制" class="headerlink" title="4. Back键监听机制"></a>4. Back键监听机制</h4><p>Fragmentation库提供一个类似Android事件分发机制的Back键监听机制：</p><p>按下Back键，事件首先传递到Activity内栈顶的Fragment，如果该Fragment有子Fragment，则传递到子栈内的栈顶子Fragment，依次类推；</p><p>如果栈顶子Fragment不处理该事件，则向上传递（栈底还有子Fragment则向栈底传递，如果没有则向父Fragment传递，最终到SupportActivity）</p><p>如果处理该事件，则消费该事件，不再向上传递。</p><h5 id="对于SupportActivity"><a href="#对于SupportActivity" class="headerlink" title="对于SupportActivity"></a>对于SupportActivity</h5><p>注意：请不要复写onBackPressed()方法，改为复写onBackPressedSupport()；<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 任意Fragment的onBackPressedSupport()返回true，该方法都不会被回调</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onBackPressedSupport</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// super的实现为：</span></span><br><span class="line">    <span class="comment">// if (getSupportFragmentManager().getBackStackEntryCount() &gt; 1) &#123;</span></span><br><span class="line">    <span class="comment">//     mFragmentation.back(getSupportFragmentManager());</span></span><br><span class="line">    <span class="comment">// &#125; else &#123;</span></span><br><span class="line">    <span class="comment">//     finish();</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="keyword">super</span>.onBackPressedSupport();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="对于SupportFragment"><a href="#对于SupportFragment" class="headerlink" title="对于SupportFragment"></a>对于SupportFragment</h5><p>如果return true，则消费该事件，不再向上传递。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onBackPressedSupport</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 默认flase，继续向上传递</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.onBackPressedSupport();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;懒加载&lt;/li&gt;
&lt;li&gt;优化Animation性能&lt;/li&gt;
&lt;li&gt;转场动画&lt;/li&gt;
&lt;li&gt;Back键监听机制&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="Fragmentation" scheme="http://www.sanmaoliu.com/tags/Fragmentation/"/>
    
      <category term="Fragment" scheme="http://www.sanmaoliu.com/tags/Fragment/"/>
    
  </entry>
  
  <entry>
    <title>Fragmentation的学习2</title>
    <link href="http://www.sanmaoliu.com/2018/05/22/Fragmentation%E7%9A%84%E5%AD%A6%E4%B9%A02/"/>
    <id>http://www.sanmaoliu.com/2018/05/22/Fragmentation的学习2/</id>
    <published>2018-05-22T01:00:12.000Z</published>
    <updated>2018-05-22T01:26:58.000Z</updated>
    
    <content type="html"><![CDATA[<ol><li>导包</li><li>核心概括</li><li>Application初始化API</li><li>API一览</li></ol><a id="more"></a><h4 id="1-导包"><a href="#1-导包" class="headerlink" title="1. 导包"></a>1. 导包</h4><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// appcompat-v7包是必须的</span></span><br><span class="line">compile <span class="string">'me.yokeyword:fragmentation:&#123;version&#125;'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果不想继承SupportActivity/Fragment，自己定制Support，可仅依赖:</span></span><br><span class="line"><span class="comment">// compile 'me.yokeyword:fragmentation-core:&#123;version&#125;'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果想使用SwipeBack 滑动边缘退出Fragment/Activity功能，完整的添加规则如下：</span></span><br><span class="line">compile <span class="string">'me.yokeyword:fragmentation:&#123;version&#125;'</span></span><br><span class="line"><span class="comment">// swipeback基于fragmentation, 如果是自定制SupportActivity/Fragment，则参照SwipeBackActivity/Fragment实现即可</span></span><br><span class="line">compile <span class="string">'me.yokeyword:fragmentation-swipeback:&#123;version&#125;'</span></span><br></pre></td></tr></table></figure><h4 id="2-核心概括"><a href="#2-核心概括" class="headerlink" title="2. 核心概括"></a>2. 核心概括</h4><ul><li><code>loadRootX()</code>系列方法，操作的对象是 孩子Fragment，为避免被强杀重启后重复load，建议在<code>findChildFragment(ChildFragment.class)==null</code>情况下才load；</li><li><code>startX()</code>，<code>popX()</code>，<code>find/getX()</code>系列方法，操作的对象是 兄弟Fragment；</li><li><code>popChildX()</code>，<code>find/getChildX()</code>系列方法，操作的对象是 孩子Fragment。</li></ul><blockquote><p>通过上面3个概念配合详细的API以及栈视图，就可以轻松开发出单Activity＋多Fragment结构的App。</p></blockquote><h4 id="3-Application初始化API"><a href="#3-Application初始化API" class="headerlink" title="3. Application初始化API"></a>3. Application初始化API</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Fragmentation.builder()</span><br><span class="line">        <span class="comment">// 设置 栈视图 模式为 悬浮球模式   SHAKE: 摇一摇唤出   NONE：隐藏</span></span><br><span class="line">        .stackViewMode(Fragmentation.BUBBLE)</span><br><span class="line">        .debug(BuildConfig.DEBUG)</span><br><span class="line">        <span class="comment">// 在遇到After onSaveInstanceState时，不会抛出异常，会回调到下面的ExceptionHandler</span></span><br><span class="line">        .handleException(<span class="keyword">new</span> ExceptionHandler() &#123;</span><br><span class="line">             <span class="meta">@Override</span></span><br><span class="line">             <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onException</span><span class="params">(Exception e)</span> </span>&#123;</span><br><span class="line">                 <span class="comment">// 建议在该回调处上传至我们的Crash监测服务器 </span></span><br><span class="line">                 <span class="comment">// 以Bugtags为例子: 手动把捕获到的 Exception 传到 Bugtags 后台。</span></span><br><span class="line">                 <span class="comment">// Bugtags.sendException(e);</span></span><br><span class="line">             &#125;</span><br><span class="line">         &#125;)</span><br><span class="line">         .install();</span><br></pre></td></tr></table></figure><h4 id="4-API一览"><a href="#4-API一览" class="headerlink" title="4. API一览"></a>4. API一览</h4><h5 id="装载根Fragment，一般在findChildFragment-ChildFragment-class-null时load"><a href="#装载根Fragment，一般在findChildFragment-ChildFragment-class-null时load" class="headerlink" title="装载根Fragment，一般在findChildFragment(ChildFragment.class)==null时load"></a>装载根Fragment，一般在findChildFragment(ChildFragment.class)==null时load</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 装载根Fragment, 即Activity内的第一个Fragment 或 Fragment内的第一个子Fragment</span></span><br><span class="line">loadRootFragment(<span class="keyword">int</span> containerId, SupportFragment toFragment)</span><br><span class="line">loadRootFragment(<span class="keyword">int</span> containerId, SupportFragment toFragment, <span class="keyword">boolean</span> addToBackStack, <span class="keyword">boolean</span> allowEnterAnim)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 装载多个根Fragment，用于同级Fragment的场景，详情见新Demo的MainActivity</span></span><br><span class="line">loadMultipleRootFragment(<span class="keyword">int</span> containerId, <span class="keyword">int</span> showPosition, SupportFragment... toFragments);</span><br></pre></td></tr></table></figure><p>附：同级Fragment场景下的切换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// show一个Fragment，hide一个Fragment； 主要用于类似微信主页那种 切换tab的情况</span></span><br><span class="line">showHideFragment(SupportFragment showFragment, SupportFragment hideFragment);</span><br></pre></td></tr></table></figure><h5 id="启动Fragment"><a href="#启动Fragment" class="headerlink" title="启动Fragment"></a>启动Fragment</h5><blockquote><p> 如果在Activity使用，则本质是<code>activity.getSupportFragmentManager().getTopFragment().start(f)</code>；</p></blockquote><p>SupportFragment和SupportActivity共有的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 启动新的Fragment，启动者和被启动者是在同一个栈的</span></span><br><span class="line">start(SupportFragment fragment)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以某种启动模式，启动新的Fragment</span></span><br><span class="line">start(SupportFragment fragment, <span class="keyword">int</span> launchMode)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动新的Fragment，并能接收到新Fragment的数据返回</span></span><br><span class="line">startForResult(SupportFragment fragment,<span class="keyword">int</span> requestCode)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动目标Fragment，并关闭当前Fragment</span></span><br><span class="line">startWithPop(SupportFragment fragment)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动目标Fragment，并关闭targetFragment之上的Fragments</span></span><br><span class="line">startWithPopTo(SupportFragment fragment, Class targetFragment, <span class="keyword">boolean</span> includeTargetFragment)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.0.0 New:  你可以使用extraTransaction() + start() 来实现上面的各种startXX()设置更多功能</span></span><br><span class="line">supportFragment.extraTransaction()</span><br><span class="line">                .setTag(tag)  <span class="comment">// 自定义tag</span></span><br><span class="line">                .addSharedElement(xx).setLaunchMode(SINGLETASK).withPop(<span class="keyword">true</span>).forResult(<span class="number">1</span>)</span><br><span class="line">                .start()</span><br><span class="line">                .popTo(tag, includeTagFragment)</span><br><span class="line">              <span class="comment">//.dontAddToBackStack()</span></span><br><span class="line">              <span class="comment">//.add()</span></span><br><span class="line">              <span class="comment">//.remove(f) ...</span></span><br></pre></td></tr></table></figure></p><p>下面的方法是SupportFragment才有的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// replace方式启动目标Fragment，配合replaceLoadRootFragment()使用</span></span><br><span class="line">replaceFragment(SupportFragment toFragment, <span class="keyword">boolean</span> addToBack)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Fragmentation的事务内部是通过一个ActionQueue队列排队执行的，使用该方法可以将自定义任务（事务）入队执行</span></span><br><span class="line">post(Runnable runnable)</span><br></pre></td></tr></table></figure><h5 id="出栈"><a href="#出栈" class="headerlink" title="出栈"></a>出栈</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 出栈当前Fragment(在当前Fragment所在栈内pop)</span></span><br><span class="line">pop();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出栈targetFragment之上的所有Fragments</span></span><br><span class="line">popTo(Class targetFragment, <span class="keyword">boolean</span> includeTargetFragment);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果想出栈后，紧接着.beginTransaction()开始一个新事务，请使用下面的方法：</span></span><br><span class="line"><span class="comment">// 该方法可以自定义出栈动画，可以让动画看起来更自然，如果对动画无要求，也可以使用popTo() + 事务来执行</span></span><br><span class="line">popTo(Class targetFragment, <span class="keyword">boolean</span> includeTargetFragment, Runnable afterTransaction, <span class="keyword">int</span> animation)</span><br></pre></td></tr></table></figure><p>下面的方法是SupportFragment才有的，操作目标是子Fragment：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">popChild();</span><br><span class="line">popToChild(Class fragmentClass, <span class="keyword">boolean</span> includeSelf);</span><br><span class="line">popToChild(Class fragmentClass, <span class="keyword">boolean</span> includeSelf, Runnable afterTransaction);</span><br><span class="line">popToChild(Class fragmentClass, <span class="keyword">boolean</span> includeSelf, Runnable afterTransaction,<span class="keyword">int</span> popAnim);</span><br></pre></td></tr></table></figure><h5 id="查找Fragment"><a href="#查找Fragment" class="headerlink" title="查找Fragment"></a>查找Fragment</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取所在栈内的栈顶Fragment</span></span><br><span class="line">getTopFragment();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前Fragment所在栈内的前一个Fragment</span></span><br><span class="line">getPreFragment();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过class获取所在栈内的某个Fragment</span></span><br><span class="line">findFragment(Class fragmentClass);</span><br><span class="line"></span><br><span class="line"><span class="comment">//下面的方法是SupportFragment才有的，从子栈内查找：</span></span><br><span class="line">getTopChildFragment();</span><br><span class="line">findChildFragment(Class fragmentClass);</span><br></pre></td></tr></table></figure><h5 id="输入法相关"><a href="#输入法相关" class="headerlink" title="输入法相关"></a>输入法相关</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 隐藏软键盘 一般用在hide时</span></span><br><span class="line">hideSoftInput();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示软键盘，调用该方法后，会在onPause时自动隐藏软键盘</span></span><br><span class="line">showSoftInput(View view);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;导包&lt;/li&gt;
&lt;li&gt;核心概括&lt;/li&gt;
&lt;li&gt;Application初始化API&lt;/li&gt;
&lt;li&gt;API一览&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="Fragmentation" scheme="http://www.sanmaoliu.com/tags/Fragmentation/"/>
    
      <category term="Fragment" scheme="http://www.sanmaoliu.com/tags/Fragment/"/>
    
  </entry>
  
  <entry>
    <title>Activity的四种launchMode</title>
    <link href="http://www.sanmaoliu.com/2018/05/21/Activity%E7%9A%84%E5%9B%9B%E7%A7%8DlaunchMode/"/>
    <id>http://www.sanmaoliu.com/2018/05/21/Activity的四种launchMode/</id>
    <published>2018-05-21T03:28:09.000Z</published>
    <updated>2018-05-21T06:34:50.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Activity的四种launchMode"><a href="#Activity的四种launchMode" class="headerlink" title="Activity的四种launchMode"></a>Activity的四种launchMode</h3><p>launchMode在多个Activity跳转的过程中扮演着重要的角色，它可以决定是否生成新的Activity实例，是否重用已存在的Activity实例，是否和其他Activity实例公用一个task里。这里简单介绍一下task的概念，task是一个具有栈结构的对象，一个task可以管理多个Activity，启动一个应用，也就创建一个与之对应的task。</p><p>Activity一共有以下四种launchMode：</p><ol><li>standard</li><li>singleTop</li><li>singleTask</li><li>singleInstance</li></ol><p>我们可以在AndroidManifest.xml配置<activity>的android:launchMode属性为以上四种之一即可。</activity></p><a id="more"></a><h4 id="1-standard"><a href="#1-standard" class="headerlink" title="1.standard"></a>1.standard</h4><p>standard模式是默认的启动模式，不用为<activity>配置android:launchMode属性即可，当然也可以指定值为standard。</activity></p><p><img src="https://coding.net/u/sanmaoliu/p/pictures/git/raw/master/Activity的四种launchMode.png" alt></p><p>如图所示，每次跳转系统都会在task中生成一个新的FirstActivity实例，并且放于栈结构的顶部，当我们按下后退键时，才能看到原来的FirstActivity实例。</p><p>这就是standard启动模式，不管有没有已存在的实例，都生成新的实例。</p><h4 id="2-singleTop"><a href="#2-singleTop" class="headerlink" title="2.singleTop"></a>2.singleTop</h4><p><img src="https://coding.net/u/sanmaoliu/p/pictures/git/raw/master/Activity的四种launchMode2.png" alt><br>上图所示，跳转时系统会先在栈结构中寻找是否有一个FirstActivity实例正位于栈顶，如果有则不再生成新的，而是直接使用。也许朋友们会有疑问，我只看到栈内只有一个Activity，如果是多个Activity怎么办，如果不是在栈顶会如何？<br><img src="https://coding.net/u/sanmaoliu/p/pictures/git/raw/master/Activity的四种launchMode3.png" alt><br>这就是singleTop启动模式，如果发现有对应的Activity实例正位于栈顶，则重复利用，不再生成新的实例。不是位于栈顶，重新生成一个实例。</p><h4 id="3-singleTask"><a href="#3-singleTask" class="headerlink" title="3.singleTask"></a>3.singleTask</h4><p><img src="https://coding.net/u/sanmaoliu/p/pictures/git/raw/master/Activity的四种launchMode4.png" alt><br>singleTask模式，如果发现有对应的Activity实例，则使此Activity实例之上的其他Activity实例统统出栈，使此Activity实例成为栈顶对象，显示到幕前。</p><h4 id="4-singleInstance"><a href="#4-singleInstance" class="headerlink" title="4.singleInstance"></a>4.singleInstance</h4><p><img src="https://coding.net/u/sanmaoliu/p/pictures/git/raw/master/Activity的四种launchMode5.png" alt><br>举一个例子，假如我们有一个share应用，其中的ShareActivity是入口Activity，也是可供其他应用调用的Activity，我们把这个Activity的启动模式设置为singleInstance，然后在其他应用中调用。我们编辑ShareActivity的配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">".ShareActivity"</span> <span class="attr">android:launchMode</span>=<span class="string">"singleInstance"</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.MAIN"</span> /&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.LAUNCHER"</span> /&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.SINGLE_INSTANCE_SHARE"</span> /&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.DEFAULT"</span> /&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后我们在其他应用中这样启动该Activity：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent(<span class="string">"android.intent.action.SINGLE_INSTANCE_SHARE"</span>);  </span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure><p>当我们打开ShareActivity后再按后退键回到原来界面时，ShareActivity做为一个独立的个体存在，如果这时我们打开share应用，无需创建新的ShareActivity实例即可看到结果，因为系统会自动查找，存在则直接利用。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Activity的四种launchMode&quot;&gt;&lt;a href=&quot;#Activity的四种launchMode&quot; class=&quot;headerlink&quot; title=&quot;Activity的四种launchMode&quot;&gt;&lt;/a&gt;Activity的四种launchMode&lt;/h3&gt;&lt;p&gt;launchMode在多个Activity跳转的过程中扮演着重要的角色，它可以决定是否生成新的Activity实例，是否重用已存在的Activity实例，是否和其他Activity实例公用一个task里。这里简单介绍一下task的概念，task是一个具有栈结构的对象，一个task可以管理多个Activity，启动一个应用，也就创建一个与之对应的task。&lt;/p&gt;
&lt;p&gt;Activity一共有以下四种launchMode：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;standard&lt;/li&gt;
&lt;li&gt;singleTop&lt;/li&gt;
&lt;li&gt;singleTask&lt;/li&gt;
&lt;li&gt;singleInstance&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我们可以在AndroidManifest.xml配置&lt;activity&gt;的android:launchMode属性为以上四种之一即可。&lt;/activity&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Fragmentation" scheme="http://www.sanmaoliu.com/tags/Fragmentation/"/>
    
      <category term="Fragment" scheme="http://www.sanmaoliu.com/tags/Fragment/"/>
    
  </entry>
  
  <entry>
    <title>Fragmentation的学习1</title>
    <link href="http://www.sanmaoliu.com/2018/05/21/Fragmentation%E7%9A%84%E5%AD%A6%E4%B9%A01/"/>
    <id>http://www.sanmaoliu.com/2018/05/21/Fragmentation的学习1/</id>
    <published>2018-05-21T01:55:15.000Z</published>
    <updated>2018-05-24T01:27:50.000Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>为重度使用Fragment而生</p></li><li><p>提供了方便的管理Fragment的方法</p></li><li><p>有效解决Fragment重叠问题</p></li><li><p>实时查看Fragment的(包括嵌套Fragment)栈视图，方便Fragment嵌套时的调试</p></li><li><p>增加启动模式、startForResult等类似Activity方法</p></li><li><p>修复官方库里pop(tag/id)出栈多个Fragment时的一些BUG</p></li><li><p>完美解决进出栈动画的一些BUG，更自由的管理Fragment的动画</p></li><li><p>支持SwipeBack滑动边缘退出需要使用Fragmentation_SwipeBack库,详情 <a href="https://github.com/YoKeyword/Fragmentation/blob/master/fragmentation_swipeback/README.md?_blank" target="_blank" rel="noopener">README</a></p></li></ol><p><a href="http://www.jianshu.com/p/38f7994faa6b" target="_blank" rel="noopener">原文链接：</a></p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;&lt;p&gt;为重度使用Fragment而生&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;提供了方便的管理Fragment的方法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;有效解决Fragment重叠问题&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;实时查看Fragment的(包括嵌套Fragment)栈视图，方便Fragment嵌套时的调试&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;增加启动模式、startForResult等类似Activity方法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;修复官方库里pop(tag/id)出栈多个Fragment时的一些BUG&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;完美解决进出栈动画的一些BUG，更自由的管理Fragment的动画&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;支持SwipeBack滑动边缘退出需要使用Fragmentation_SwipeBack库,详情 &lt;a href=&quot;https://github.com/YoKeyword/Fragmentation/blob/master/fragmentation_swipeback/README.md?_blank&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;README&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a href=&quot;http://www.jianshu.com/p/38f7994faa6b&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接：&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Fragmentation" scheme="http://www.sanmaoliu.com/tags/Fragmentation/"/>
    
      <category term="Fragment" scheme="http://www.sanmaoliu.com/tags/Fragment/"/>
    
  </entry>
  
  <entry>
    <title>打开Android Studio报错“Error running xxx: Please select Android SDK”</title>
    <link href="http://www.sanmaoliu.com/2018/05/19/%E6%89%93%E5%BC%80Android-Studio%E6%8A%A5%E9%94%99%E2%80%9CError-running-Please-select-Android-SDK%E2%80%9D/"/>
    <id>http://www.sanmaoliu.com/2018/05/19/打开Android-Studio报错“Error-running-Please-select-Android-SDK”/</id>
    <published>2018-05-19T07:15:46.000Z</published>
    <updated>2018-05-19T08:59:24.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>今天打开Android Studio编译项目正常，但在执行Run app的时候莫名其妙弹出配置对话框，一看SDK配置没什么问题，就直接单击“Run”按钮，谁料下面的消息窗口直接提示运行错误“Error running —: Please select Android SDK”<br><a id="more"></a></p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>由于Android Studio异常关闭，使得某些配置文件损坏，因此需要在线更新SDK才能恢复被损坏的文件。解决办法如下：<br>首先依次选择主菜单“File”—&gt;“Settings”<br>上述菜单操作打开设置窗口，然后依次展开“Appearance &amp; Behavior”—&gt;“System Settings”—&gt;“Android SDK”，在右边的设置界面编辑SDK的路径。单击SDK目录输入框右边的“Edit”链接<br><img src="https://coding.net/u/sanmaoliu/p/pictures/git/raw/master/打开Android Studio报错Error running Please select Android SDK.png?raw=true" alt></p><p>单击“Edit”链接之后打开SDK的设置界面如下图所示，这里SDK的目录保持不动，单击页面下方的“Next”按钮，在下一个页面继续单击“Next”按钮，等待Android Studio下载最新的编译工具，下载完成后单击页面右下角的“Finish”按钮完成更新操作。</p><p><img src="https://coding.net/u/sanmaoliu/p/pictures/git/raw/master/打开Android Studio报错Error running Please select Android SDK2.png?raw=true" alt></p><p>回到Android Studio的主界面，此时会自动同步编译工具并重新编译，等待重编完成，即可正常执行Run app的操作了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h4&gt;&lt;p&gt;今天打开Android Studio编译项目正常，但在执行Run app的时候莫名其妙弹出配置对话框，一看SDK配置没什么问题，就直接单击“Run”按钮，谁料下面的消息窗口直接提示运行错误“Error running —: Please select Android SDK”&lt;br&gt;
    
    </summary>
    
    
      <category term="Android Studio" scheme="http://www.sanmaoliu.com/tags/Android-Studio/"/>
    
  </entry>
  
  <entry>
    <title>在Android Studio上使用coding.net做版本管理</title>
    <link href="http://www.sanmaoliu.com/2018/05/19/%E5%9C%A8androidstudio%E4%B8%8A%E4%BD%BF%E7%94%A8coding-net%E5%81%9A%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/"/>
    <id>http://www.sanmaoliu.com/2018/05/19/在androidstudio上使用coding-net做版本管理/</id>
    <published>2018-05-19T03:40:00.000Z</published>
    <updated>2018-05-21T01:43:20.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="在Android-Studio上使用coding-net做版本管理"><a href="#在Android-Studio上使用coding-net做版本管理" class="headerlink" title="在Android Studio上使用coding.net做版本管理"></a>在Android Studio上使用coding.net做版本管理</h3><p>由于国内政策原因，github连接过慢，甚至会上不了。所以我考虑使用一个备用的git版本管理平台，国产出品：coding.net 它的界面做的相对漂亮，功能和github也极尽相似，最重要的是私有库免费，而且国内开发连接速度快，体验流畅。缺点应该是用户数量远小于github吧。</p><p>coding.net仓库分组管理，github上却没有，导致如果有大量项目（仓库）的时候，浏览起来是一个超长超难看的仓库列表，甚至还要搜索才能找到需要浏览的项目。</p><a id="more"></a><ol><li>安装了git软件，并在android studio中配置git软件的路径(git.exe的路径)</li></ol><p><img src="https://coding.net/u/sanmaoliu/p/pictures/git/raw/master/在androidstudio上使用coding.net做版本管理.png?raw=true" alt></p><ol start="2"><li>创建本地的git仓库：creat git responsibility(在VCS-&gt;import into Version Control)</li></ol><p><img src="https://coding.net/u/sanmaoliu/p/pictures/git/raw/master/在androidstudio上使用coding.net做版本管理2.png?raw=true" alt></p><ol start="3"><li>add(添加)所有文件到上面创建的本地git仓库中：在project视图上右键，在git子菜单下的add选项</li></ol><p><img src="https://coding.net/u/sanmaoliu/p/pictures/git/raw/master/在androidstudio上使用coding.net做版本管理3.png?raw=true" alt></p><ol start="4"><li>commit(确认)提交文件的变化：在上面的VCS的向上箭头的(快捷键”Ctrl+K”),即Commit changes</li></ol><p><img src="https://coding.net/u/sanmaoliu/p/pictures/git/raw/master/在androidstudio上使用coding.net做版本管理4.png?raw=true" alt><br>5.在上面弹出的窗口下的commit里有个commit and push选项，选择它确认</p><p><img src="https://coding.net/u/sanmaoliu/p/pictures/git/raw/master/在androidstudio上使用coding.net做版本管理5.png?raw=true" alt></p><ol start="6"><li>输入远程登录的git(https地址)：点击master，在弹出的窗口下输入代码托管项目的git https地址。确认连接到远程代码库。然后cancel返回主界面。(之前连接过了就不需要再次连接)</li><li>先pull 拉下来，再 push 上去。pull的时候可能会出现rejected错误，查看错误窗口原因，修正后即可。（若有多人合作的项目，应在pull后，选择“merge”强行合并文件，“rebase”也是合并，但是它会询问你合并哪些冲突文件）</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;在Android-Studio上使用coding-net做版本管理&quot;&gt;&lt;a href=&quot;#在Android-Studio上使用coding-net做版本管理&quot; class=&quot;headerlink&quot; title=&quot;在Android Studio上使用coding.net做版本管理&quot;&gt;&lt;/a&gt;在Android Studio上使用coding.net做版本管理&lt;/h3&gt;&lt;p&gt;由于国内政策原因，github连接过慢，甚至会上不了。所以我考虑使用一个备用的git版本管理平台，国产出品：coding.net 它的界面做的相对漂亮，功能和github也极尽相似，最重要的是私有库免费，而且国内开发连接速度快，体验流畅。缺点应该是用户数量远小于github吧。&lt;/p&gt;
&lt;p&gt;coding.net仓库分组管理，github上却没有，导致如果有大量项目（仓库）的时候，浏览起来是一个超长超难看的仓库列表，甚至还要搜索才能找到需要浏览的项目。&lt;/p&gt;
    
    </summary>
    
    
      <category term="git" scheme="http://www.sanmaoliu.com/tags/git/"/>
    
      <category term="coding.net" scheme="http://www.sanmaoliu.com/tags/coding-net/"/>
    
      <category term="Android Studio" scheme="http://www.sanmaoliu.com/tags/Android-Studio/"/>
    
  </entry>
  
  <entry>
    <title>使用 Git上传代码到coding.net代码仓库</title>
    <link href="http://www.sanmaoliu.com/2018/05/19/%E4%BD%BF%E7%94%A8-Git%E4%B8%8A%E4%BC%A0%E4%BB%A3%E7%A0%81%E5%88%B0coding-net%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93/"/>
    <id>http://www.sanmaoliu.com/2018/05/19/使用-Git上传代码到coding-net代码仓库/</id>
    <published>2018-05-19T02:48:09.000Z</published>
    <updated>2018-05-19T08:40:38.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="如题使用-Git上传代码到coding-net代码仓库-和ssh更改后重新连接仓库"><a href="#如题使用-Git上传代码到coding-net代码仓库-和ssh更改后重新连接仓库" class="headerlink" title="如题使用 Git上传代码到coding.net代码仓库 和ssh更改后重新连接仓库"></a>如题使用 Git上传代码到coding.net代码仓库 和ssh更改后重新连接仓库</h4><p>Coding.net 建立一个私有的仓库进行代码分支管理，版本控制。本文介绍如何上传下载代码。</p><a id="more"></a><ol><li><p>生成SSH公钥</p><p>不同网站上要有不同的ssh公钥就是执行下句后，重新命名一个公钥名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C &quot;your_email@youemal.com&quot;</span><br></pre></td></tr></table></figure></li><li><p>配置SSH公钥</p><p><img src="https://coding.net/u/sanmaoliu/p/pictures/git/raw/master/coding.net%20add%20ssh%E5%85%AC%E9%92%A5.png?raw=true" alt></p></li><li><p>创建本地代码库</p><p>在WorkSpace下 git init</p></li><li><p>远程代码库克隆</p><p>前提：自行在coding中建立一个项目，空项目即可</p><p>git clone https：//xxxxxx</p></li><li><p>cd 进入这个克隆好的项目中，查看项目是否更改git status</p></li><li><p>git add 文件名 或者 git add .（全部）</p></li><li><p>git commit -m (代码备注随便写)</p></li><li><p>git push origin master</p></li></ol><h4 id="更改ssh公钥重新连接之前的仓库"><a href="#更改ssh公钥重新连接之前的仓库" class="headerlink" title="更改ssh公钥重新连接之前的仓库"></a>更改ssh公钥重新连接之前的仓库</h4><ul><li>重新配置ssh公钥</li><li>ssh-add ~/.ssh/id_rsa   (如果出现Could not open a connection to your authentication agent.)</li><li>则执行ssh-agent bash 然后重新执行上一步，搞定</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;如题使用-Git上传代码到coding-net代码仓库-和ssh更改后重新连接仓库&quot;&gt;&lt;a href=&quot;#如题使用-Git上传代码到coding-net代码仓库-和ssh更改后重新连接仓库&quot; class=&quot;headerlink&quot; title=&quot;如题使用 Git上传代码到coding.net代码仓库 和ssh更改后重新连接仓库&quot;&gt;&lt;/a&gt;如题使用 Git上传代码到coding.net代码仓库 和ssh更改后重新连接仓库&lt;/h4&gt;&lt;p&gt;Coding.net 建立一个私有的仓库进行代码分支管理，版本控制。本文介绍如何上传下载代码。&lt;/p&gt;
    
    </summary>
    
    
      <category term="git" scheme="http://www.sanmaoliu.com/tags/git/"/>
    
      <category term="coding.net" scheme="http://www.sanmaoliu.com/tags/coding-net/"/>
    
  </entry>
  
  <entry>
    <title>RxBus，RxManager with RxJava2</title>
    <link href="http://www.sanmaoliu.com/2018/05/18/RxBus%EF%BC%8CRxManager-with-RxJava2/"/>
    <id>http://www.sanmaoliu.com/2018/05/18/RxBus，RxManager-with-RxJava2/</id>
    <published>2018-05-18T09:45:36.000Z</published>
    <updated>2018-05-18T09:53:48.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>现在查到的关于RxBus, RxManager的封装大部分是基于RxJava1的，从RxJava1到RxJava2的变化很大，很难平滑地过度，所以自己根据RxJava2重新封装下RxBus和RxManager<br><a id="more"></a></p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>RxBus.java</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"><span class="keyword">import</span> io.reactivex.Observable;</span><br><span class="line"><span class="keyword">import</span> io.reactivex.android.schedulers.AndroidSchedulers;</span><br><span class="line"><span class="keyword">import</span> io.reactivex.annotations.NonNull;</span><br><span class="line"><span class="keyword">import</span> io.reactivex.functions.Consumer;</span><br><span class="line"><span class="keyword">import</span> io.reactivex.subjects.PublishSubject;</span><br><span class="line"><span class="keyword">import</span> io.reactivex.subjects.Subject;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RxBus</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">private</span> static RxBus instance;  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">/** </span></span><br><span class="line"><span class="comment">         * ConcurrentHashMap: 线程安全集合 </span></span><br><span class="line"><span class="comment">         *   Subject 同时充当了Observer和Observable的角色 </span></span><br><span class="line"><span class="comment">         */</span>  </span><br><span class="line">        <span class="meta">@SuppressWarnings(<span class="meta-string">"rawtypes"</span>)</span>  </span><br><span class="line">        <span class="keyword">private</span> ConcurrentHashMap&lt;Object, List&lt;Subject&gt;&gt; subjectMapper = new ConcurrentHashMap&lt;&gt;();  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">public</span> static synchronized RxBus getInstance() &#123;  </span><br><span class="line">            <span class="keyword">if</span>(<span class="literal">null</span> == instance) &#123;  </span><br><span class="line">                instance = new RxBus();  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">return</span> instance;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">private</span> RxBus() &#123;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">/** </span></span><br><span class="line"><span class="comment">         * 订阅事件源 </span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> observable </span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> consumer </span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> </span></span><br><span class="line"><span class="comment">         */</span>  </span><br><span class="line">        <span class="keyword">public</span> RxBus onEvent(Observable&lt;?&gt; observable, Consumer&lt;Object&gt; consumer) &#123;  </span><br><span class="line">            observable.observeOn(AndroidSchedulers.mainThread())  </span><br><span class="line">                    .subscribe(consumer, new Consumer&lt;Throwable&gt;() &#123;  </span><br><span class="line">                        <span class="meta">@Override</span>  </span><br><span class="line">                        <span class="keyword">public</span> void accept(Throwable throwable) throws Exception &#123;  </span><br><span class="line">                            throwable.printStackTrace();  </span><br><span class="line">                        &#125;  </span><br><span class="line">                    &#125;);  </span><br><span class="line">            <span class="keyword">return</span> getInstance();  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">/** </span></span><br><span class="line"><span class="comment">         * 注册事件源 </span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> tag key </span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> &lt;T&gt; </span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> </span></span><br><span class="line"><span class="comment">         */</span>  </span><br><span class="line">        <span class="meta">@SuppressWarnings(&#123;<span class="meta-string">"rawtypes"</span>&#125;)</span>  </span><br><span class="line">        <span class="keyword">public</span> &lt;T&gt; Observable&lt;T&gt; register(<span class="meta">@NonNull</span> Object tag) &#123;  </span><br><span class="line">            List&lt;Subject&gt; subjectList = subjectMapper.<span class="keyword">get</span>(tag);  </span><br><span class="line">            <span class="keyword">if</span>(<span class="literal">null</span> == subjectList) &#123;  </span><br><span class="line">                subjectList = new ArrayList&lt;&gt;();  </span><br><span class="line">                subjectMapper.put(tag, subjectList);  </span><br><span class="line">            &#125;  </span><br><span class="line">  </span><br><span class="line">            Subject&lt;T&gt; subject = PublishSubject.create();  </span><br><span class="line">            subjectList.add(subject);  </span><br><span class="line">            <span class="comment">// LogUtil.log("register" + tag + " size:" + subjectList.size());  </span></span><br><span class="line">            <span class="keyword">return</span> subject;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">/** </span></span><br><span class="line"><span class="comment">         * 取消整个tag的监听 </span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> tag key </span></span><br><span class="line"><span class="comment">         */</span>  </span><br><span class="line">        <span class="meta">@SuppressWarnings(<span class="meta-string">"rawtypes"</span>)</span>  </span><br><span class="line">        <span class="keyword">public</span> void unregister(<span class="meta">@NonNull</span> Object tag) &#123;  </span><br><span class="line">            List&lt;Subject&gt; subjectList = subjectMapper.<span class="keyword">get</span>(tag);  </span><br><span class="line">            <span class="keyword">if</span>(<span class="literal">null</span> != subjectList) &#123;  </span><br><span class="line">                subjectMapper.remove(tag);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">/** </span></span><br><span class="line"><span class="comment">         * 取消tag里某个observable的监听 </span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> tag key </span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> observable 要删除的observable </span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> </span></span><br><span class="line"><span class="comment">         */</span>  </span><br><span class="line">        <span class="meta">@SuppressWarnings(<span class="meta-string">"rawtypes"</span>)</span>  </span><br><span class="line">        <span class="keyword">public</span> RxBus unregister(<span class="meta">@NonNull</span> Object tag,  </span><br><span class="line">                                <span class="meta">@NonNull</span> Observable&lt;?&gt; observable) &#123;  </span><br><span class="line">            <span class="keyword">if</span>(<span class="literal">null</span> == observable) &#123;  </span><br><span class="line">                <span class="keyword">return</span> getInstance();  </span><br><span class="line">            &#125;  </span><br><span class="line">  </span><br><span class="line">            List&lt;Subject&gt; subjectList = subjectMapper.<span class="keyword">get</span>(tag);  </span><br><span class="line">            <span class="keyword">if</span>(<span class="literal">null</span> != subjectList) &#123;  </span><br><span class="line">                <span class="comment">// 从subjectList中删去observable  </span></span><br><span class="line">                subjectList.remove((Subject&lt;?&gt;) observable);  </span><br><span class="line">                <span class="comment">// 若此时subjectList为空则从subjectMapper中删去  </span></span><br><span class="line">                <span class="keyword">if</span>(isEmpty(subjectList)) &#123;  </span><br><span class="line">                    subjectMapper.remove(tag);  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">return</span> getInstance();  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">/** </span></span><br><span class="line"><span class="comment">         * 触发事件 </span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> content </span></span><br><span class="line"><span class="comment">         */</span>  </span><br><span class="line">        <span class="keyword">public</span> void post(<span class="meta">@NonNull</span> Object content) &#123;  </span><br><span class="line">            post(content.getClass().getName(), content);  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">/** </span></span><br><span class="line"><span class="comment">         * 触发事件 </span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> tag key </span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> content </span></span><br><span class="line"><span class="comment">         */</span>  </span><br><span class="line">        <span class="meta">@SuppressWarnings(&#123;<span class="meta-string">"unchecked"</span>, <span class="meta-string">"rawtypes"</span>&#125;)</span>  </span><br><span class="line">        <span class="keyword">public</span> void post(<span class="meta">@NonNull</span> Object tag, <span class="meta">@NonNull</span> Object content) &#123;  </span><br><span class="line">            List&lt;Subject&gt; subjectList = subjectMapper.<span class="keyword">get</span>(tag);  </span><br><span class="line">            <span class="keyword">if</span>(!isEmpty(subjectList)) &#123;  </span><br><span class="line">                <span class="keyword">for</span>(Subject subject : subjectList) &#123;  </span><br><span class="line">                    subject.onNext(content);  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">/** </span></span><br><span class="line"><span class="comment">         * 判断集合是否为空 </span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> collection 集合 </span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> </span></span><br><span class="line"><span class="comment">         */</span>  </span><br><span class="line">        <span class="meta">@SuppressWarnings(<span class="meta-string">"rawtypes"</span>)</span>  </span><br><span class="line">        <span class="keyword">public</span> static boolean isEmpty(Collection&lt;Subject&gt; collection) &#123;  </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span> == collection || collection.isEmpty();  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RxManager.java</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> io.reactivex.Observable;</span><br><span class="line"><span class="keyword">import</span> io.reactivex.android.schedulers.AndroidSchedulers;</span><br><span class="line"><span class="keyword">import</span> io.reactivex.disposables.CompositeDisposable;</span><br><span class="line"><span class="keyword">import</span> io.reactivex.disposables.Disposable;</span><br><span class="line"><span class="keyword">import</span> io.reactivex.functions.Consumer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RxManager</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> RxBus mRxBus = RxBus.getInstance();  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 管理观察源 </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Observable&lt;?&gt;&gt; mObservableMap = new HashMap&lt;&gt;();  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 管理订阅者 </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="keyword">private</span> CompositeDisposable mCompositeSubscription = new CompositeDisposable();  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> void on(String eventName, Consumer&lt;Object&gt; consumer) &#123;  </span><br><span class="line">        <span class="comment">// 注册  </span></span><br><span class="line">        Observable&lt;?&gt; mObservable = mRxBus.register(eventName);  </span><br><span class="line">  </span><br><span class="line">        mObservableMap.put(eventName, mObservable);  </span><br><span class="line">  </span><br><span class="line">        mCompositeSubscription  </span><br><span class="line">                .add(mObservable.observeOn(AndroidSchedulers.mainThread())  </span><br><span class="line">                        .subscribe(consumer, new Consumer&lt;Throwable&gt;() &#123;  </span><br><span class="line">                            <span class="meta">@Override</span>  </span><br><span class="line">                            <span class="keyword">public</span> void accept(Throwable throwable) throws Exception &#123;  </span><br><span class="line">                                throwable.printStackTrace();  </span><br><span class="line">                            &#125;  </span><br><span class="line">                        &#125;));  </span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 添加订阅者到mCompositeSubscription </span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> m 要添加的订阅者 </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="keyword">public</span> void add(Disposable m) &#123;  </span><br><span class="line">        mCompositeSubscription.add(m);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 取消所有注册 </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="keyword">public</span> void clear() &#123;  </span><br><span class="line">        <span class="comment">// 取消订阅  </span></span><br><span class="line">        mCompositeSubscription.dispose();  </span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;String, Observable&lt;?&gt;&gt; entry : mObservableMap.entrySet()) &#123;  </span><br><span class="line">            <span class="comment">// 取消注册  </span></span><br><span class="line">            mRxBus.unregister(entry.getKey(), entry.getValue());  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 触发事件 </span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tag </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> content </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="keyword">public</span> void post(Object tag, Object content) &#123;  </span><br><span class="line">        mRxBus.post(tag, content);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h4&gt;&lt;p&gt;现在查到的关于RxBus, RxManager的封装大部分是基于RxJava1的，从RxJava1到RxJava2的变化很大，很难平滑地过度，所以自己根据RxJava2重新封装下RxBus和RxManager&lt;br&gt;
    
    </summary>
    
    
      <category term="RxJava2" scheme="http://www.sanmaoliu.com/tags/RxJava2/"/>
    
  </entry>
  
  <entry>
    <title>杂谈</title>
    <link href="http://www.sanmaoliu.com/2018/05/18/%E6%9D%82%E8%B0%88/"/>
    <id>http://www.sanmaoliu.com/2018/05/18/杂谈/</id>
    <published>2018-05-18T07:36:56.000Z</published>
    <updated>2018-05-18T09:55:44.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="哎"><a href="#哎" class="headerlink" title="哎"></a>哎</h4><p>悔不该没有备份项目，我的CommonApp代码没了。。。。</p><p>真的是打扰了。</p><p>还算是敲响警钟了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;哎&quot;&gt;&lt;a href=&quot;#哎&quot; class=&quot;headerlink&quot; title=&quot;哎&quot;&gt;&lt;/a&gt;哎&lt;/h4&gt;&lt;p&gt;悔不该没有备份项目，我的CommonApp代码没了。。。。&lt;/p&gt;
&lt;p&gt;真的是打扰了。&lt;/p&gt;
&lt;p&gt;还算是敲响警钟了&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="diray" scheme="http://www.sanmaoliu.com/tags/diray/"/>
    
  </entry>
  
  <entry>
    <title>Gradle问题总结</title>
    <link href="http://www.sanmaoliu.com/2018/05/17/Gradle%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <id>http://www.sanmaoliu.com/2018/05/17/Gradle问题总结/</id>
    <published>2018-05-17T13:41:56.000Z</published>
    <updated>2018-05-19T08:02:08.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>Error:Could not run build action using Gradle installation D:\AndroidStudio\AS\gradle\gradle-3.3<br><a id="more"></a></p><h4 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h4><p>利用AndroidStudio内置的清理工具清理</p><ol><li><p>File -&gt; Invalidate caches / Restart </p><p><img src="https://coding.net/u/sanmaoliu/p/pictures/git/raw/master/gradle问题.png" alt></p><p>​</p></li><li><p>Invalidate and Restart</p><p><img src="https://coding.net/u/sanmaoliu/p/pictures/git/raw/master/gradle问题2.png" alt></p><p>​</p></li></ol><p>点击后会自动清理并且重启studio。</p><p>注意：一定要保持gradle-wrapper.properties下distributionUrl=<a href="https://services.gradle.org/distributions/gradle-3.3-all.zip" target="_blank" rel="noopener">https://services.gradle.org/distributions/gradle-3.3-all.zip</a>和本地gradle版本一致。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h4&gt;&lt;p&gt;Error:Could not run build action using Gradle installation D:\AndroidStudio\AS\gradle\gradle-3.3&lt;br&gt;
    
    </summary>
    
    
      <category term="Gradle" scheme="http://www.sanmaoliu.com/tags/Gradle/"/>
    
  </entry>
  
  <entry>
    <title>设计模式：简介</title>
    <link href="http://www.sanmaoliu.com/2018/05/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9A%E7%AE%80%E4%BB%8B/"/>
    <id>http://www.sanmaoliu.com/2018/05/15/设计模式：简介/</id>
    <published>2018-05-15T03:48:02.000Z</published>
    <updated>2018-05-15T03:55:20.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="设计模式的介绍"><a href="#设计模式的介绍" class="headerlink" title="设计模式的介绍"></a>设计模式的介绍</h4><p>设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。</p><p>设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。项目中合理地运用设计模式可以完美地解决很多问题，每种模式在现实中都有相应的原理来与之对应，每种模式都描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是设计模式能被广泛应用的原因。</p><a id="more"></a><h4 id="设计模式的使用"><a href="#设计模式的使用" class="headerlink" title="设计模式的使用"></a>设计模式的使用</h4><p>设计模式在软件开发中的两个主要用途。</p><h5 id="开发人员的共同平台"><a href="#开发人员的共同平台" class="headerlink" title="开发人员的共同平台"></a>开发人员的共同平台</h5><p>设计模式提供了一个标准的术语系统，且具体到特定的情景。例如，单例设计模式意味着使用单个对象，这样所有熟悉单例设计模式的开发人员都能使用单个对象，并且可以通过这种方式告诉对方，程序使用的是单例模式。</p><h5 id="最佳的实践"><a href="#最佳的实践" class="headerlink" title="最佳的实践"></a>最佳的实践</h5><p>设计模式已经经历了很长一段时间的发展，它们提供了软件开发过程中面临的一般问题的最佳解决方案。学习这些模式有助于经验不足的开发人员通过一种简单快捷的方式来学习软件设计。</p><h4 id="设计模式的类型"><a href="#设计模式的类型" class="headerlink" title="设计模式的类型"></a>设计模式的类型</h4><p>根据设计模式的参考书 Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式 - 可复用的面向对象软件元素） 中所提到的，总共有 23 种设计模式。这些模式可以分为三大类：创建型模式（Creational Patterns）、结构型模式（Structural Patterns）、行为型模式（Behavioral Patterns）。当然，我们还会讨论另一类设计模式：J2EE 设计模式。</p><table><thead><tr><th>序号</th><th>模式 &amp; 描述</th><th>包括</th></tr></thead><tbody><tr><td>1</td><td><strong>创建型模式</strong>这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。</td><td>工厂模式（Factory Pattern）抽象工厂模式（Abstract Factory Pattern）单例模式（Singleton Pattern）建造者模式（Builder Pattern）原型模式（Prototype Pattern）</td></tr><tr><td>2</td><td><strong>结构型模式</strong>这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。</td><td>适配器模式（Adapter Pattern）桥接模式（Bridge Pattern）过滤器模式（Filter、Criteria Pattern）组合模式（Composite Pattern）装饰器模式（Decorator Pattern）外观模式（Facade Pattern）享元模式（Flyweight Pattern）代理模式（Proxy Pattern）</td></tr><tr><td>3</td><td><strong>行为型模式</strong>这些设计模式特别关注对象之间的通信。</td><td>责任链模式（Chain of Responsibility Pattern）命令模式（Command Pattern）解释器模式（Interpreter Pattern）迭代器模式（Iterator Pattern）中介者模式（Mediator Pattern）备忘录模式（Memento Pattern）观察者模式（Observer Pattern）状态模式（State Pattern）空对象模式（Null Object Pattern）策略模式（Strategy Pattern）模板模式（Template Pattern）访问者模式（Visitor Pattern）</td></tr><tr><td>4</td><td><strong>J2EE 模式</strong>这些设计模式特别关注表示层。这些模式是由 Sun Java Center 鉴定的。</td><td>MVC 模式（MVC Pattern）业务代表模式（Business Delegate Pattern）组合实体模式（Composite Entity Pattern）数据访问对象模式（Data Access Object Pattern）前端控制器模式（Front Controller Pattern）拦截过滤器模式（Intercepting Filter Pattern）服务定位器模式（Service Locator Pattern）传输对象模式（Transfer Object Pattern）</td></tr></tbody></table><h4 id="设计模式的六大原则"><a href="#设计模式的六大原则" class="headerlink" title="设计模式的六大原则"></a>设计模式的六大原则</h4><p><strong>1、开闭原则（Open Close Principle）</strong></p><p>开闭原则的意思是：<strong>对扩展开放，对修改关闭</strong>。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。</p><p><strong>2、里氏代换原则（Liskov Substitution Principle）</strong></p><p>里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。</p><p><strong>3、依赖倒转原则（Dependence Inversion Principle）</strong></p><p>这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。</p><p><strong>4、接口隔离原则（Interface Segregation Principle）</strong></p><p>这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。</p><p><strong>5、迪米特法则，又称最少知道原则（Demeter Principle）</strong></p><p>最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。</p><p><strong>6、合成复用原则（Composite Reuse Principle）</strong></p><p>合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;设计模式的介绍&quot;&gt;&lt;a href=&quot;#设计模式的介绍&quot; class=&quot;headerlink&quot; title=&quot;设计模式的介绍&quot;&gt;&lt;/a&gt;设计模式的介绍&lt;/h4&gt;&lt;p&gt;设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。&lt;/p&gt;
&lt;p&gt;设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。项目中合理地运用设计模式可以完美地解决很多问题，每种模式在现实中都有相应的原理来与之对应，每种模式都描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是设计模式能被广泛应用的原因。&lt;/p&gt;
    
    </summary>
    
    
      <category term="design patterns" scheme="http://www.sanmaoliu.com/tags/design-patterns/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin Learning(6章)</title>
    <link href="http://www.sanmaoliu.com/2018/05/14/Kotlin-Learning5/"/>
    <id>http://www.sanmaoliu.com/2018/05/14/Kotlin-Learning5/</id>
    <published>2018-05-14T07:17:09.000Z</published>
    <updated>2018-05-14T08:25:44.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><ol><li>多重申明</li><li>Ranges</li><li>类型检查和自动转换</li><li>This表达式</li><li>等式</li><li>运算符重载</li><li>空安全</li><li>异常</li><li>注解</li><li>反射</li><li>动态类型</li></ol><a id="more"></a><h4 id="多重声明"><a href="#多重声明" class="headerlink" title="多重声明"></a>多重声明</h4><p>有时候可以通过给对象插入多个成员函数做区别是很方便的，比如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> (name, age) = person</span><br></pre></td></tr></table></figure><p>这种语法叫多重声明。多重声明一次创建了多个变量。我们声明了俩个新变量： name age 并且可以独立使用：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">println(name)</span><br><span class="line">println(age)</span><br></pre></td></tr></table></figure><p>多重声明被编译成下面的代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> name = persion.component1()</span><br><span class="line"><span class="keyword">val</span> age = persion.component2()</span><br></pre></td></tr></table></figure><p>component1() component2() 是另一个转换原则的例子。任何类型都可以在多重分配的右边。当然了，也可以有 component3() component4() 等等 </p><p>多重声明也可以在 for 循环中用</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ((a, b) <span class="keyword">in</span> collection) &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>参数 a 和 b 是 component1() component2() 的返回值</p><h5 id="例子：一个函数返回俩个值"><a href="#例子：一个函数返回俩个值" class="headerlink" title="例子：一个函数返回俩个值"></a>例子：一个函数返回俩个值</h5><p>要是一个函数想返回俩个值。比如，一个对象结果，一个是排序的状态。在 Kotlin中的一个紧凑的方案是声明 data 类并返回实例：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Result</span></span>(<span class="keyword">val</span> result: <span class="built_in">Int</span>, <span class="keyword">val</span> status: Status)</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">function</span><span class="params">(...)</span></span>: Result &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> Result(result, status)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">val</span> (result, status) = function(...)</span><br></pre></td></tr></table></figure><p>数据类自动声明 componentN() 函数<br>注意：也可以使用标准类 Pair 并让函数返回 ‘Pair’，但可读性不是很强</p><h5 id="例子：多重声明和-Map"><a href="#例子：多重声明和-Map" class="headerlink" title="例子：多重声明和 Map"></a>例子：多重声明和 Map</h5><p>转换 map 的最好办法可能是下面这样：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ((key, value) <span class="keyword">in</span> map) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了让这个可以工作，我们需要</p><blockquote><p>通过提供 iterator() 函数序列化呈现 map 通过 component1() 和component1() 函数是把元素成对呈现</p></blockquote><p>事实上，标准库提供了这样的扩展：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;K, V&gt;</span> Map<span class="type">&lt;K, V&gt;</span>.<span class="title">iterator</span><span class="params">()</span></span>: Iterator&lt;Map.Entry&lt;K, V&gt;&gt; = ent</span><br><span class="line">rySet().iterator()</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;K, V&gt;</span> Map.Entry<span class="type">&lt;K, V&gt;</span>.<span class="title">component1</span><span class="params">()</span></span> = getKey()</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;K, V&gt;</span> Map.Entry<span class="type">&lt;K, V&gt;</span>.<span class="title">component2</span><span class="params">()</span></span> = getValue()</span><br></pre></td></tr></table></figure><p>因此你可以用 for 循环方便的读取 map (或者其它数据集合)</p><h4 id="Ranges"><a href="#Ranges" class="headerlink" title="Ranges"></a>Ranges</h4><p>range 表达式拥有 rangeTo 函数操作符是 .. 。 Range 可以对任何可比较的类型做操作，但对很多原语是优化过的。下面是些例子：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (i <span class="keyword">in</span> <span class="number">1</span>..<span class="number">10</span>) &#123;</span><br><span class="line">println(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (x !<span class="keyword">in</span> <span class="number">1.0</span>..<span class="number">3.0</span>) println(x)</span><br><span class="line"><span class="keyword">if</span> (str <span class="keyword">in</span> <span class="string">"island"</span>..<span class="string">"isle"</span>) println(str)</span><br></pre></td></tr></table></figure><p>数字的范围有个附加的特性：它们可以迭代。编译器会把它转成类似于 java 的 for循环的形式，且不用担心越界：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span>..<span class="number">4</span>) print(i) <span class="comment">// prints "1234"</span></span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">4</span>..<span class="number">1</span>) print(i) <span class="comment">// prints nothing</span></span><br><span class="line"><span class="keyword">for</span> (x <span class="keyword">in</span> <span class="number">1.0</span>..<span class="number">2.0</span>) print(<span class="string">"<span class="variable">$x</span> "</span>) <span class="comment">// prints "1.0 2.0 "</span></span><br></pre></td></tr></table></figure><p>如果你想迭代数字并想反过来，这个相当简单，你可以使用 downTo() 函数</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">4</span> downTo <span class="number">1</span>) print(i)</span><br></pre></td></tr></table></figure><p>也可以使用指定步数的迭代，这个用到 step()</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span>..<span class="number">4</span> step <span class="number">2</span>) print(i) <span class="comment">// prints "13"</span></span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">4</span> downTo <span class="number">1</span> step <span class="number">2</span>) print(i) <span class="comment">// prints "42"</span></span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.0</span>..<span class="number">2.0</span> step <span class="number">0.3</span>) print(<span class="string">"<span class="variable">$i</span> "</span>) <span class="comment">// prints "1.0 1.3 1.6 1.9 "</span></span><br></pre></td></tr></table></figure><h5 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h5><p>在标准库中有俩种接口：Range 和 Progression<br>Range 表示数学范围上的一个间隔。它有俩个端点：start 和 end 。主要的操作符是 contains 通常在 in/!in 操作符内：<br>Progression 表示一个算数级数。它有一个 start 和 end 以及一个非零 increment 。Progression 是Iterable 的一个子类，因此可以使用在 for 循环中，或者 map filter等等。第一个元素是 start 下一个元素都是前一个元素的 increment。 Progression 的迭代与 java/javaScript 的 for 循环相同：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// if increment &gt; 0</span></span><br><span class="line"><span class="keyword">for</span> (int i = start; i &lt;= end; i += increment) &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// if increment &lt; 0</span></span><br><span class="line"><span class="keyword">for</span> (int i = start; i &gt;= end; i += increment) &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="范围指标"><a href="#范围指标" class="headerlink" title="范围指标"></a>范围指标</h5><p>使用例子：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Checking if value of comparable is in range. Optimized for number primitives.</span></span><br><span class="line"><span class="keyword">if</span> (i <span class="keyword">in</span> <span class="number">1</span>..<span class="number">10</span>) println(i)</span><br><span class="line"><span class="keyword">if</span> (x <span class="keyword">in</span> <span class="number">1.0</span>..<span class="number">3.0</span>) println(x)</span><br><span class="line"><span class="keyword">if</span> (str <span class="keyword">in</span> <span class="string">"island"</span>..<span class="string">"isle"</span>) println(str)</span><br><span class="line"><span class="comment">// Iterating over arithmetical progression of numbers. Optimized for number primitives (as indexed for-loop in Java).</span></span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span>..<span class="number">4</span>) print(i) <span class="comment">// prints "1234"</span></span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">4</span>..<span class="number">1</span>) print(i) <span class="comment">// prints nothing</span></span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">4</span> downTo <span class="number">1</span>) print(i) <span class="comment">// prints "4321"</span></span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span>..<span class="number">4</span> step <span class="number">2</span>) print(i) <span class="comment">// prints "13"</span></span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> (<span class="number">1</span>..<span class="number">4</span>).reversed()) print(i) <span class="comment">// prints "4321"</span></span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> (<span class="number">1</span>..<span class="number">4</span>).reversed() step <span class="number">2</span>) print(i) <span class="comment">// prints "42"</span></span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">4</span> downTo <span class="number">1</span> step <span class="number">2</span>) print(i) <span class="comment">// prints "42"</span></span><br><span class="line"><span class="keyword">for</span> (x <span class="keyword">in</span> <span class="number">1.0</span>..<span class="number">2.0</span>) print(<span class="string">"<span class="variable">$x</span> "</span>) <span class="comment">// prints "1.0 2.0 "</span></span><br><span class="line"><span class="keyword">for</span> (x <span class="keyword">in</span> <span class="number">1.0</span>..<span class="number">2.0</span> step <span class="number">0.3</span>) print(<span class="string">"<span class="variable">$x</span> "</span>) <span class="comment">// prints "1.0 1.3 1.6 1.9 "</span></span><br><span class="line"><span class="keyword">for</span> (x <span class="keyword">in</span> <span class="number">2.0</span> downTo <span class="number">1.0</span> step <span class="number">0.3</span>) print(<span class="string">"<span class="variable">$x</span> "</span>) <span class="comment">// prints "2.0 1.7 1.4 1.1 "</span></span><br><span class="line"><span class="keyword">for</span> (str <span class="keyword">in</span> <span class="string">"island"</span>..<span class="string">"isle"</span>) println(str) <span class="comment">// error: string range cannot be iterated over</span></span><br></pre></td></tr></table></figure><h5 id="常见的接口的定义"><a href="#常见的接口的定义" class="headerlink" title="常见的接口的定义"></a>常见的接口的定义</h5><p>有俩种基本接口： Range Progression</p><p>Range 接口定义了一个范围，或者是数学意义上的一个间隔。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Range</span>&lt;<span class="type">T : Comparable&lt;T</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">val</span> start: T</span><br><span class="line">    <span class="keyword">val</span> end: T</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">contains</span><span class="params">(Element : <span class="type">T</span>)</span></span>: <span class="built_in">Boolean</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Progression 定义了数学上的级数。包括 start end increment 端点。最大的特点就是它可以迭代，因此它是 Iterable 的子类。end 不是必须的。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Progression</span>&lt;<span class="type">N : Number</span>&gt; : <span class="type">Iterable</span>&lt;<span class="type">N</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">val</span> start : N</span><br><span class="line">    <span class="keyword">val</span> end : N</span><br><span class="line">    <span class="keyword">val</span> increment : Number</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与 java 的 for 循环类似：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// if increment &gt; 0</span></span><br><span class="line"><span class="keyword">for</span> (int i = start; i &lt;= end; i += increment) &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// if increment &lt; 0</span></span><br><span class="line"><span class="keyword">for</span> (int i = start; i &gt;= end; i += increment) &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="类的实现"><a href="#类的实现" class="headerlink" title="类的实现"></a>类的实现</h5><p>为避免不需要的重复，让我们先考虑一个数字类型 Int 。其它的数字类型也一样。注意这些类的实例需要用相应的构造函数来创建，使用 rangeTo() downTo()reversed() stop() 实用函数。<br>IntProgression 类很直接也很简单：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntProgression</span></span>(<span class="keyword">override</span> <span class="keyword">val</span> start: <span class="built_in">Int</span>, <span class="keyword">override</span> <span class="keyword">val</span> end: <span class="built_in">Int</span>, <span class="keyword">override</span> <span class="keyword">val</span> increment: <span class="built_in">Int</span> ): Progression&lt;<span class="built_in">Int</span>&gt; &#123;</span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">iterator</span><span class="params">()</span></span>: Iterator&lt;<span class="built_in">Int</span>&gt; = IntProgressionIteratorImpl(start, end, increment)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>IntRange 有些狡猾：它实现了 Progression Range 接口，因为它天生以通过 range 迭代(默认增加值是 1 )：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntRange</span></span>(<span class="keyword">override</span> <span class="keyword">val</span> start: <span class="built_in">Int</span>, <span class="keyword">override</span> <span class="keyword">val</span> end: <span class="built_in">Int</span>): Range&lt;<span class="built_in">Int</span>&gt;, Progression&lt;<span class="built_in">Int</span>&gt; &#123;</span><br><span class="line"><span class="keyword">override</span> <span class="keyword">val</span> increment: <span class="built_in">Int</span></span><br><span class="line"><span class="keyword">get</span>() = <span class="number">1</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">contains</span><span class="params">(element: <span class="type">Int</span>)</span></span>: <span class="built_in">Boolean</span> = start &lt;= element &amp;&amp; element &lt;= end</span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">iterator</span><span class="params">()</span></span>: Iterator&lt;<span class="built_in">Int</span>&gt; = IntProgressionIteratorImpl(start, end, increment)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ComparableRange 也很简单：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ComparableRange</span>&lt;<span class="type">T : Comparable&lt;T</span>&gt;&gt;</span>(<span class="keyword">override</span> <span class="keyword">val</span> start: T, <span class="keyword">override</span> <span class="keyword">val</span> end: T): Range&lt;T&gt; &#123;</span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">contains</span><span class="params">(element: <span class="type">T</span>)</span></span>: <span class="built_in">Boolean</span> = start &lt;= element &amp;&amp; element &lt;= end</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="一些实用的函数"><a href="#一些实用的函数" class="headerlink" title="一些实用的函数"></a>一些实用的函数</h5><p>rangeTo()<br>rangeTo() 函数仅仅是调用 *Range 的构造函数，比如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Int</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">rangeTo</span><span class="params">(other: <span class="type">Byte</span>)</span></span>: IntRange = IntRange(<span class="keyword">this</span>, Other)</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">rangeTo</span><span class="params">(other: <span class="type">Int</span>)</span></span>: IntRange = IntRange(<span class="keyword">this</span>, other)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>downTo()<br>downTo() 扩展函数可以为任何数字类型定义，这里有俩个例子：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="built_in">Long</span>.<span class="title">downTo</span><span class="params">(other: <span class="type">Double</span>)</span></span>: DoubleProgression &#123;</span><br><span class="line"><span class="keyword">return</span> DoubleProgression(<span class="keyword">this</span>, other, -<span class="number">1.0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="built_in">Byte</span>.<span class="title">downTo</span><span class="params">(other: <span class="type">Int</span>)</span></span>: IntProgression &#123;</span><br><span class="line"><span class="keyword">return</span> IntProgression(<span class="keyword">this</span>, other, -<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>reversed()<br>reversed() 扩展函数是给所有的 <em>Range 和 </em>Progression 类定义的，并且它们都返回反向的级数。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> IntProgression.<span class="title">reversed</span><span class="params">()</span></span>: IntProgression &#123;</span><br><span class="line"><span class="keyword">return</span> IntProgression(end, start, -increment)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> IntRange.<span class="title">reversed</span><span class="params">()</span></span>: IntProgression &#123;</span><br><span class="line"><span class="keyword">return</span> IntProgression(end, start, -<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>step()<br>step() 扩展函数是给所有的 <em>Range 和 </em>Progression 类定义的，所有的返回级数都修改了 setp 值。注意 step 值总是正的，否则函数不会改变迭代的方向。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> IntProgression.<span class="title">step</span><span class="params">(step: <span class="type">Int</span>)</span></span>: IntProgression &#123;</span><br><span class="line">    <span class="keyword">if</span> (step &lt;= <span class="number">0</span>) <span class="keyword">throw</span> IllegalArgumentException(<span class="string">"Step must be positive, was: <span class="variable">$step</span>"</span>)</span><br><span class="line">        <span class="keyword">return</span> IntProgression(start, end, <span class="keyword">if</span> (increment &gt; <span class="number">0</span>) step <span class="keyword">else</span> -step)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> IntRange.<span class="title">step</span><span class="params">(step: <span class="type">Int</span>)</span></span>: IntProgression &#123;</span><br><span class="line">    <span class="keyword">if</span> (step &lt;= <span class="number">0</span>) <span class="keyword">throw</span> IllegalArgumentException(<span class="string">"Step must be positive, was: <span class="variable">$step</span>"</span>)</span><br><span class="line">        <span class="keyword">return</span> IntProgression(start, end, step)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="类型检查和转换"><a href="#类型检查和转换" class="headerlink" title="类型检查和转换"></a>类型检查和转换</h4><h5 id="is-is-表达式"><a href="#is-is-表达式" class="headerlink" title="is !is 表达式"></a>is !is 表达式</h5><p>我们可以在运行是通过上面俩个操作符检查一个对象是否是某个特定类：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (obj <span class="keyword">is</span> String) &#123;</span><br><span class="line">print(obj.length)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (obj !<span class="keyword">is</span> String) &#123; <span class="comment">// same as !(obj is String)</span></span><br><span class="line">print(<span class="string">"Not a String"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">print(obj.length)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="智能转换"><a href="#智能转换" class="headerlink" title="智能转换"></a>智能转换</h5><p>在很多情形中，需要使用非明确的类型，因为编译器会跟踪 is 检查静态变量，并在需要的时候自动插入安全转换：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">demo</span><span class="params">(x: <span class="type">Any</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (x <span class="keyword">is</span> String) &#123;</span><br><span class="line">    print(x.length) <span class="comment">// x is automatically cast to String</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器足够智能如何转换是安全的，如果不安全将会返回：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x !<span class="keyword">is</span> String) <span class="keyword">return</span></span><br><span class="line">print(x.length) <span class="comment">//x 自动转换为 String</span></span><br></pre></td></tr></table></figure><p>或者在 || &amp;&amp; 操作符的右边的值</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// x is automatically cast to string on the right-hand side of`||`</span></span><br><span class="line"><span class="keyword">if</span> (x !<span class="keyword">is</span> String || x.length == <span class="number">0</span>) <span class="keyword">return</span></span><br><span class="line"><span class="comment">// x is automatically cast to string on the right-hand side of`&amp;&amp;`</span></span><br><span class="line"><span class="keyword">if</span> (x <span class="keyword">is</span> String &amp;&amp; x.length &gt; <span class="number">0</span>)</span><br><span class="line">print(x.length) <span class="comment">// x is automatically cast to String</span></span><br></pre></td></tr></table></figure><p>这样的转换在 when 表达式和 whie 循环中也会发生</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">when</span> (x) &#123;</span><br><span class="line">    <span class="keyword">is</span> <span class="built_in">Int</span> -&gt; print(x + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">is</span> String -&gt; print(x.length + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">is</span> Array&lt;<span class="built_in">Int</span>&gt; -&gt; print(x.sum())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="“不安全”的转换符"><a href="#“不安全”的转换符" class="headerlink" title="“不安全”的转换符"></a>“不安全”的转换符</h5><p>和 如果转换是不被允许的那么转换符就会抛出一个异常。因此我们称之为不安全的。在kotlin 中 我们用前缀 as 操作符</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> x: String = y <span class="keyword">as</span> String</span><br></pre></td></tr></table></figure><p>注意 null 不能被转换为 String 因为它不是 nullable ，也就是说如果 y 是空的，则上面的代码会抛出空异常。<br>为了 java 的转换语句匹配我们得像下面这样：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> x: String?= y <span class="keyword">as</span> String?</span><br></pre></td></tr></table></figure><h5 id="“安全”转换符"><a href="#“安全”转换符" class="headerlink" title="“安全”转换符"></a>“安全”转换符</h5><p>为了避免抛出异常，可以用 as? 这个安全转换符，这样失败就会返回 null ：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> x: String ?= y <span class="keyword">as</span>? String</span><br></pre></td></tr></table></figure><p>不管 as? 右边的是不是一个非空 String 结果都会转换为可空的。</p><h4 id="This-表达式"><a href="#This-表达式" class="headerlink" title="This 表达式"></a>This 表达式</h4><p>为了记录下当前接受者，我们使用 this 表达式：</p><blockquote><p>在类的成员中，this 表示当前类的对象<br>在扩展函数或扩展字面函数中，this 表示 . 左边接收者参数</p></blockquote><p>如果 this 没有应用者，则指向的是最内层的闭合范围。为了在其它范围中返回 this，需要使用标签</p><h5 id="this使用范围"><a href="#this使用范围" class="headerlink" title="this使用范围"></a>this使用范围</h5><p>为了在范围外部(一个类，或者表达式函数，或者带标签的扩展字面函数)访问 this，我们需要在使用 this@lable 作为 lable</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123; <span class="comment">// implicit label @A</span></span><br><span class="line">    <span class="keyword">inner</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123; <span class="comment">// implicit label @B</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="built_in">Int</span>.<span class="title">foo</span><span class="params">()</span></span> &#123; <span class="comment">// implicit label @foo</span></span><br><span class="line">            <span class="keyword">val</span> a = <span class="keyword">this</span><span class="symbol">@A</span> <span class="comment">// A's this</span></span><br><span class="line">            <span class="keyword">val</span> b = <span class="keyword">this</span><span class="symbol">@B</span> <span class="comment">// B's this</span></span><br><span class="line">            <span class="keyword">val</span> c = <span class="keyword">this</span> <span class="comment">// foo()'s receiver, an Int</span></span><br><span class="line">            <span class="keyword">val</span> c1 = <span class="keyword">this</span><span class="symbol">@foo</span> <span class="comment">// foo()'s receiver, an Int</span></span><br><span class="line">            <span class="keyword">val</span> funLit = <span class="meta">@lambda</span> &#123; String.() -&gt;</span><br><span class="line">                <span class="keyword">val</span> d = <span class="keyword">this</span> <span class="comment">// funLit's receiver</span></span><br><span class="line">                <span class="keyword">val</span> d1 = <span class="keyword">this</span><span class="symbol">@lambda</span> <span class="comment">// funLit's receiver</span></span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">val</span> funLit2 = &#123; (s: String) -&gt;</span><br><span class="line">            <span class="comment">// foo()'s receiver, since enclosing function literal</span></span><br><span class="line">            <span class="comment">// doesn't have any receiver</span></span><br><span class="line">            <span class="keyword">val</span> d1 = <span class="keyword">this</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="等式"><a href="#等式" class="headerlink" title="等式"></a>等式</h4><p>在 kotlin 中有俩中相等：</p><blockquote><p>参照相等(指向相同的对象) 结构相等</p></blockquote><h5 id="参照相等"><a href="#参照相等" class="headerlink" title="参照相等"></a>参照相等</h5><p>参照相等是通过 === 操作符判断的(不等是 !== ) a===b 只有 a b 指向同一个对象是判别才成立。<br>另外，你可以使用内联函数 identityEquals() 判断参照相等：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a.identityEquals(b)</span><br><span class="line">a identityEquals b</span><br></pre></td></tr></table></figure><h5 id="结构相等"><a href="#结构相等" class="headerlink" title="结构相等"></a>结构相等</h5><p>结构相等是通过 == 判断的。像 a == b 将会翻译成：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a?.equals(b) ?: b === <span class="literal">null</span></span><br></pre></td></tr></table></figure><p>如果 a 不是 null 则调用 equals(Any?) 函数，否则检查 b 是否参照等于 null<br>注意完全没有必要为优化你的代码而将 a == null 写成 a === null 编译器会自动帮你做的。</p><h4 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h4><p>Kotlin 允许我们实现一些我们自定义类型的运算符实现。这些运算符有固定的表示，和固定的优先级。为实现这样的运算符，我们提供了固定名字的数字函数和扩展函数，比如二元运算符的左值和一元运算符的参数类型。</p><h5 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h5><p>这里我们描述了一些常用运算符的重载</p><h5 id="一元运算符"><a href="#一元运算符" class="headerlink" title="一元运算符"></a>一元运算符</h5><table><thead><tr><th>表达式</th><th style="text-align:center">转换</th></tr></thead><tbody><tr><td>+a</td><td style="text-align:center">a.plus()</td></tr><tr><td>-a</td><td style="text-align:center">a.minus()</td></tr><tr><td>!a</td><td style="text-align:center">a.not()</td></tr></tbody></table><p>这张表解释了当编译器运行时，比如，表达式 +a ，是这样运行的：</p><blockquote><p>决定 a 的类型，假设是 T 寻找接收者是 T 的无参函数 plus() ，比如数字函数或者扩展函数 如果这样的函数缺失或不明确，则返回错误。 如果函数是当前函数或返回类型是 R 则表达式 +a 是 R 类型。</p></blockquote><p>注意这些操作符和其它的一样，都被优化为基本类型并且不会产生多余的开销。<br>| 表达式 | 转换 |<br>| - | :-: |<br>| a++ |  a.inc() + see below |<br>| a– |  a.des() + see below |</p><p>这些操作符允许修改接收者和返回类型。</p><blockquote><p>inc()/dec() shouldn’t mutate the receiver object.<br>By “changing the receiver” we mean the receiver-variable, not the receiver object.</p></blockquote><p>编译器是这样解决有后缀的操作符的比如 a++ :</p><blockquote><p>决定 a 的类型，假设是 T 寻找无参函数 inc() ，作用在接收者T 如果返回类型是 R ，则必须是 T 的子类</p></blockquote><p>计算表达式的效果是：</p><blockquote><p>把 a 的初始值存储在 a0 中 把 a.inc() 的结果作用在 a 上 把 a0 作为表达式的返回值</p></blockquote><p>a– 的步骤也是一样的<br>++a –a 的解决方式也是一样的</p><h5 id="二元操作符"><a href="#二元操作符" class="headerlink" title="二元操作符"></a>二元操作符</h5><table><thead><tr><th>表达式</th><th style="text-align:center">转换</th></tr></thead><tbody><tr><td>a + b</td><td style="text-align:center">a.plus(b)</td></tr><tr><td>a - b</td><td style="text-align:center">a.minus(b)</td></tr><tr><td>a * b</td><td style="text-align:center">a.times(b)</td></tr><tr><td>a / b</td><td style="text-align:center">a.div(b)</td></tr><tr><td>a % b</td><td style="text-align:center">a.mod(b)</td></tr><tr><td>a..b</td><td style="text-align:center">a.rangeTo(b)</td></tr></tbody></table><p>编译器只是解决了该表中翻译为列的表达式</p><table><thead><tr><th>表达式</th><th style="text-align:center">转换</th></tr></thead><tbody><tr><td>a in b</td><td style="text-align:center">b.contains(a)</td></tr><tr><td>a !in b</td><td style="text-align:center">!b.contains(a)</td></tr></tbody></table><p>in 和 !in 的产生步骤是一样的，但参数顺序是相反的。</p><table><thead><tr><th>标志</th><th style="text-align:center">转换</th></tr></thead><tbody><tr><td>a[i]</td><td style="text-align:center">a.get(i)</td></tr><tr><td>a[i, j]</td><td style="text-align:center">a.get(i, j)</td></tr><tr><td>a[i_1, …, i_n]</td><td style="text-align:center">a.get(i_1, … , i_n)</td></tr><tr><td>a[i] = b</td><td style="text-align:center">a.set(i, b)</td></tr><tr><td>a[i,j] =b</td><td style="text-align:center">a.set(i, j, b)</td></tr><tr><td>a[i_1, … , i_n] = b</td><td style="text-align:center">a.set(i_1,… ,o_n,b)</td></tr></tbody></table><p>方括号被转换为 get set 函数</p><table><thead><tr><th>表达式</th><th style="text-align:center">转换</th></tr></thead><tbody><tr><td>a(i)</td><td style="text-align:center">a.invoke(i)</td></tr><tr><td>a(i, j)</td><td style="text-align:center">a.invoke(i, j)</td></tr><tr><td>a(i_1, … , i_n)</td><td style="text-align:center">a.invoke(i_1, …, i_n)</td></tr></tbody></table><p>括号被转换为带有正确参数的 invoke 参数</p><table><thead><tr><th>表达式</th><th style="text-align:center">转换</th></tr></thead><tbody><tr><td>a += b</td><td style="text-align:center">a.plusAssign(b)</td></tr><tr><td>a -= b</td><td style="text-align:center">a.minusAssign(b)</td></tr><tr><td>a *= b</td><td style="text-align:center">a.timesAssign(b)</td></tr><tr><td>a /= b</td><td style="text-align:center">a.divAssign(b)</td></tr><tr><td>a %= b</td><td style="text-align:center">a.modAssign(b)</td></tr></tbody></table><p>在分配 a+= b时编译器是下面这样实现的：</p><blockquote><p>右边列的函数是否可用 对应的二元函数(比如 plus() )是否也可用,不可用在报告错误 确定它的返回值是 Unit 否则报告错误 生成 a.plusAssign(b) 否则试着生成 a=a+b 代码</p></blockquote><p>Note: assignments are NOT expressions in Kotlin.</p><table><thead><tr><th>表达式</th><th style="text-align:center">转换</th></tr></thead><tbody><tr><td>a == b</td><td style="text-align:center">a?.equals(b) ?: b.identityEquals(null)</td></tr><tr><td>a != b</td><td style="text-align:center">!(a?.equals(b) ?: b.identityEquals(null))</td></tr></tbody></table><p>注意 === !== 是不允许重载的<br>== 操作符有俩点特别：</p><blockquote><p>它被翻译成一个复杂的表达式，用于筛选空值，而且 null == null 是真<br>它需要带有特定签名的函数，而不仅仅是特定名称的函数，下面这样：</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">equals</span><span class="params">(other: <span class="type">Any</span>?)</span></span>: <span class="built_in">Boolean</span></span><br></pre></td></tr></table></figure><p>或者用相同的参数列表和返回类型的扩展功能</p><table><thead><tr><th>表达式</th><th style="text-align:center">转换</th></tr></thead><tbody><tr><td>a &gt; b</td><td style="text-align:center">a.compareTo(b) &gt; 0</td></tr><tr><td>a &lt; b</td><td style="text-align:center">a.compareTo(b) &lt; 0</td></tr><tr><td>a &gt;= b</td><td style="text-align:center">a.compareTo(b) &gt;= 0</td></tr><tr><td>a &lt;= b</td><td style="text-align:center">a.compareTo(b) &lt;= 0</td></tr></tbody></table><p>所有的比较都转换为 compareTo 的调用，这个函数需要返回 Int 值</p><p>#####命名函数的中缀调用</p><p>我们可以通过 中缀函数的调用 来模拟自定义中缀操作符</p><h4 id="空安全"><a href="#空安全" class="headerlink" title="空安全"></a>空安全</h4><h5 id="可空类型和非空类型"><a href="#可空类型和非空类型" class="headerlink" title="可空类型和非空类型"></a>可空类型和非空类型</h5><p>Kotlin 类型系统致力于消灭空引用。<br>在许多语言中都存在的一个大陷阱包括 java ，就是访问一个空引用的成员，结果会有空引用异常。在 java 中这就是 NullPointerException 或者叫 NPE<br>Kotlin 类型系统致力与消灭 NullPointerException 异常。唯一可能引起 NPE异常的可能是：</p><blockquote><p>明确调用 throw NullPointerException() 外部 java 代码引起 一些前后矛盾的初始化(在构造函数中没初始化的成员在其它地方使用)</p></blockquote><p>在 Kotlin 类型系统中可以为空和不可为空的引用是不同的。比如，普通的String 类型的变量不能为空：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a: String =<span class="string">"abc"</span></span><br><span class="line">a = <span class="literal">null</span> <span class="comment">//编译错误</span></span><br></pre></td></tr></table></figure><p>允许为空，我们必须把它声明为可空的变量：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b: String? = <span class="string">"abc"</span></span><br><span class="line">b = <span class="literal">null</span></span><br></pre></td></tr></table></figure><p>现在你可以调用 a 的方法，而不用担心 NPE 异常了：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> l = a.length()</span><br></pre></td></tr></table></figure><p>但如果你想使用 b 调用同样的方法就有可能报错了：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> l = b.length() <span class="comment">//错误：b 不可为空</span></span><br></pre></td></tr></table></figure><p>但我们任然想要调用方法，有些办法可以解决。</p><h5 id="在条件中检查-null"><a href="#在条件中检查-null" class="headerlink" title="在条件中检查 null"></a>在条件中检查 null</h5><p>首先，你可以检查 b 是否为空，并且分开处理下面选项：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> l = <span class="keyword">if</span> (b != <span class="literal">null</span>) b.length() <span class="keyword">else</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure><p>编译器会跟踪你检查的信息并允许在 if 中调用 length()。更复杂的条件也是可以的：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (b != <span class="literal">null</span> &amp;&amp; b.length() &gt;<span class="number">0</span>)</span><br><span class="line">print(<span class="string">"Stirng of length <span class="subst">$&#123;b.length&#125;</span>"</span>)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">print(<span class="string">"Empty string"</span>)</span><br></pre></td></tr></table></figure><p>注意只有在 b 是不可变时才可以</p><h5 id="安全调用"><a href="#安全调用" class="headerlink" title="安全调用"></a>安全调用</h5><p>第二个选择就是使用安全操作符， ?. :</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b?.length()</span><br></pre></td></tr></table></figure><p>如果 b 不为空则返回长度，否则返回空。这个表达式的的类型是 Int?<br>安全调用在链式调用是是很有用的。比如，如果 Bob 是一个雇员可能分配部门(也可能不分配)，如果我们想获取 Bob 的部门名作为名字的前缀，就可以这样做：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bob?.department?.head?.name</span><br></pre></td></tr></table></figure><p>这样的调用链在任何一个属性为空都会返回空。</p><h5 id="Elvis-操作符"><a href="#Elvis-操作符" class="headerlink" title="Elvis 操作符"></a>Elvis 操作符</h5><p>当我们有一个 r 的可空引用时，我们可以说如果 r 不空则使用它，否则使用使用非空的 x :</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> l: <span class="built_in">Int</span> = <span class="keyword">if</span> (b != <span class="literal">null</span>) b.length() <span class="keyword">else</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure><p>尽管使用 if 表达式我们也可以使用 Elvis 操作符， ?:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> l = b.length()?: -<span class="number">1</span></span><br></pre></td></tr></table></figure><p>如果 ?: 左边表达式不为空则返回，否则返回右边的表达式。注意右边的表带式只有在左边表达式为空是才会执行<br>注意在 Kotlin 中 throw return 是表达式，所以它们也可以在 Elvis 操作符右边。这是非常有用的，比如检查函数参数是否为空；</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">(node: <span class="type">Node</span>)</span></span>: String? &#123;</span><br><span class="line">    <span class="keyword">val</span> parent = node.getParent() ?: <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    <span class="keyword">val</span> name = node.getName() ?: <span class="keyword">throw</span> IllegalArgumentException(<span class="string">"name expected"</span>)</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="操作符"><a href="#操作符" class="headerlink" title="!! 操作符"></a>!! 操作符</h5><p>第三个选择是 NPE-lovers。我们可以用 b!! ，这会返回一个非空的 b 或者抛出一个 b 为空的 NPE</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> l = b !!.length()</span><br></pre></td></tr></table></figure><h5 id="安全转换"><a href="#安全转换" class="headerlink" title="安全转换"></a>安全转换</h5><p>普通的转换可能产生 ClassCastException 异常。另一个选择就是使用安全转换，如果不成功就返回空：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> aInt: <span class="built_in">Int</span>? = a <span class="keyword">as</span>? <span class="built_in">Int</span></span><br></pre></td></tr></table></figure><h4 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h4><h5 id="异常类"><a href="#异常类" class="headerlink" title="异常类"></a>异常类</h5><p>所有的异常类都是 Exception 的子类。每个异常都有一个消息，栈踪迹和可选的原因。<br>使用 throw 表达式，抛出异常</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> MyException(<span class="string">"Hi There!"</span>)</span><br></pre></td></tr></table></figure><p>使用 try 捕获异常</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// some code</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (e: SomeException) &#123;</span><br><span class="line"><span class="comment">// handler</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">// optional finally block</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有可能有不止一个的 catch 块。finally 块可以省略。</p><h5 id="try-是一个表达式"><a href="#try-是一个表达式" class="headerlink" title="try 是一个表达式"></a>try 是一个表达式</h5><p>try 可以有返回值：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> a: <span class="built_in">Int</span>? = <span class="keyword">try</span> &#123; parseInt(input) &#125; <span class="keyword">catch</span> (e: NumberFormatException) &#123; <span class="literal">null</span> &#125;</span><br></pre></td></tr></table></figure><p>try 返回值要么是 try 块的最后一个表达式，要么是 catch 块的最后一个表达式。 finally 块的内容不会对表达式有任何影响。</p><h5 id="检查异常"><a href="#检查异常" class="headerlink" title="检查异常"></a>检查异常</h5><p>Kotlin 中没有异常检查。这是由多种原因造成的，我们这里举个简单的例子下面是 JDK StringBuilder 类实现的一个接口</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Appendable append(CharSequence csq) throws IOException;</span><br></pre></td></tr></table></figure><p>这个签名说了什么？ 它说每次我把 string 添加到什么东西(StringBuilder 或者 log console 等等)上时都会捕获 IOExceptions 为什么呢？因为可能涉及到 IO 操作(Writer 也实现了 Appendable)… 所以导致所有实现 Appendable 的接口都得捕获异常</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">log.append(message)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"><span class="comment">// Must be safe</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样是不利的，参看Effective java<br>Bruce Eckel 在java 需要异常检查吗?说到：</p><blockquote><p>Examination of small programs leads to the conclusion that requiring exception specifications could both enhance developer productivity and enhance code quality, but experience with large software projects suggests a different result – decreased productivity and little or no increase in code quality.</p></blockquote><h4 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h4><h5 id="注解声明"><a href="#注解声明" class="headerlink" title="注解声明"></a>注解声明</h5><p>注解是一种将元数据附加到代码中的方法。声明注解需要在类前面使用 annotation关键字：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">annotation</span> <span class="class"><span class="keyword">class</span> <span class="title">fancy</span></span></span><br></pre></td></tr></table></figure><h5 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@fancy</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="meta">@fancy</span> <span class="function"><span class="keyword">fun</span> <span class="title">baz</span><span class="params">(<span class="meta">@fancy</span> foo: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="meta">@fancy</span> <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在多数情形中 @ 标识是可选的。只有在注解表达式或本地声明中才必须：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fancy <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    fancy <span class="function"><span class="keyword">fun</span> <span class="title">baz</span><span class="params">(fancy foo: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="meta">@fancy</span> <span class="function"><span class="keyword">fun</span> <span class="title">bar</span><span class="params">()</span></span> &#123; ... &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="meta">@fancy</span> <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要给构造函数注解，就需要在构造函数声明时添加 constructor 关键字，并且需要在前面添加注解：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> <span class="meta">@inject</span> <span class="keyword">constructor</span> </span>(dependency: MyDependency)</span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure><p>也可以注解属性访问者：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x: MyDependency?=<span class="literal">null</span></span><br><span class="line">    <span class="meta">@inject</span> <span class="keyword">set</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h5><p>注解可以有带参数的构造函数。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">annotation</span> <span class="class"><span class="keyword">class</span> <span class="title">special</span></span>(<span class="keyword">val</span> why: String)</span><br><span class="line">special(<span class="string">"example"</span>) <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><h5 id="Lambdas"><a href="#Lambdas" class="headerlink" title="Lambdas"></a>Lambdas</h5><p>注解也可以用在 Lambda 中。这将会应用到 lambda 生成的 invoke() 方法。这对Quasar框架很有用，在这个框架中注解被用来并发控制</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">annotation</span> <span class="class"><span class="keyword">class</span> <span class="title">Suspendable</span></span></span><br><span class="line"><span class="keyword">val</span> f = <span class="meta">@Suspendable</span> &#123; Fiber.sleep(<span class="number">10</span>) &#125;</span><br></pre></td></tr></table></figure><h5 id="java-注解"><a href="#java-注解" class="headerlink" title="java 注解"></a>java 注解</h5><p>java 注解在 kotlin 中是完全兼容的：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test</span><br><span class="line"><span class="keyword">import</span> org.junit.Assert.*</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tests</span> </span>&#123;</span><br><span class="line">    Test <span class="function"><span class="keyword">fun</span> <span class="title">simple</span><span class="params">()</span></span> &#123;</span><br><span class="line">    assertEquals(<span class="number">42</span>, getTheAnswer())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>java 注解也可以通过在导入是重命名实现像修改者那样：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test <span class="keyword">as</span> test</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tests</span> </span>&#123;</span><br><span class="line">    test <span class="function"><span class="keyword">fun</span> <span class="title">simple</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为 java 中注解参数顺序是没定义的，你不能通过传入参数的方法调用普通函数。相反，你需要使用命名参数语法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Ann &#123;</span><br><span class="line">    int intValue();</span><br><span class="line">    String stringValue(<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//kotlin</span></span><br><span class="line">Ann(intValue = <span class="number">1</span>, stringValue = <span class="string">"abc"</span>) <span class="class"><span class="keyword">class</span> <span class="title">C</span></span></span><br></pre></td></tr></table></figure><p>像 java 中那样，值参数是特殊的情形；它的值可以不用明确的名字。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AnnWithValue &#123;</span><br><span class="line">String value();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//kotlin</span></span><br><span class="line">AnnWithValue(<span class="string">"abc"</span>) <span class="class"><span class="keyword">class</span> <span class="title">C</span></span></span><br></pre></td></tr></table></figure><p>如果java 中的 value 参数有数组类型，则在 kotlin 中变成 vararg 参数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AnnWithArrayValue &#123;</span><br><span class="line">String[] value();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Kotlin</span></span><br><span class="line">AnnWithArrayValue(<span class="string">"abc"</span>, <span class="string">"foo"</span>, <span class="string">"bar"</span>) <span class="class"><span class="keyword">class</span> <span class="title">C</span></span></span><br></pre></td></tr></table></figure><p>如果你需要明确一个类作为一个注解参数，使用 Kotlin 类KClass。Kotlin 编译器会自动把它转为 java 类，因此 java 代码就可以正常看到注解和参数了。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlin.reflect.KClass</span><br><span class="line"><span class="keyword">annotation</span> <span class="class"><span class="keyword">class</span> <span class="title">Ann</span></span>(<span class="keyword">val</span> arg1: KClass&lt;*&gt;, <span class="keyword">val</span> arg2: KClass&lt;<span class="keyword">out</span> Any?&gt;)</span><br><span class="line">Ann(String::<span class="class"><span class="keyword">class</span>, <span class="type">Int::class) class MyClass</span></span></span><br></pre></td></tr></table></figure><p>注解实例的值在 kotlin 代码中是暴露属性。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Ann &#123;</span><br><span class="line">int value();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Kotlin</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">(ann: <span class="type">Ann</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">val</span> i = ann.value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h4><p>反射是一系列语言和库的特性，允许在运行是获取你代码结构。 Kotlin 把函数和属性作为语言的头等类，而且反射它们和使用函数式编程或反应是编程风格很像。</p><blockquote><p>On the Java platform, the runtime component required for using the reflection features is distributed as a separate JAR file (kotlin-reflect.jar). This is done to reduce the required size of the runtime library for applications that do not use reflection features. If you do use reflection, please make sure that the .jar file is added to the classpath of your project.</p></blockquote><h5 id="类引用"><a href="#类引用" class="headerlink" title="类引用"></a>类引用</h5><p>最基本的反射特性就是得到运行时的类引用。要获取引用并使之成为静态类可以使用字面类语法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> c = MyClass::<span class="class"><span class="keyword">class</span></span></span><br></pre></td></tr></table></figure><p>引用是一种 KClass类型的值。你可以使用 KClass.properties 和 KClass.extensionProperties 获取类和父类的所有属性引用的列表。<br>注意这与 java 类的引用是不一样的。参看 java interop section</p><h5 id="函数引用"><a href="#函数引用" class="headerlink" title="函数引用"></a>函数引用</h5><p>当有一个像下面这样的函数声明时：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">isOdd</span><span class="params">(x: <span class="type">Int</span>)</span></span> =x % <span class="number">2</span> !=<span class="number">0</span></span><br></pre></td></tr></table></figure><p>我们可以通过 isOdd(5) 轻松调用，同样我们也可以把它作为一个值传递给其它函数。我们可以使用 :: 操作符</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> numbers = listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">println(numbers.filter( ::isOdd) ) <span class="comment">//prints [1, 3]</span></span><br></pre></td></tr></table></figure><p>这里 ::isOdd 是是一个函数类型的值 (Int) -&gt; Boolean<br>注意现在 :: 操作符右边不能用语重载函数。将来，我们计划提供一个语法明确参数类型这样就可以使用明确的重载函数了。<br>如果需要使用一系列类，或者扩展函数，必须是需合格的，并且结果是扩展函数类型，比如。 String::toCharArray 就带来一个 String: String.() -&gt; CharArray 类型的扩展函数。</p><h5 id="例子：函数组合"><a href="#例子：函数组合" class="headerlink" title="例子：函数组合"></a>例子：函数组合</h5><p>考虑一下下面的函数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> compose<span class="type">&lt;A, B, C&gt;</span><span class="params">(f: (<span class="type">B</span>)</span></span> -&gt; C, g: (A) -&gt; B): (A) -&gt; C &#123;</span><br><span class="line"><span class="keyword">return</span> &#123;x -&gt; f(g(x))&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它返回一个由俩个传递进去的函数的组合。现在你可以把它用在可调用的引用上了：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">length</span><span class="params">(s: <span class="type">String</span>)</span></span> = s.size</span><br><span class="line"><span class="keyword">val</span> oddLength = compose(::isOdd, ::length)</span><br><span class="line"><span class="keyword">val</span> strings = listOf(<span class="string">"a"</span>, <span class="string">"ab"</span>, <span class="string">"abc"</span>)</span><br><span class="line">println(strings.filter(oddLength)) <span class="comment">// Prints "[a, abc]"</span></span><br></pre></td></tr></table></figure><h5 id="属性引用"><a href="#属性引用" class="headerlink" title="属性引用"></a>属性引用</h5><p>在 kotlin 中访问顶级类的属性，我们也可以使用 :: 操作符：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    println(::x.<span class="keyword">get</span>())</span><br><span class="line">    ::x.<span class="keyword">set</span>(<span class="number">2</span>)</span><br><span class="line">    println(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>::x 表达式评估为 KProperty 类型的属性，它允许我们使用 get() 读它的值或者使用名字取回它的属性。更多请参看docs on the KProperty class<br>对于可变的属性比如 var y =1 , ::y 返回类型为 [KMutableProperty]，它有 set() 方法<br>访问一个类的属性成员，我们这样修饰：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>(<span class="keyword">val</span> p: <span class="built_in">Int</span>)</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> prop = A::p</span><br><span class="line">    println(prop.<span class="keyword">get</span>(A(<span class="number">1</span>))) <span class="comment">// prints "1"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于扩展属性：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> String.lastChar: <span class="built_in">Char</span></span><br><span class="line"><span class="keyword">get</span>() = <span class="keyword">this</span>[size - <span class="number">1</span>]</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">println(String::lastChar.<span class="keyword">get</span>(<span class="string">"abc"</span>)) <span class="comment">// prints "c"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="与-java-反射调用"><a href="#与-java-反射调用" class="headerlink" title="与 java 反射调用"></a>与 java 反射调用</h5><p>在 java 平台上，标准库包括反射类的扩展，提供了到 java 反射对象的映射(参看kotlin.reflect.jvm 包)。比如，想找到一个备用字段或者 java getter 方法，你可以这样写：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlin.reflect.jvm.*</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>(<span class="keyword">val</span> p: <span class="built_in">Int</span>)</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">println(A::p.javaGetter) <span class="comment">// prints "public final int A.getP()"</span></span><br><span class="line">println(A::p.javaField) <span class="comment">// prints "private final int A.p"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="构造函数引用"><a href="#构造函数引用" class="headerlink" title="构造函数引用"></a>构造函数引用</h5><p>构造函数可以像方法或属性那样引用。只需要使用 :: 操作符并加上类名。下面的函数是一个没有参数并且返回类型是 Foo :</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">calss Foo</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">function</span><span class="params">(factory : ()</span></span> -&gt; Foo) &#123;</span><br><span class="line"><span class="keyword">val</span> x: Foo = factory()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以像下面这样使用：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function(:: Foo)</span><br></pre></td></tr></table></figure><h4 id="动态类型"><a href="#动态类型" class="headerlink" title="动态类型"></a>动态类型</h4><p>作为静态类型的语言，kotlin任然拥有与无类型或弱类型语言的调用，比如javaScript。为了方便使用， dynamic 应而生：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> dyn: <span class="keyword">dynamic</span> = ...</span><br></pre></td></tr></table></figure><p>dynamic 类型关闭了 kotlin 的类型检查：</p><blockquote><p>这样的类型可以分配任意变量或者在任意的地方作为参数传递 任何值都可以分配为 dynamic 类型，或者作为参数传递给任何接受 dynamic 类型参数的函数 这样的类型不做 null 检查</p></blockquote><p>dynamic 最奇特的特性就是可以在 dynamic 变量上调用任何属性或任何方法： (The most peculiar feature of dynamic is that we are allowed to call any property or function with any parameters on a dynamic variable:)</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dyn.whatever(<span class="number">1</span>, <span class="string">"foo"</span>, dyn) <span class="comment">// 'whatever' is not defined anywhere</span></span><br><span class="line">dyn.whatever(*array(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))</span><br></pre></td></tr></table></figure><p>在 javaScript 平台上这样的代码会编译为 ‘as is’: dyn.whatever(1) 在 kotlin 中变成了 javaScript 中的代码 (On the JavaScript platform this code will be compiled “as is”: dyn.whatever(1) in Kotlin becomes dyn.whatever(1) in the generated JavaScript code.)<br>动态调用可以返回 dynamic 作为结果，因此我们可以轻松实现链式调用：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dyn.foo().bar.bat(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>当给动态调用传递一个 lambda 表达式时，所有的参数默认都是 dynamic ：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dyn.foo &#123;</span><br><span class="line">x -&gt; x.bar() <span class="comment">// x is dynamic</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;其它&quot;&gt;&lt;a href=&quot;#其它&quot; class=&quot;headerlink&quot; title=&quot;其它&quot;&gt;&lt;/a&gt;其它&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;多重申明&lt;/li&gt;
&lt;li&gt;Ranges&lt;/li&gt;
&lt;li&gt;类型检查和自动转换&lt;/li&gt;
&lt;li&gt;This表达式&lt;/li&gt;
&lt;li&gt;等式&lt;/li&gt;
&lt;li&gt;运算符重载&lt;/li&gt;
&lt;li&gt;空安全&lt;/li&gt;
&lt;li&gt;异常&lt;/li&gt;
&lt;li&gt;注解&lt;/li&gt;
&lt;li&gt;反射&lt;/li&gt;
&lt;li&gt;动态类型&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="learn" scheme="http://www.sanmaoliu.com/tags/learn/"/>
    
      <category term="Kotlin" scheme="http://www.sanmaoliu.com/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>设计模式：单例模式</title>
    <link href="http://www.sanmaoliu.com/2018/05/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9A%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.sanmaoliu.com/2018/05/14/设计模式：单例模式/</id>
    <published>2018-05-14T06:31:34.000Z</published>
    <updated>2018-05-19T08:04:46.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="实现单例模式"><a href="#实现单例模式" class="headerlink" title="实现单例模式"></a>实现单例模式</h4><h5 id="单例模式第一版："><a href="#单例模式第一版：" class="headerlink" title="单例模式第一版："></a>单例模式第一版：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;  <span class="comment">//私有构造函数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;  <span class="comment">//单例对象</span></span><br><span class="line">    <span class="comment">//静态工厂方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>为什么这样写呢？我们来解释几个关键点：</p><p>1.要想让一个类只能构建一个对象，自然不能让它随便去做new操作，因此Signleton的构造方法是私有的。</p><p>2.instance是Singleton类的静态成员，也是我们的单例对象。它的初始值可以写成Null，也可以写成new Singleton()。至于其中的区别后来会做解释。</p><p>3.getInstance是获取单例对象的方法。</p><p>如果单例初始值是null，还未构建，则构建单例对象并返回。这个写法属于单例模式当中的<strong>懒汉模式。</strong></p><p>如果单例对象一开始就被new Singleton()主动构建，则不再需要判空操作，这种写法属于<strong>饿汉模式</strong>。</p><p>这两个名字很形象：饿汉主动找食物吃，懒汉躺在地上等着人喂。</p><h5 id="单例模式第二版：线程安全"><a href="#单例模式第二版：线程安全" class="headerlink" title="单例模式第二版：线程安全"></a>单例模式第二版：线程安全</h5><p>为什么说刚才的代码不是线程安全呢？</p><p>假设Singleton类刚刚被初始化，instance对象还是空，这时候两个线程同时访问getInstance方法：</p><p><img src="https://coding.net/u/sanmaoliu/p/pictures/git/raw/master/单例模式1.jpg" alt></p><p>因为Instance是空，所以两个线程同时通过了条件判断，开始执行new操作：</p><p><img src="https://coding.net/u/sanmaoliu/p/pictures/git/raw/master/单例模式2.jpg" alt></p><p>这样一来，显然instance被构建了两次。让我们对代码做一下修改：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;  <span class="comment">//私有构造函数</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;  <span class="comment">//单例对象</span></span><br><span class="line">   <span class="comment">//静态工厂方法</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;      <span class="comment">//双重检测机制</span></span><br><span class="line">         <span class="keyword">synchronized</span> (Singleton.class)&#123;  <span class="comment">//同步锁</span></span><br><span class="line">           <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;     <span class="comment">//双重检测机制</span></span><br><span class="line">             instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么这样写呢？我们来解释几个关键点：</p><p>1.为了防止new Singleton被执行多次，因此在new操作之前加上Synchronized 同步锁，锁住整个类（注意，这里不能使用对象锁）。</p><p>2.进入Synchronized 临界区以后，还要再做一次判空。因为当两个线程同时访问的时候，线程A构建完对象，线程B也已经通过了最初的判空验证，不做第二次判空的话，线程B还是会再次构建instance对象。</p><p><img src="https://coding.net/u/sanmaoliu/p/pictures/git/raw/master/单例模式3.jpg" alt></p><p><img src="https://coding.net/u/sanmaoliu/p/pictures/git/raw/master/单例模式4.jpg" alt></p><p><img src="https://coding.net/u/sanmaoliu/p/pictures/git/raw/master/单例模式5.jpg" alt></p><p><img src="https://coding.net/u/sanmaoliu/p/pictures/git/raw/master/单例模式6.jpg" alt></p><p><img src="https://coding.net/u/sanmaoliu/p/pictures/git/raw/master/单例模式7.jpg" alt></p><p>像这样两次判空的机制叫做<strong>双重检测机制</strong>。</p><h5 id="单例模式第三版：隐藏的漏洞"><a href="#单例模式第三版：隐藏的漏洞" class="headerlink" title="单例模式第三版：隐藏的漏洞"></a>单例模式第三版：隐藏的漏洞</h5><p>假设这样的场景，当两个线程一先一后访问getInstance方法的时候，当A线程正在构建对象，B线程刚刚进入方法：</p><p><img src="https://coding.net/u/sanmaoliu/p/pictures/git/raw/master/单例模式8.jpg" alt></p><p>这种情况表面看似没什么问题，要么Instance还没被线程A构建，线程B执行 if（instance == null）的时候得到true；要么Instance已经被线程A构建完成，线程B执行 if（instance == null）的时候得到false。</p><p>真的如此吗？答案是否定的。这里涉及到了JVM编译器的<strong>指令重排</strong>。</p><p>指令重排是什么意思呢？比如java中简单的一句 instance = new Singleton，会被编译器编译成如下JVM指令： </p><p>memory =allocate();    //1：分配对象的内存空间  </p><p>ctorInstance(memory);  //2：初始化对象 </p><p>instance =memory;     //3：设置instance指向刚分配的内存地址 </p><p>但是这些指令顺序并非一成不变，有可能会经过JVM和CPU的优化，指令重排成下面的顺序：</p><p>memory =allocate();    //1：分配对象的内存空间 </p><p>instance =memory;     //3：设置instance指向刚分配的内存地址 </p><p>ctorInstance(memory);  //2：初始化对象 </p><p>当线程A执行完1,3,时，instance对象还未完成初始化，但已经不再指向null。此时如果线程B抢占到CPU资源，执行  if（instance == null）的结果会是false，从而返回一个<strong>没有初始化完成的instance对象</strong>。如下图所示：</p><p><img src="https://coding.net/u/sanmaoliu/p/pictures/git/raw/master/单例模式9.jpg" alt></p><p><img src="https://coding.net/u/sanmaoliu/p/pictures/git/raw/master/单例模式10.jpg" alt></p><p>如何避免这一情况呢？我们需要在instance对象前面增加一个修饰符<strong>volatile。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;  <span class="comment">//私有构造函数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;  <span class="comment">//单例对象</span></span><br><span class="line">    <span class="comment">//静态工厂方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;      <span class="comment">//双重检测机制</span></span><br><span class="line">         <span class="keyword">synchronized</span> (Singleton.class)&#123;  <span class="comment">//同步锁</span></span><br><span class="line">           <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;     <span class="comment">//双重检测机制</span></span><br><span class="line">             instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">             &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> instance;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>volatile</p><blockquote><p>The volatile keyword indicates that a value may change between different accesses, it prevents an optimizing compiler from optimizing away subsequent reads or writes and thus incorrectly reusing a stale value or omitting writes.</p></blockquote><p>经过volatile的修饰，当线程A执行instance = new Singleton的时候，JVM执行顺序是什么样？始终保证是下面的顺序：</p><p>memory =allocate();    //1：分配对象的内存空间  </p><p>ctorInstance(memory);  //2：初始化对象 </p><p>instance =memory;     //3：设置instance指向刚分配的内存地址 </p><p>如此在线程B看来，instance对象的引用要么指向null，要么指向一个初始化完毕的Instance，而不会出现某个中间态，保证了安全。</p><h5 id="用静态内部类实现单例模式："><a href="#用静态内部类实现单例模式：" class="headerlink" title="用静态内部类实现单例模式："></a>用静态内部类实现单例模式：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LazyHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有几个需要注意的点：</p><p>1.从外部无法访问静态内部类LazyHolder，只有当调用Singleton.getInstance方法的时候，才能得到单例对象INSTANCE。</p><p>2.INSTANCE对象初始化的时机并不是在单例类Singleton被加载的时候，而是在调用getInstance方法，使得静态内部类LazyHolder被加载的时候。因此这种实现方式是利用<strong>classloader的加载机制</strong>来实现懒加载，并保证构建单例的线程安全。</p><p>还存在一个问题无法防止利用反射来重复构建对象，先看下如何利用反射打破单例模式的约束</p><p>如何利用反射打破单例模式的约束？其实很简单，我们来看下代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获得构造器</span></span><br><span class="line">Constructor con = Singleton.class.getDeclaredConstructor();</span><br><span class="line"><span class="comment">//设置为可访问</span></span><br><span class="line">con.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">//构造两个不同的对象</span></span><br><span class="line">Singleton singleton1 = (Singleton)con.newInstance();</span><br><span class="line">Singleton singleton2 = (Singleton)con.newInstance();</span><br><span class="line"><span class="comment">//验证是否是不同对象</span></span><br><span class="line">System.out.println(singleton1.equals(singleton2));</span><br></pre></td></tr></table></figure><p>代码可以简单归纳为三个步骤：</p><p>第一步，获得单例类的构造器。</p><p>第二步，把构造器设置为可访问。</p><p>第三步，使用newInstance方法构造对象。</p><p>最后为了确认这两个对象是否真的是不同的对象，我们使用equals方法进行比较。毫无疑问，比较结果是false。 </p><p><strong>用枚举实现单例模式来防止反射的构建方式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> SingletonEnum &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>让我们来做一个实验，仍然执行刚才的反射代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获得构造器</span></span><br><span class="line">Constructor con = SingletonEnum.class.getDeclaredConstructor();</span><br><span class="line"><span class="comment">//设置为可访问</span></span><br><span class="line">con.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">//构造两个不同的对象</span></span><br><span class="line">SingletonEnum singleton1 = (SingletonEnum)con.newInstance();</span><br><span class="line">SingletonEnum singleton2 = (SingletonEnum)con.newInstance();</span><br><span class="line"><span class="comment">//验证是否是不同对象</span></span><br><span class="line">System.out.println(singleton1.equals(singleton2));</span><br></pre></td></tr></table></figure><p>执行获得构造器这一步的时候，抛出了如下异常：</p><p>Exception in thread “main” java.lang.NoSuchMethodException: com.xiaohui.singleton.test.SingletonEnum.<init>()</init></p><p>at java.lang.Class.getConstructor0(Class.java:2892)</p><p>at java.lang.Class.getDeclaredConstructor(Class.java:2058)</p><p>at com.xiaohui.singleton.test.SingletonTest.main(SingletonTest.java:22)</p><p>at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</p><p>at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)</p><p>at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</p><p>at java.lang.reflect.Method.invoke(Method.java:606)</p><p>at com.intellij.rt.execution.application.AppMain.main(AppMain.java:134)</p><p><img src="https://coding.net/u/sanmaoliu/p/pictures/git/raw/master/单例模式11.jpg" alt></p><p><strong>几点补充：</strong></p><ol><li>volatile关键字不但可以防止指令重排，也可以保证线程访问的变量值是<strong>主内存中的最新值</strong>。有关volatile的详细原理，我在以后的漫画中会专门讲解。</li><li>使用枚举实现的单例模式，不但可以防止利用反射强行构建单例对象，而且可以在枚举类对象被<strong>反序列化</strong>的时候，保证反序列的返回结果是同一对象。 </li></ol><p>对于其他方式实现的单例模式，如果既想要做到可序列化，又想要反序列化为同一对象，则必须实现<strong>readResolve</strong>方法。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;实现单例模式&quot;&gt;&lt;a href=&quot;#实现单例模式&quot; class=&quot;headerlink&quot; title=&quot;实现单例模式&quot;&gt;&lt;/a&gt;实现单例模式&lt;/h4&gt;&lt;h5 id=&quot;单例模式第一版：&quot;&gt;&lt;a href=&quot;#单例模式第一版：&quot; class=&quot;headerlink&quot; title=&quot;单例模式第一版：&quot;&gt;&lt;/a&gt;单例模式第一版：&lt;/h5&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Singleton&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Singleton&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&amp;#125;  &lt;span class=&quot;comment&quot;&gt;//私有构造函数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; Singleton instance = &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;  &lt;span class=&quot;comment&quot;&gt;//单例对象&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//静态工厂方法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; Singleton &lt;span class=&quot;title&quot;&gt;getInstance&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (instance == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            instance = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Singleton();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; instance;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="design patterns" scheme="http://www.sanmaoliu.com/tags/design-patterns/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin Learning(5章)</title>
    <link href="http://www.sanmaoliu.com/2018/05/11/Kotlin-Learning4/"/>
    <id>http://www.sanmaoliu.com/2018/05/11/Kotlin-Learning4/</id>
    <published>2018-05-11T06:38:02.000Z</published>
    <updated>2018-05-11T07:13:36.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="函数和lambda表达式"><a href="#函数和lambda表达式" class="headerlink" title="函数和lambda表达式"></a>函数和lambda表达式</h3><ol><li><p>函数</p></li><li><p>高级函数和lambda表达式</p></li><li><p>内联函数</p><a id="more"></a></li></ol><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><h5 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h5><p>在 kotlin 中用关键字 fun 声明函数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">double</span><span class="params">(x: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="函数用法"><a href="#函数用法" class="headerlink" title="函数用法"></a>函数用法</h5><p>通过传统的方法调用函数</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> result = double(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>通过 . 调用成员函数</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Sample().foo() <span class="comment">// 创建Sample类的实例,调用foo方法</span></span><br></pre></td></tr></table></figure><h5 id="中缀符号"><a href="#中缀符号" class="headerlink" title="中缀符号"></a>中缀符号</h5><p>在满足以下条件时,函数也可以通过中缀符号进行调用：</p><blockquote><p>它们是成员函数或者是扩展函数 只有一个参数 使用 infix 关键词进行标记</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//给 Int 定义一个扩展方法</span></span><br><span class="line"><span class="keyword">infix</span> <span class="function"><span class="keyword">fun</span> <span class="built_in">Int</span>.<span class="title">shl</span><span class="params">(x: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1</span> shl <span class="number">2</span> <span class="comment">//用中缀注解调用扩展函数</span></span><br><span class="line"><span class="number">1</span>.shl(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><h5 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h5><p>函数参数是用 Pascal 符号定义的 name:type。参数之间用逗号隔开，每个参数必须指明类型。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">powerOf</span><span class="params">(number: <span class="type">Int</span>, exponent: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h5><p>函数参数可以设置默认值,当参数被忽略时会使用默认值。这样相比其他语言可以减少重载。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">read</span><span class="params">(b: <span class="type">Array</span>&lt;<span class="type">Byte</span>&gt;, off: <span class="type">Int</span> = <span class="number">0</span>, len: <span class="type">Int</span> = b.size()</span></span> ) &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认值可以通过在type类型后使用 = 号进行赋值</p><h5 id="命名参数"><a href="#命名参数" class="headerlink" title="命名参数"></a>命名参数</h5><p>在调用函数时可以参数可以命名。这对于那种有大量参数的函数是很方便的.</p><p>下面是一个例子：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">reformat</span><span class="params">(str: <span class="type">String</span>, </span></span></span><br><span class="line"><span class="function"><span class="params">             normalizeCase: <span class="type">Boolean</span> = <span class="literal">true</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">             upperCaseFirstLetter: <span class="type">Boolean</span> = <span class="literal">true</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">divideByCamelHumps: <span class="type">Boolean</span> = <span class="literal">false</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">wordSeparator: <span class="type">Char</span> = <span class="string">' '</span>)</span></span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以使用默认参数</p><blockquote><p>reformat(str)</p></blockquote><p>然而当调用非默认参数是就需要像下面这样：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reformat(str, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="string">'_'</span>)</span><br></pre></td></tr></table></figure><p>使用命名参数我们可以让代码可读性更强：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">reformat(str,</span><br><span class="line">        normalizeCase = <span class="literal">true</span>,</span><br><span class="line">        uppercaseFirstLetter = <span class="literal">true</span>,</span><br><span class="line">        divideByCamelHumps = <span class="literal">false</span>,</span><br><span class="line">        wordSeparator = <span class="string">'_'</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>如果不需要全部参数的话可以这样：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reformat(str, wordSeparator = <span class="string">'_'</span>)</span><br></pre></td></tr></table></figure><p>注意,命名参数语法不能够被用于调用Java函数中,因为Java的字节码不能确保方法参数命名的不变性</p><h5 id="不带返回值的参数"><a href="#不带返回值的参数" class="headerlink" title="不带返回值的参数"></a>不带返回值的参数</h5><p>如果函数不会返回任何有用值，那么他的返回类型就是 Unit . Unit 是一个只有唯一值 Unit 的类型.这个值并不需要被直接返回:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printHello</span><span class="params">(name: <span class="type">String</span>?)</span></span>: <span class="built_in">Unit</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (name != <span class="literal">null</span>)</span><br><span class="line">    println(<span class="string">"Hello <span class="subst">$&#123;name&#125;</span>"</span>)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    println(<span class="string">"Hi there!"</span>)</span><br><span class="line">    <span class="comment">// `return Unit` or `return` is optional</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Unit 返回值也可以省略，比如下面这样：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printHello</span><span class="params">(name: <span class="type">String</span>?)</span></span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="单表达式函数"><a href="#单表达式函数" class="headerlink" title="单表达式函数"></a>单表达式函数</h5><p>当函数只返回单个表达式时，大括号可以省略并在 = 后面定义函数体</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">double</span><span class="params">(x: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> = x*<span class="number">2</span></span><br></pre></td></tr></table></figure><p>在编译器可以推断出返回值类型的时候,返回值的类型可以省略:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">double</span><span class="params">(x: <span class="type">Int</span>)</span></span> = x * <span class="number">2</span></span><br></pre></td></tr></table></figure><h5 id="明确返回类型"><a href="#明确返回类型" class="headerlink" title="明确返回类型"></a>明确返回类型</h5><p>下面的例子中必须有明确返回类型,除非他是返回 Unit 类型的值,Kotlin 并不会对函数体重的返回类型进行推断,因为函数体中可能有复杂的控制流,他的返回类型未必对读者可见(甚至对编译器而言也有可能是不可见的)：</p><p>#####变长参数</p><p>函数的参数(通常是最后一个参数)可以用 vararg 修饰符进行标记：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> asList<span class="type">&lt;T&gt;</span><span class="params">(<span class="keyword">vararg</span> ts: <span class="type">T</span>)</span></span>: List&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> result = ArrayList&lt;T&gt;()</span><br><span class="line">    <span class="keyword">for</span> (t <span class="keyword">in</span> ts)</span><br><span class="line">    result.add(t)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>标记后,允许给函数传递可变长度的参数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>只有一个参数可以被标注为 vararg 。加入 vararg 并不是列表中的最后一个参数,那么后面的参数需要通过命名参数语法进行传值,再或者如果这个参数是函数类型,就需要通过lambda法则.<br>当调用变长参数的函数时，我们可以一个一个的传递参数，比如 asList(1, 2, 3) ，或者我们要传递一个 array 的内容给函数，我们就可以使用 * 前缀操作符：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> a = array(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">val</span> list = asList(-<span class="number">1</span>, <span class="number">0</span>, *a, <span class="number">4</span>)</span><br></pre></td></tr></table></figure><h5 id="函数范围"><a href="#函数范围" class="headerlink" title="函数范围"></a>函数范围</h5><p>Kotlin 中可以在文件顶级声明函数，这就意味者你不用像在Java,C#或是Scala一样创建一个类来持有函数。除了顶级函数，Kotlin 函数可以声明为局部的，作为成员函数或扩展函数。</p><p>#####局部函数</p><p>Kotlin 支持局部函数，比如在一个函数包含另一函数。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">dfs</span><span class="params">(graph: <span class="type">Graph</span>)</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">dfs</span><span class="params">(current: <span class="type">Vertex</span>, visited: <span class="type">Set</span>&lt;<span class="type">Vertex</span>&gt;)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited.add(current)) <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> (v <span class="keyword">in</span> current.neighbors)</span><br><span class="line">        dfs(v, visited)</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(graph.vertices[<span class="number">0</span>], HashSet())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>局部函数可以访问外部函数的局部变量(比如闭包)</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">dfs</span><span class="params">(graph: <span class="type">Graph</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> visited = HashSet&lt;Vertex&gt;()</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">dfs</span><span class="params">(current: <span class="type">Vertex</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited.add(current)) <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> (v <span class="keyword">in</span> current.neighbors)</span><br><span class="line">    dfs(v)</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(graph.vertices[<span class="number">0</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>局部函数甚至可以返回到外部函数 qualified return expressions</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">reachable</span><span class="params">(from: <span class="type">Vertex</span>, to: <span class="type">Vertex</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> visited = HashSet&lt;Vertex&gt;()</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">dfs</span><span class="params">(current: <span class="type">Vertex</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (current == to) <span class="keyword">return</span><span class="symbol">@reachable</span> <span class="literal">true</span></span><br><span class="line">        <span class="keyword">if</span> (!visited.add(current)) <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> (v <span class="keyword">in</span> current.neighbors)</span><br><span class="line">        dfs(v)</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(from)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h5><p>成员函数是定义在一个类或对象里边的</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sample</span></span>() &#123;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> &#123; print(<span class="string">"Foo"</span>) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>成员函数可以用 . 的方式调用</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Sample.foo()</span><br></pre></td></tr></table></figure><p>更多请参看类和继承</p><h5 id="泛型函数"><a href="#泛型函数" class="headerlink" title="泛型函数"></a>泛型函数</h5><p>函数可以有泛型参数，样式是在函数后跟上尖括号。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> sigletonArray<span class="type">&lt;T&gt;</span><span class="params">(item: <span class="type">T</span>)</span></span>: Array&lt;T&gt; &#123;</span><br><span class="line"><span class="keyword">return</span> Array&lt;T&gt;(<span class="number">1</span>, &#123;item&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更多请参看泛型</p><h5 id="尾递归函数"><a href="#尾递归函数" class="headerlink" title="尾递归函数"></a>尾递归函数</h5><p>Kotlin 支持函数式编程的尾递归。这个允许一些算法可以通过循环而不是递归解决问题，从而避免了栈溢出。当函数被标记为 tailrec 时，编译器会优化递归，并用高效迅速的循环代替它。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">tailrec</span> <span class="function"><span class="keyword">fun</span> <span class="title">findFixPoint</span><span class="params">(x: <span class="type">Double</span> = <span class="number">1.0</span>)</span></span>: <span class="built_in">Double</span></span><br><span class="line">= <span class="keyword">if</span> (x == Math.cos(x)) x <span class="keyword">else</span> findFixPoint(Math.cos(x))</span><br></pre></td></tr></table></figure><p>这段代码计算的是数学上的余弦不动点。Math.cos 从 1.0 开始不断重复，直到值不变为止，结果是 0.7390851332151607 这段代码和下面的是等效的：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">findFixPoint</span><span class="params">()</span></span>: <span class="built_in">Double</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">1.0</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">val</span> y = Math.cos(x)</span><br><span class="line">        <span class="keyword">if</span> ( x == y ) <span class="keyword">return</span> y</span><br><span class="line">        x = y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 tailrec 修饰符必须在最后一个操作中调用自己。在递归调用代码后面是不允许有其它代码的，并且也不可以在 try/catch/finall 块中进行使用。当前的尾递归只在 JVM 的后端中可以用</p><h4 id="高阶函数与-lambda-表达式"><a href="#高阶函数与-lambda-表达式" class="headerlink" title="高阶函数与 lambda 表达式"></a>高阶函数与 lambda 表达式</h4><p>#####高阶函数</p><p>高阶函数就是可以接受函数作为参数并返回一个函数的函数。比如 lock() 就是一个很好的例子，它接收一个 lock 对象和一个函数，运行函数并释放 lock;</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> lock<span class="type">&lt;T&gt;</span><span class="params">(lock: <span class="type">Lock</span>, body: ()</span></span> -&gt; T ) : T &#123;</span><br><span class="line">    lock.lock()</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> body()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在解释一下上面的代码吧： body 有一个函数类型 () -&gt; T ,把它设想为没有参数并返回 T 类型的函数。它引发了内部的 try 函数块，并被 lock 保护，结果是通过 lock() 函数返回的。<br>如果我们想调用 lock() ，函数，我们可以传给它另一个函数做参数，参看函数参考：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">toBeSynchroized</span><span class="params">()</span></span> = sharedResource.operation()</span><br><span class="line"><span class="keyword">val</span> result = lock(lock, ::toBeSynchroized)</span><br></pre></td></tr></table></figure><p>其实最方便的办法是传递一个字面函数(通常是 lambda 表达式)：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> result = lock(lock, &#123;</span><br><span class="line">sharedResource.operation() &#125;)</span><br></pre></td></tr></table></figure><p>字面函数经常描述有更多细节，但为了继续本节，我们看一下更简单的预览吧：</p><blockquote><p>字面函数被包在大括号里<br>参数在 -&gt; 前面声明(参数类型可以省略)<br>函数体在 -&gt; 之后</p></blockquote><p>在 kotlin 中有一个约定，如果最后一个参数是函数，可以省略括号：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lock (lock) &#123;</span><br><span class="line">sharedResource.operation()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后一个高阶函数的例子是 map() (of MapReduce):</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T, R&gt;</span> List<span class="type">&lt;T&gt;</span>.<span class="title">map</span><span class="params">(transform: (<span class="type">T</span>)</span></span> -&gt; R):</span><br><span class="line">List&lt;R&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> result = arrayListOf&lt;R&gt;()</span><br><span class="line">    <span class="keyword">for</span> (item <span class="keyword">in</span> <span class="keyword">this</span>)</span><br><span class="line">    result.add(transform(item))</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数可以通过下面的方式调用</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> doubled = ints.map &#123;it -&gt; it * <span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure><p>如果字面函数只有一个参数，则声明可以省略，名字就是 it :</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ints map &#123;it * <span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure><p>这样就可以写LINQ-风格的代码了：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strings filter &#123;it.length == <span class="number">5</span>&#125; sortBy &#123;it&#125; map &#123;it.toUpperCase()&#125;</span><br></pre></td></tr></table></figure><h5 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h5><p>有些时候可以用 内联函数 提高高阶函数的性能。</p><h5 id="字面函数和函数表达式"><a href="#字面函数和函数表达式" class="headerlink" title="字面函数和函数表达式"></a>字面函数和函数表达式</h5><p>字面函数或函数表达式就是一个 “匿名函数”，也就是没有声明的函数，但立即作为表达式传递下去。想想下面的例子：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">max(strings, &#123;a, b -&gt; a.length &lt; b.length &#125;)</span><br></pre></td></tr></table></figure><p>max 函数就是一个高阶函数,它接受函数作为第二个参数。第二个参数是一个表达式所以本生就是一个函数，即字面函数。作为一个函数，相当于：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">compare</span><span class="params">(a: <span class="type">String</span>, b: <span class="type">String</span>)</span></span> : <span class="built_in">Boolean</span> = a.length &lt; b.length</span><br></pre></td></tr></table></figure><h5 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h5><p>一个函数要接受另一个函数作为参数，我们得给它指定一个类型。比如上面的max 定义是这样的：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> max<span class="type">&lt;T&gt;</span><span class="params">(collection: <span class="type">Collection</span>&lt;<span class="type">out</span> <span class="type">T</span>&gt;, less: (<span class="type">T</span>, T)</span></span> -&gt; <span class="built_in">Boolean</span></span><br><span class="line">): T? &#123;</span><br><span class="line">    <span class="keyword">var</span> max: T? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">for</span> (it <span class="keyword">in</span> collection)</span><br><span class="line">    <span class="keyword">if</span> (max == <span class="literal">null</span> || less(max!!, it))</span><br><span class="line">    max = it</span><br><span class="line">    <span class="keyword">return</span> max</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数 less 是 (T, T) -&gt; Boolean 类型，也就是接受俩个 T 类型参数返回一个 Boolean :如果第一个参数小于第二个则返回真。<br>在函数体第四行， less 是用作函数<br>一个函数类型可以像上面那样写，也可有命名参数，更多参看命名参数</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> compare: (x: T,y: T) -&gt; <span class="built_in">Int</span> = ...</span><br></pre></td></tr></table></figure><h5 id="函数文本语法"><a href="#函数文本语法" class="headerlink" title="函数文本语法"></a>函数文本语法</h5><p>函数文本的完全写法是下面这样的：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> sum = &#123;x: <span class="built_in">Int</span>,y: <span class="built_in">Int</span> -&gt; x + y&#125;</span><br></pre></td></tr></table></figure><p>函数文本总是在大括号里包裹着，在完全语法中参数声明是在括号内，类型注解是可选的，函数体是在 -&gt; 之后，像下面这样：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> sum: (<span class="built_in">Int</span>, <span class="built_in">Int</span>) -&gt; <span class="built_in">Int</span> = &#123;x, y -&gt; x+y &#125;</span><br></pre></td></tr></table></figure><p>函数文本有时只有一个参数。如果 kotlin 可以从它本生计算出签名，那么可以省略这个唯一的参数，并会通过 it 隐式的声明它：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ints.filter &#123;it &gt; <span class="number">0</span>&#125;<span class="comment">//这是 (it: Int) -&gt; Boolean 的字面意思</span></span><br></pre></td></tr></table></figure><p>注意如果一个函数接受另一个函数做为最后一个参数，该函数文本参数可以在括号内的参数列表外的传递。参看 callSuffix</p><h5 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h5><p>上面没有讲到可以指定返回值的函数。在大多数情形中，这是不必要的，因为返回值是可以自动推断的。然而，如果你需要自己指定，可以用函数表达式来做：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">fun</span><span class="params">(x: <span class="type">Int</span>, y: <span class="type">Int</span> )</span></span>: <span class="built_in">Int</span> = x + y</span><br></pre></td></tr></table></figure><p>函数表达式很像普通的函数声明，除了省略了函数名。它的函数体可以是一个表达式(像上面那样)或者是一个块：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">fun</span><span class="params">(x: <span class="type">Int</span>, y: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line"><span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数以及返回值和普通函数是一样的，如果它们可以从上下文推断出参数类型，则参数可以省略：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ints.filter(<span class="function"><span class="title">fun</span><span class="params">(item)</span></span> = item &gt; <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>返回值类型的推导和普通函数一样：函数返回值是通过表达式自动推断并被明确声明</p><p>注意函数表达式的参数总是在括号里传递的。 The shorthand syntax allowing to leave the function outside the parentheses works only for function literals.</p><p>字面函数和表达式函数的另一个区别是没有本地返回。没有 lable 的返回总是返回到 fun 关键字所声明的地方。这意味着字面函数内的返回会返回到一个闭合函数，而表达式函数会返回到函数表达式自身。</p><h5 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h5><p>一个字面函数或者表达式函数可以访问闭包，即访问自身范围外的声明的变量。不像 java 那样在闭包中的变量可以被捕获修改：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line">ins filter &#123;it &gt; <span class="number">0</span>&#125; forEach &#123;</span><br><span class="line">sum += it</span><br><span class="line">&#125;</span><br><span class="line">print(sum)</span><br></pre></td></tr></table></figure><h5 id="函数表达式扩展"><a href="#函数表达式扩展" class="headerlink" title="函数表达式扩展"></a>函数表达式扩展</h5><p>除了普通的功能，kotlin 支持扩展函数。这种方式对于字面函数和表达式函数都是适用的。它们最重要的使用是在 Type-safe Groovy-style builders。</p><p>表达式函数的扩展和普通的区别是它有接收类型的规范。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> sum = <span class="function"><span class="keyword">fun</span> <span class="built_in">Int</span>.<span class="params">(other: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> = <span class="keyword">this</span> + other</span><br></pre></td></tr></table></figure><p>接收类型必须在表达式函数中明确指定，但字面函数不用。字面函数可以作为扩展函数表达式，但只有接收类型可以通过上下文推断出来。<br>表达式函数的扩展类型是一个带接收者的函数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum : <span class="built_in">Int</span>.(other: <span class="built_in">Int</span>) -&gt; <span class="built_in">Int</span></span><br></pre></td></tr></table></figure><p>可以用 . 或前缀来使用这样的函数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.sum(<span class="number">2</span>)</span><br><span class="line"><span class="number">1</span> sum <span class="number">2</span></span><br></pre></td></tr></table></figure><h4 id="内联函数-1"><a href="#内联函数-1" class="headerlink" title="内联函数"></a>内联函数</h4><p>使用高阶函数带来了相应的运行时麻烦：每个函数都是一个对象，它捕获闭包，即这些变量可以在函数体内被访问。内存的分配，虚拟调用的运行都会带来开销但在大多数这种开销是可以通过内联文本函数避免。下面就是一个很好的例子。 lock() 函数可以很容易的在内联点调用。思考一下下面的例子：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lock(i) &#123; foo() &#125;</span><br></pre></td></tr></table></figure><p>(Instead of creating a function object for the parameter and generating a call)，编译器可以忽略下面的代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">lock.lock()</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">foo()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">lock.lock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这好像不是我们开始想要的<br>想要让编译器不这样做的话，我们需要用 inline 标记 lock() 函数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> lock<span class="type">&lt;T&gt;</span><span class="params">(lock: <span class="type">Lock</span>,body: ()</span></span>-&gt; T): T &#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>inline 标记即影响函数本身也影响传递进来的 lambda 函数：所有的这些都将被关联到调用点。<br>内联可能会引起生成代码增长，但我们可以合理的解决它(不要内联太大的函数)</p><h5 id="noinline"><a href="#noinline" class="headerlink" title="@noinline"></a>@noinline</h5><p>为了你想要一些 lambda 表达式传递给内联函数时是内联的，你可以给你的一些函数参数标记 @noinline 注解：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">(inlined: ()</span></span> -&gt; Uint, <span class="meta">@noinline</span> notInlined: () -&gt; <span class="built_in">Unit</span>) &#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内联的 lambda 只能在内联函数中调用，或者作为内联参数，但 @noinline 标记的可以通过任何我们喜欢的方式操控：存储在字段，( passed around etc)<br>注意如果内联函数没有内联的函数参数并且没有具体类型的参数，编译器会报警告，这样内联函数就没有什么优点的(如果你认为内联是必须的你可以忽略警告)</p><h5 id="返回到非局部"><a href="#返回到非局部" class="headerlink" title="返回到非局部"></a>返回到非局部</h5><p>在 kotlin 中，我们可以不加条件的使用 return 去退出一个命名函数或表达式函数。这意味这退出一个 lambda 函数，我们不得不使用标签，而且空白的 return在 lambda 函数中是禁止的，因为 lambda 函数不可以造一个闭合函数返回：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ordinaryFunction &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="comment">// 错误 不可以在这返回</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但如果 lambda 函数是内联传递的，则返回也是可以内联的，因此允许下面这样：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    inlineFunction &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意有些内联函数可以调用传递进来的 lambda 函数，但不是在函数体，而是在另一个执行的上下文中，比如局部对象或者一个嵌套函数。在这样的情形中，非局部的控制流也不允许在lambda 函数中。为了表明，lambda 参数需要有 InlineOptions.ONLY_LOCAL_RETURN 注解：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">f</span><span class="params">(inlineOptions(InlineOption.ONLY_LOCAL_RETURN)</span></span> body:() -&gt; <span class="built_in">Unit</span>) &#123;</span><br><span class="line">    <span class="keyword">val</span> f = <span class="keyword">object</span>: Runnable &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> = body()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内联 lambda 不允许用 break 或 continue ，但在以后的版本可能会支持。</p><h5 id="实例化参数类型"><a href="#实例化参数类型" class="headerlink" title="实例化参数类型"></a>实例化参数类型</h5><p>有时候我们需要访问传递过来的类型作为参数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> TreeNode.<span class="title">findParentOfType</span><span class="params">(clazz: <span class="type">Class</span>&lt;<span class="type">T</span>&gt;)</span></span>: T? &#123;</span><br><span class="line">    <span class="keyword">var</span> p = parent</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">null</span> &amp;&amp; !clazz.isInstance(p)) &#123;</span><br><span class="line">    p = p?.parent</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@suppress(<span class="meta-string">"UNCHECKED_CAST"</span>)</span></span><br><span class="line">    <span class="keyword">return</span> p <span class="keyword">as</span> T</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，我们创立了一颗树，并用反射检查它是否是某个特定类型。一切看起来很<br>好，但调用点就很繁琐了：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myTree.findParentOfType(javaClass&lt;MyTreeNodeType&gt;() )</span><br></pre></td></tr></table></figure><p>我们想要的仅仅是给这个函数传递一个类型，即像下面这样：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myTree.findParentOfType&lt;MyTreeNodeType&gt;()</span><br></pre></td></tr></table></figure><p>为了达到这个目的，内联函数支持具体化的类型参数，因此我们可以写成这样：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;<span class="keyword">reified</span> T&gt;</span> TreeNode.<span class="title">findParentOfType</span><span class="params">()</span></span>: T? &#123;</span><br><span class="line">    <span class="keyword">var</span> p = parent</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">null</span> &amp;&amp; p !<span class="keyword">is</span> T) &#123;</span><br><span class="line">    p = p?.parent</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p <span class="keyword">as</span> T</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们用 refied 修饰符检查类型参数，既然它可以在函数内部访问了，也就基本上接近普通函数了。因为函数是内联的，所以不许要反射，像 !is ｀as｀这样的操作都可以使用。同时，我们也可以像上面那样调用它了myTree.findParentOfType()<br>尽管在很多情况下会使用反射，我们仍然可以使用实例化的类型参数javaClass() 来访问它：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> methodsOf<span class="type">&lt;<span class="keyword">reified</span> T&gt;</span><span class="params">()</span></span> = javaClass&lt;T&gt;().getMethods()</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(s: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">println(methodsOf&lt;String&gt;().joinToString(<span class="string">'\n'</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>普通的函数(没有标记为内联的)不能有实例化参数。<br>更底层的解释请看spec document</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;函数和lambda表达式&quot;&gt;&lt;a href=&quot;#函数和lambda表达式&quot; class=&quot;headerlink&quot; title=&quot;函数和lambda表达式&quot;&gt;&lt;/a&gt;函数和lambda表达式&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;函数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;高级函数和lambda表达式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;内联函数&lt;/p&gt;
    
    </summary>
    
    
      <category term="learn" scheme="http://www.sanmaoliu.com/tags/learn/"/>
    
      <category term="Kotlin" scheme="http://www.sanmaoliu.com/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin Lenrning(4章)</title>
    <link href="http://www.sanmaoliu.com/2018/05/10/Kotlin-Learning3/"/>
    <id>http://www.sanmaoliu.com/2018/05/10/Kotlin-Learning3/</id>
    <published>2018-05-10T01:01:59.000Z</published>
    <updated>2018-05-10T02:20:22.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h3><ol><li>类和继承</li><li>属性和字段</li><li>接口</li><li>可见性修复</li><li>扩展</li><li>数据对象</li><li>泛型</li><li>嵌套类</li><li>枚举类</li><li>对象表达式和声明</li><li>代理模式</li><li>代理属性</li></ol><a id="more"></a><h4 id="类和继承"><a href="#类和继承" class="headerlink" title="类和继承"></a>类和继承</h4><h5 id="类"><a href="#类" class="headerlink" title="类"></a>类</h5><p>在 Kotlin 中类用 class 声明：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Invoice</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类的声明包含类名，类头(指定类型参数，主构造函数等等)，以及类主体，用大括号包裹。类头和类体是可选的；如果没有类体可以省略大括号。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Empty</span></span></span><br></pre></td></tr></table></figure><h5 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h5><p>在 Kotlin 中类可以有一个主构造函数以及多个二级构造函数。主构造函数是类头的一部分：跟在类名后面(可以有可选的类型参数)。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">constructor</span></span>(firstName: String)&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果主构造函数没有注解或可见性说明，则 constructor 关键字是可以省略：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(firstName: String)&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主构造函数不能包含任意代码。初始化代码可以放在以 init 做前缀的初始化块内</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span></span>(name: String)&#123;</span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">    logger,info(<span class="string">"Customer initialized with value <span class="subst">$&#123;name&#125;</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意主构造函数的参数可以用在初始化块内，也可以用在类的属性初始化声明处：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span></span>(name: String) &#123;</span><br><span class="line"><span class="keyword">val</span> customerKry = name.toUpperCase()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事实上，声明属性并在主构造函数中初始化,在 Kotlin 中有更简单的语法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(<span class="keyword">val</span> firstName: String, <span class="keyword">val</span> lastName: String, <span class="keyword">var</span> age: <span class="built_in">Int</span>)&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>像普通的属性，在主构造函数中的属性可以是可变或只读。<br>如果构造函数有注解或可见性声明，则 constructor 关键字是不可少的，并且可见性应该在前：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span> <span class="keyword">public</span> <span class="meta">@inject</span> <span class="keyword">constructor</span> </span>(name: String) &#123;...&#125;</span><br></pre></td></tr></table></figure><h5 id="二级构造函数"><a href="#二级构造函数" class="headerlink" title="二级构造函数"></a>二级构造函数</h5><p>类也可以有二级构造函数，需要加前缀 constructor:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(parent: Person) &#123;</span><br><span class="line">    parent.children.add(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果类有主构造函数，每个二级构造函数都要，或直接或间接通过另一个二级构造函数代理主构造函数。在同一个类中代理另一个构造函数使用 this 关键字：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(<span class="keyword">val</span> name: String) &#123;</span><br><span class="line">    <span class="keyword">constructor</span> (name: String, paret: Person) : <span class="keyword">this</span>(name) &#123;</span><br><span class="line">    parent.children.add(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果一个非抽象类没有声明构造函数(主构造函数或二级构造函数)，它会产生一个没有参数的构造函数。构造函数是 public 。如果你不想你的类有公共的构造函数，你就得声明一个空的主构造函数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DontCreateMe</span> <span class="keyword">private</span> <span class="keyword">constructor</span> </span>() &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：在 JVM 虚拟机中，如果主构造函数的所有参数都有默认值，编译器会生成一个附加的无参的构造函数，这个构造函数会直接使用默认值。这使得Kotlin 可以更简单的使用像 Jackson 或者 JPA 这样使用无参构造函数来创建类实例的库。</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span></span>(<span class="keyword">val</span> customerName: String = <span class="string">""</span>)</span><br></pre></td></tr></table></figure><h5 id="创建类的实例"><a href="#创建类的实例" class="headerlink" title="创建类的实例"></a>创建类的实例</h5><p>我们可以像使用普通函数那样使用构造函数创建类实例：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> invoice = Invoice()</span><br><span class="line"><span class="keyword">val</span> customer = Customer(<span class="string">"Joe Smith"</span>)</span><br></pre></td></tr></table></figure><p>注意 Kotlin 没有 new 关键字。</p><h5 id="类成员"><a href="#类成员" class="headerlink" title="类成员"></a>类成员</h5><p>类可以包含：</p><blockquote><p>构造函数和初始化代码块<br>函数<br>属性<br>内部类<br>对象声明</p></blockquote><h5 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h5><p>Kotin 中所有的类都有共同的父类 Any ，下面是一个没有父类声明的类：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span> // 隐式继承于 <span class="title">Any</span></span></span><br></pre></td></tr></table></figure><p><strong>Any</strong> 不是 java.lang.Object ；事实上它除了 equals() , hashCode() 以及 toString() 外没有任何成员了。<br>声明一个明确的父类，需要在类头后加冒号再加父类：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Base</span></span>(p: <span class="built_in">Int</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span></span>(p: <span class="built_in">Int</span>) : Base(p)</span><br></pre></td></tr></table></figure><p>如果类有主构造函数，则基类可以而且是必须在主构造函数中立即初始化。</p><p>如果类没有主构造函数，则必须在每一个构造函数中用 super 关键字初始化基类，或者在代理另一个构造函数做这件事。注意在这种情形中不同的二级构造函数可以调用基类不同的构造方法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyView</span> : <span class="type">View &#123;</span></span></span><br><span class="line">    <span class="keyword">constructor</span>(ctx: Context) : <span class="keyword">super</span>(ctx) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">constructor</span>(ctx: Context, attrs: AttributeSet) : <span class="keyword">super</span>(ctx,attrs) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>open 注解与java 中的 final相反:它允许别的类继承这个类。默认情形下，kotlin 中所有的类都是 final ,对应 Effective Java ：Design and document for inheritance or else prohibit it.</p><h5 id="复写成员"><a href="#复写成员" class="headerlink" title="复写成员"></a>复写成员</h5><p>像之前提到的，我们在 kotlin 中坚持做明确的事。不像 java ，kotlin 需要把可以复写的成员都明确注解出来，并且重写它们：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">v</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">nv</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span></span>() : Base() &#123;</span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">v</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于 Derived.v() 来说 override 注解是必须的。如果没有加的话，编译器会提示。如果没有 open 注解，像 Base.nv() ,在子类中声明一个同样的函数是不合法的，要么加 override 要么不要复写。在 final 类(就是没有open注解的类)中，open 类型的成员是不允许的。<br>标记为 override 的成员是 open的，它可以在子类中被复写。如果你不想被重写就要加 final:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">AnotherDerived</span></span>() : Base() &#123;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">v</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>等等！我现在怎么hack我的库？！<br>有个问题就是如何复写子类中那些作者不想被重写的类，下面介绍一些令人讨厌的方案。<br>我们认为这是不好的，原因如下：</p><blockquote><p>最好的实践建议你不应给做这些 hack<br>人们可以用其他的语言成功做到类似的事情<br>如果你真的想 hack 那么你可以在 java 中写好 hack 方案，然后在 kotlin 中调用 ，专业的构架可以很好的做到这一点</p></blockquote><h5 id="复写规则"><a href="#复写规则" class="headerlink" title="复写规则"></a>复写规则</h5><p>在 kotlin 中，实现继承通常遵循如下规则：如果一个类从它的直接父类继承了同一个成员的多个实现，那么它必须复写这个成员并且提供自己的实现(或许只是直接用了继承来的实现)。为表示使用父类中提供的方法我们用 super 表示:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">f</span> <span class="params">()</span></span> &#123; print(<span class="string">"A"</span>) &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">a</span><span class="params">()</span></span> &#123; print(<span class="string">"a"</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">f</span><span class="params">()</span></span> &#123; print(<span class="string">"B"</span>) &#125; <span class="comment">//接口的成员变量默认是 open 的</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">b</span><span class="params">()</span></span> &#123; print(<span class="string">"b"</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span>() : A() , B&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">f</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>&lt;A&gt;.f()<span class="comment">//调用 A.f()</span></span><br><span class="line">        <span class="keyword">super</span>&lt;B&gt;.f()<span class="comment">//调用 B.f()</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以同时从 A B 中继承方法，而且 C 继承 a() 或 b() 的实现没有任何问题，因为它们都只有一个实现。但是 f() 有俩个实现，因此我们在 C 中必须复写 f() 并且提供自己的实现来消除歧义。</p><h5 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h5><p>一个类或一些成员可能被声明成 abstract 。一个抽象方法在它的类中没有实现方法。记住我们不用给一个抽象类或函数添加 open 注解，它默认是带着的。<br>我们可以用一个抽象成员去复写一个带 open 注解的非抽象方法。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line"><span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">f</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Derived</span> : <span class="type">Base</span></span>() &#123;</span><br><span class="line"><span class="keyword">override</span> <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="伴随对象"><a href="#伴随对象" class="headerlink" title="伴随对象"></a>伴随对象</h5><p>在 kotlin 中不像 java 或者 C# 它没有静态方法。在大多数情形下，我们建议只用包<br>级别的函数。<br>如果你要写一个没有实例类就可以调用的方法，但需要访问到类内部(比如说一个工厂方法)，你可以把它写成它所在类的一个成员(you can write it as a member of an object declaration inside that class)<br>更高效的方法是，你可以在你的类中声明一个伴随对象，这样你就可以像 java/c#那样把它当做静态方法调用，只需要它的类名做一个识别就好了</p><h5 id="密封类"><a href="#密封类" class="headerlink" title="密封类"></a>密封类</h5><p>密封类用于代表严格的类结构，值只能是有限集合中的某中类型，不可以是任何其它类型。这就相当于一个枚举类的扩展：枚举值集合的类型是严格限制的，但每个枚举常量只有一个实例，而密封类的子类可以有包含不同状态的多个实例。<br>声明密封类需要在 class 前加一个 sealed 修饰符。密封类可以有子类但必须全部嵌套在密封类声明内部。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">class</span> <span class="title">Expr</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Const</span></span>(<span class="keyword">val</span> number: <span class="built_in">Double</span>) : Expr()</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Sum</span></span>(<span class="keyword">val</span> e1: Expr, <span class="keyword">val</span> e2: Expr) : Expr()</span><br><span class="line">    <span class="keyword">object</span> NotANumber : Expr()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意密封类子类的扩展可以在任何地方，不必在密封类声明内部进行。<br>使用密封类的最主要的的好处体现在你使用 when 表达式。可以确保声明可以覆盖到所有的情形，不需要再使用 else 情形。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">eval</span><span class="params">(expr: <span class="type">Expr</span>)</span></span>: <span class="built_in">Double</span> = <span class="keyword">when</span>(expr) &#123;</span><br><span class="line">    <span class="keyword">is</span> Const -&gt; expr.number</span><br><span class="line">    <span class="keyword">is</span> Sum -&gt; eval(expr.e1) + eval(expr.e2)</span><br><span class="line">    NotANumber -&gt; <span class="built_in">Double</span>.NaN</span><br><span class="line">    <span class="comment">// the `else` clause is not required because we've covered all the cases</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="属性和字段"><a href="#属性和字段" class="headerlink" title="属性和字段"></a>属性和字段</h4><h5 id="属性声明"><a href="#属性声明" class="headerlink" title="属性声明"></a>属性声明</h5><p>在 Kotlin 中类可以有属性，我们可以使用 var 关键字声明可变属性，或者用 val 关键字声明只读属性。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Address</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> name: String = ...</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> street: String = ...</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> city: String = ...</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> state: String? = ...</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> zip: String = ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以像使用 java 中的字段那样,通过名字直接使用一个属性：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">copyAddress</span><span class="params">(address: <span class="type">Address</span>)</span></span> : Address &#123;</span><br><span class="line">    <span class="keyword">val</span> result = Address() <span class="comment">//在 kotlin 中没有 new 关键字</span></span><br><span class="line">    result.name = address.name <span class="comment">//accessors are called</span></span><br><span class="line">    result.street = address.street</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Getter-和-Setter"><a href="#Getter-和-Setter" class="headerlink" title="Getter 和 Setter"></a>Getter 和 Setter</h5><p>声明一个属性的完整语法如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> &lt;propertyName&gt;: &lt;PropertyType&gt; [ = &lt;property_initializer&gt; ]</span><br><span class="line">    &lt;getter&gt;</span><br><span class="line">    &lt;setter&gt;</span><br></pre></td></tr></table></figure><p>语法中的初始化语句，getter 和 setter 都是可选的。如果属性类型可以从初始化语句或者类的成员函数中推断出来,那么他的类型也是忽略的。<br>例子：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> allByDefault: <span class="built_in">Int</span>? <span class="comment">// 错误: 需要一个初始化语句, 默认实现了 getter和 setter 方法</span></span><br><span class="line"><span class="keyword">var</span> initialized = <span class="number">1</span> <span class="comment">// 类型为 Int, 默认实现了 getter 和 setter</span></span><br></pre></td></tr></table></figure><p>只读属性的声明语法和可变属性的声明语法相比有两点不同: 它以 val 而不是 var 开头，不允许 setter 函数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> simple: <span class="built_in">Int</span>? <span class="comment">// 类型为 Int ，默认实现 getter ，但必须在构造函数中初始化</span></span><br><span class="line"><span class="keyword">val</span> inferredType = <span class="number">1</span> <span class="comment">// 类型为 Int 类型,默认实现 getter</span></span><br></pre></td></tr></table></figure><p>我们可以像写普通函数那样在属性声明中自定义的访问器，下面是一个自定义的getter 的例子:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isEmpty: <span class="built_in">Boolean</span></span><br><span class="line"><span class="keyword">get</span>() = <span class="keyword">this</span>.size == <span class="number">0</span></span><br></pre></td></tr></table></figure><p>下面是一个自定义的setter:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stringRepresentation: String</span><br><span class="line">    <span class="keyword">get</span>() = <span class="keyword">this</span>.toString()</span><br><span class="line">    <span class="keyword">set</span> (value) &#123;</span><br><span class="line">    setDataFormString(value) <span class="comment">// 格式化字符串,并且将值重新赋值给其他元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了方便起见,setter 方法的参数名是value,你也可以自己任选一个自己喜欢的名称.<br>如果你需要改变一个访问器的可见性或者给它添加注解，但又不想改变默认的实现，那么你可以定义一个不带函数体的访问器:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> settVisibilite: String = <span class="string">"abc"</span><span class="comment">//非空类型必须初始化</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">set</span> <span class="comment">// setter 是私有的并且有默认的实现</span></span><br><span class="line"><span class="keyword">var</span> setterVithAnnotation: Any?</span><br><span class="line"><span class="meta">@Inject</span> <span class="keyword">set</span> <span class="comment">// 用 Inject 注解 setter</span></span><br></pre></td></tr></table></figure><h5 id="备用字段"><a href="#备用字段" class="headerlink" title="备用字段"></a>备用字段</h5><p>在 kotlin 中类不可以有字段。然而当使用自定义的访问器时有时候需要备用字段。出于这些原因 kotlin 使用 field 关键词提供了自动备用字段</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> counter = <span class="number">0</span> <span class="comment">//初始化值会直接写入备用字段</span></span><br><span class="line">    <span class="keyword">set</span>(value) &#123;</span><br><span class="line">        <span class="keyword">if</span> (value &gt;= <span class="number">0</span>)</span><br><span class="line">        field = value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>field 关键词只能用于属性的访问器.<br>编译器会检查访问器的代码,如果使用了备用字段(或者访问器是默认的实现逻辑)，就会自动生成备用字段,否则就不会.<br>比如下面的例子中就不会有备用字段：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> isEmpty: <span class="built_in">Boolean</span></span><br><span class="line"><span class="keyword">get</span>() = <span class="keyword">this</span>.size == <span class="number">0</span></span><br></pre></td></tr></table></figure><h5 id="备用属性"><a href="#备用属性" class="headerlink" title="备用属性"></a>备用属性</h5><p>如果你想要做一些事情但不适合这种 “隐含备用字段” 方案，你可以试着用备用属性的方式：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> _table: Map&lt;String, <span class="built_in">Int</span>&gt;? = <span class="literal">null</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">val</span> table: Map&lt;String, <span class="built_in">Int</span>&gt;</span><br><span class="line"><span class="keyword">get</span>() &#123;</span><br><span class="line"><span class="keyword">if</span> (_table == <span class="literal">null</span>)</span><br><span class="line">_table = HashMap() <span class="comment">//参数类型是推导出来的</span></span><br><span class="line"><span class="keyword">return</span> _table ?: <span class="keyword">throw</span> AssertionError(<span class="string">"Set to null by another thread"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>综合来讲，这些和 java 很相似，可以避免函数访问私有属性而破坏它的结构</p><h5 id="编译时常量"><a href="#编译时常量" class="headerlink" title="编译时常量"></a>编译时常量</h5><p>那些在编译时就能知道具体值的属性可以使用 const 修饰符标记为 编译时常量.这种属性需要同时满足以下条件:</p><ul><li>Top-level or member of an object</li><li>以 String 或基本类型进行初始化</li><li>没有自定义getter</li></ul><p>这种属性可以被当做注解使用:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">val</span> SUBSYSTEM_DEPRECATED: String = <span class="string">"This subsystem is deprecated"</span></span><br><span class="line"><span class="meta">@Deprected(SUBSYSTEM_DEPRECATED)</span> <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> &#123; ... &#125;</span><br></pre></td></tr></table></figure><h5 id="延迟初始化属性"><a href="#延迟初始化属性" class="headerlink" title="延迟初始化属性"></a>延迟初始化属性</h5><p>通常,那些被定义为拥有非空类型的属性,都需要在构造器中初始化.但有时候这并没有那么方便.例如在单元测试中,属性应该通过依赖注入进行初始化, 或者通过一个setup 方法进行初始化.在这种条件下,你不能在构造器中提供一个非空的初始化语句,但是你仍然希望在访问这个属性的时候,避免非空检查.<br>为了处理这种情况,你可以为这个属性加上 lateinit 修饰符</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> subject: TestSubject</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@SetUp</span> <span class="function"><span class="keyword">fun</span> <span class="title">setup</span><span class="params">()</span></span> &#123;</span><br><span class="line">    subject = TestSubject()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span> <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    subject.method()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个修饰符只能够被用在类的 var 类型的可变属性定义中,不能用在构造方法中.并且属性不能有自定义的 getter 和 setter访问器.这个属性的类型必须是非空的,同样也不能为一个基本类型.<br>在一个延迟初始化的属性初始化前访问他,会导致一个特定异常,告诉你访问的时候值还没有初始化.</p><h5 id="复写属性"><a href="#复写属性" class="headerlink" title="复写属性"></a>复写属性</h5><p>参看复写成员</p><h5 id="代理属性"><a href="#代理属性" class="headerlink" title="代理属性"></a>代理属性</h5><p>最常见的属性就是从备用属性中读（或者写）。另一方面，自定义的 getter 和setter 可以实现属性的任何操作。有些像懒值( lazy values )，根据给定的关键字从map 中读出，读取数据库，通知一个监听者等等，像这些操作介于 getter setter 模式之间。<br>像这样常用操作可以通过代理属性作为库来实现。</p><h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><p>Kotlin 的接口很像 java 8。它们都可以包含抽象方法，以及方法的实现。和抽象类不同的是，接口不能保存状态。可以有属性但必须是抽象的，或者提供访问器的实现。<br>接口用关键字 interface 来定义：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">bar</span><span class="params">()</span></span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//函数体是可选的</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="接口的实现"><a href="#接口的实现" class="headerlink" title="接口的实现"></a>接口的实现</h5><p>一个类或对象可以实现一个或多个接口</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> : <span class="type">MyInterface &#123;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">bar</span> <span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//函数体</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>#####接口中的属性</p><p>可以在接口中申明属性。接口中的属性要么是抽象的，要么提供访问器的实现。接口属性不可以有后备字段。而且访问器不可以引用它们。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyInterface</span> </span>&#123;</span><br><span class="line">    <span class="keyword">val</span> property: <span class="built_in">Int</span> <span class="comment">// abstract</span></span><br><span class="line">    <span class="keyword">val</span> propertyWithImplementation: String</span><br><span class="line">    <span class="keyword">get</span>() = <span class="string">"foo"</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    print(property)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> : <span class="type">MyInterface &#123;</span></span></span><br><span class="line"><span class="keyword">override</span> <span class="keyword">val</span> property: <span class="built_in">Int</span> = <span class="number">29</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="解决重写冲突"><a href="#解决重写冲突" class="headerlink" title="解决重写冲突"></a>解决重写冲突</h5><p>当我们在父类中声明了许多类型，有可能出现一个方法的多种实现。比如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> &#123; print(<span class="string">"A"</span>) &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">bar</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> &#123; print(<span class="string">"B"</span>) &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">bar</span><span class="params">()</span></span> &#123; print(<span class="string">"bar"</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> : <span class="type">A &#123;</span></span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">bar</span><span class="params">()</span></span> &#123; print(<span class="string">"bar"</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> : <span class="type">A</span>, <span class="type">B &#123;</span></span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>&lt;A&gt;.foo()</span><br><span class="line">        <span class="keyword">super</span>&lt;B&gt;.foo()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A B 接口都有声明了 foo() bar() 函数。它们都实现了 foo() 方法，但只有 B 实现了bar() ,bar() 在 A 中并没有声明它是抽象的，这是因为在接口中如果函数没有函数体，那么默认是抽像的。现在，如果我们从 A 中派生一个 C 实体类，显然我们需要重写 bar() ，并实现它。而我们从 A 和 B 派生一个 D ，我们不用重写 bar() 方法，因为我们的一个继承中有一个已经实现了它。但我们继承了两个 foo() 的实现，因此编译器不知道应该选哪个，并强制我们重写 foo() 并且明确指出我们想怎么实现。</p><h4 id="可见性修饰词"><a href="#可见性修饰词" class="headerlink" title="可见性修饰词"></a>可见性修饰词</h4><p>类，对象，接口，构造函数，属性以及它们的 setter 方法都可以有可见性修饰词。(getter 方法作为属性时都是可见性)。在 Kotlin 中有四种修饰<br>词： private , protected , internal ,以及 public 。默认的修饰符是 public 。 下面将解释不同类型的声明作用域。</p><h5 id="包"><a href="#包" class="headerlink" title="包"></a>包</h5><p>函数，属性和类，对象和接口可以在 “top-level” 声明：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> foo</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">baz</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">bar</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果没有指明任何可见性修饰词，默认使用 public ,这意味着你的声明在任何地方都可见；<br>如果你声明为 private ，则只在包含声明的文件中可见；<br>如果用 internal 声明，则在同一模块中的任何地方可见；<br>protected 在 “top-level” 中不可以使用</p></blockquote><p>例子：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> foo</span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> &#123;&#125; <span class="comment">// visible inside example.kt</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">var</span> bar: <span class="built_in">Int</span> = <span class="number">5</span> <span class="comment">// property is visible everywhere</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">set</span> <span class="comment">// setter is visible only in example.kt</span></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">val</span> baz = <span class="number">6</span> <span class="comment">// visible inside the same module</span></span><br></pre></td></tr></table></figure><h5 id="类和接口"><a href="#类和接口" class="headerlink" title="类和接口"></a>类和接口</h5><p>当在类中声明时：</p><blockquote><p>private 只在该类(以及它的成员)中可见</p><p>protected 和 private 一样但在子类中也可见<br>internal 在本模块的所有可以访问到声明区域的均可以访问该类的所有<br>internal 成员 ( internal — any client inside this module who sees the declaring class sees its internal members;)<br>public 任何地方可见 (public — any client who sees the declaring class sees its public members.)</p></blockquote><p>java 使用者注意：外部类不可以访问内部类的 private 成员。</p><p>例子：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> a = <span class="number">1</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">val</span> b = <span class="number">2</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">val</span> c = <span class="number">3</span></span><br><span class="line">    <span class="keyword">val</span> d = <span class="number">4</span> <span class="comment">// public by default</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="class"><span class="keyword">class</span> <span class="title">Nested</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> e: <span class="built_in">Int</span> = <span class="number">5</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Subclass</span> : <span class="type">Outer</span></span>() &#123;</span><br><span class="line">    <span class="comment">// a is not visible</span></span><br><span class="line">    <span class="comment">// b, c and d are visible // Nested and e are visible</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Unrelated</span></span>(o: Outer) &#123;</span><br><span class="line">    <span class="comment">// o.a, o.b are not visible</span></span><br><span class="line">    <span class="comment">// o.c and o.d are visible (same module)</span></span><br><span class="line">    <span class="comment">// Outer.Nested is not visible, and Nested::e is not visible either</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="构造函数-1"><a href="#构造函数-1" class="headerlink" title="构造函数"></a>构造函数</h5><p>通过下面的语法来指定主构造函数(必须显示的使用 constructor 关键字)的可见性：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">private</span> <span class="keyword">constructor</span></span>(a: <span class="built_in">Int</span>) &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>这里构造函数是 private 。所有的构造函数默认是 public ,实际上只要类是可见的它们就是可见的 (注意 internal 类型的类中的 public 属性只能在同一个模块内才可以访问)</p><h5 id="局部声明"><a href="#局部声明" class="headerlink" title="局部声明"></a>局部声明</h5><p>局部变量，函数和类是不允许使用修饰词的</p><h5 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h5><p>internal 修饰符是指成员的可见性是只在同一个模块中才可见的。模块在 Kotlin<br>中就是一系列的 Kotlin 文件编译在一起：</p><ul><li>an IntelliJ IDEA module;</li><li>a Maven or Gradle project;</li><li>a set of files compiled with one invocation of the Ant task.</li></ul><h4 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h4><p>与 C# 和 Gosu 类似, Kotlin 也提供了一种,可以在不继承父类，也不使用类似装饰器这样的设计模式的情况下对指定类进行扩展。我们可以通过一种叫做扩展的特殊声明来实现他。Kotlin 支持函数扩展和属性扩展。</p><h5 id="函数扩展"><a href="#函数扩展" class="headerlink" title="函数扩展"></a>函数扩展</h5><p>为了声明一个函数扩展，我们需要在函数前加一个接收者类型作为前缀。下面我们会为 MutableList 添加一个 swap 函数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> MutableList<span class="type">&lt;Int&gt;</span>.<span class="title">swap</span><span class="params">(x: <span class="type">Int</span>, y: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> temp = <span class="keyword">this</span>[x] <span class="comment">// this 对应 list</span></span><br><span class="line">    <span class="keyword">this</span>[x] = <span class="keyword">this</span>[y]</span><br><span class="line">    <span class="keyword">this</span>[y] = tmp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在扩展函数中的 this 关键字对应接收者对象。现在我们可以在任何MutableList 实例中使用这个函数了：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> l = mutableListOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">l.swap(<span class="number">0</span>, <span class="number">2</span>)<span class="comment">// 在 `swap()` 函数中 `this` 持有的值是 `l`</span></span><br></pre></td></tr></table></figure><p>当然，这个函数对任意的 MutableList 都是适用的，而且我们可以把它变的通用：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> MutableList<span class="type">&lt;T&gt;</span>.<span class="title">swap</span><span class="params">(x: <span class="type">Int</span>, y: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> tmp = <span class="keyword">this</span>[x] <span class="comment">// 'this' corresponds to the list</span></span><br><span class="line">    <span class="keyword">this</span>[x] = <span class="keyword">this</span>[y]</span><br><span class="line">    <span class="keyword">this</span>[y] = tmp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在函数名前声明了通用类型，从而使它可以接受任何参数。参看泛型函数。</p><h5 id="扩展是被静态解析的"><a href="#扩展是被静态解析的" class="headerlink" title="扩展是被静态解析的"></a>扩展是被静态解析的</h5><p>扩展实际上并没有修改它所扩展的类。定义一个扩展，你并没有在类中插入一个新的成员，只是让这个类的实例对象能够通过 . 调用新的函数。<br>需要强调的是扩展函数是静态分发的，举个例子,它们并不是接受者类型的虚拟方法。这意味着扩展函数的调用时由发起函数调用的表达式的类型决定的，而不是在运行时动态获得的表达式的类型决定。比如</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>: <span class="type">C</span></span>()</span><br><span class="line"><span class="function"><span class="keyword">fun</span> C.<span class="title">foo</span><span class="params">()</span></span> = <span class="string">"c"</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> D.<span class="title">foo</span><span class="params">()</span></span> = <span class="string">"d"</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printFoo</span><span class="params">(c: <span class="type">C</span>)</span></span> &#123;</span><br><span class="line">println(c.foo())</span><br><span class="line">&#125;</span><br><span class="line">printFoo(D())</span><br></pre></td></tr></table></figure><p>这个例子会输出 c ，因为这里扩展函数的调用决定于声明的参数 c 的类型，也就是 C 。<br>如果有同名同参数的成员函数和扩展函数，调用的时候必然会使用成员函数，比如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> &#123; println(<span class="string">"member"</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> C.<span class="title">foo</span><span class="params">()</span></span> &#123; println(<span class="string">"extension"</span>) &#125;</span><br></pre></td></tr></table></figure><p>当我们对C的实例c调用 c.foo() 的时候,他会输出”member”,而不是”extension”</p><p>但你可以用不同的函数签名通过扩展函数的方式重载函数的成员函数，比如下面这样：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> &#123; println(<span class="string">"number"</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> C.<span class="title">foo</span><span class="params">(i:<span class="type">Int</span>)</span></span> &#123; println(<span class="string">"extention"</span>) &#125;</span><br></pre></td></tr></table></figure><p>C().foo(1) 的调用会打印 “extentions”。</p><h5 id="可空的接收者"><a href="#可空的接收者" class="headerlink" title="可空的接收者"></a>可空的接收者</h5><p>注意扩展可以使用空接收者类型进行定义。这样的扩展使得，即使是一个空对象仍然可以调用该扩展，然后在扩展的内部进行 this == null 的判断。这样你就可以在 Kotlin 中任意调用 toString() 方法而不进行空指针检查：空指针检查延后到扩展函数中完成。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> Any?.<span class="title">toString</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == <span class="literal">null</span>) <span class="keyword">return</span> <span class="string">"null"</span></span><br><span class="line">    <span class="comment">// 在空检查之后，`this` 被自动转为非空类型，因此 toString() 可以被解析到任何类的成员函数中</span></span><br><span class="line">    <span class="keyword">return</span> toString()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="属性扩展"><a href="#属性扩展" class="headerlink" title="属性扩展"></a>属性扩展</h5><p>和函数类似， Kotlin 也支持属性扩展：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> &lt;T&gt; List&lt;T&gt;.lastIndex: <span class="built_in">Int</span></span><br><span class="line"><span class="keyword">get</span>() = size-<span class="number">1</span></span><br></pre></td></tr></table></figure><p>注意，由于扩展并不会真正给类添加了成员属性，因此也没有办法让扩展属性拥有一个备份字段.这也是为什么初始化函数不允许有扩展属性。扩展属性只能够通过明确提供 getter 和 setter方法来进行定义.</p><p>例子：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> Foo.bar = <span class="number">1</span> <span class="comment">//error: initializers are not allowed for extension properties</span></span><br></pre></td></tr></table></figure><h5 id="伴随对象扩展"><a href="#伴随对象扩展" class="headerlink" title="伴随对象扩展"></a>伴随对象扩展</h5><p>如果一个对象定义了伴随对象，你也可以给伴随对象添加扩展函数或扩展属性：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line"><span class="keyword">companion</span> <span class="keyword">object</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> MyClass.Companion.<span class="title">foo</span><span class="params">()</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和普通伴随对象的成员一样，它们可以只用类的名字就调用：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyClass.foo()</span><br></pre></td></tr></table></figure><h5 id="扩展的域"><a href="#扩展的域" class="headerlink" title="扩展的域"></a>扩展的域</h5><p>大多数时候我们在 top level 定义扩展，就在包下面直接定义：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> foo.bar</span><br><span class="line"><span class="function"><span class="keyword">fun</span> Baz.<span class="title">goo</span><span class="params">()</span></span> &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>为了在除声明的包外使用这个扩展，我们需要在 import 时导入：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example,usage</span><br><span class="line"><span class="keyword">import</span> foo.bar.goo <span class="comment">// 导入所有名字叫 "goo" 的扩展</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">import</span> foo.bar.* <span class="comment">// 导入foo.bar包下得所有数据</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">usage</span><span class="params">(baz: <span class="type">Baz</span>)</span></span> &#123;</span><br><span class="line">baz.goo()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h5><p>在 java 中，我们通常使用一系列名字为 “*Utils” 的类:<br>FileUtils , StringUtils 等等。很有名的 java.util.Collections 也是其中一员的，但我们不得不像下面这样使用他们：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java</span></span><br><span class="line">Collections.swap(list, Collections.binarySearch(list, Collections.max(otherList)), Collections.max(list))</span><br></pre></td></tr></table></figure><p>由于这些类名总是不变的。我们可以使用静态导入并这样使用：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swap(list, binarySearch(list, max(otherList)), max(list))</span><br></pre></td></tr></table></figure><p>这样就好很多了，但这样我们就只能从 IDE 自动完成代码那里获得很少或得不到帮助信息。如果我们可以像下面这样那么就好多了</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.swap(list.binarySearch(otherList.max()), list.max())</span><br></pre></td></tr></table></figure><p>但我们又不想在 List 类中实现所有可能的方法。这就是扩展带来的好处。</p><h4 id="数据对象"><a href="#数据对象" class="headerlink" title="数据对象"></a>数据对象</h4><h5 id="数据类"><a href="#数据类" class="headerlink" title="数据类"></a>数据类</h5><p>我们经常创建一个只保存数据的类。在这样的类中一些函数只是机械的对它们持有的数据进行一些推导。在 kotlin 中这样的类称之为 data 类，用 data 标注:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> age: <span class="built_in">Int</span>)</span><br></pre></td></tr></table></figure><p>编译器会自动根据主构造函数中声明的所有属性添加如下方法：</p><blockquote><p>equals() / hashCode 函数<br>toString 格式是 “User(name=john, age=42)”<br>compontN()functions 对应按声明顺序出现的所有属性<br>copy() 函数</p></blockquote><p>如果在类中明确声明或从基类继承了这些方法，编译器不会自动生成。<br>为确保这些生成代码的一致性，并实现有意义的行为，数据类要满足下面的要求：<br>注意如果构造函数参数中没有 val 或者 var ，就不会在这些函数中出现；</p><blockquote><p>主构造函数应该至少有一个参数；<br>主构造函数的所有参数必须标注为 val 或者 var ；<br>数据类不能是 abstract，open，sealed，或者 inner ；<br>数据类不能继承其它的类（但可以实现接口）。<br>在 JVM 中如果构造函数是无参的，则所有的属性必须有默认的值，(参看Constructors);<br>data class User(val name: String = “”, val age: Int = 0)</p></blockquote><h5 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h5><p>我们经常会对一些属性做修改但想要其他部分不变。这就是 copy() 函数的由来。在上面的 User 类中，实现起来应该是这样：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">copy</span><span class="params">(name: <span class="type">String</span> = this.name, age: <span class="type">Int</span> = this.age)</span></span> = User(name, age)</span><br></pre></td></tr></table></figure><p>有了 copy 我们就可以像下面这样写了：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> jack = User(name = <span class="string">"jack"</span>, age = <span class="number">1</span>)</span><br><span class="line"><span class="keyword">val</span> olderJack = jack.copy(age = <span class="number">2</span>)</span><br></pre></td></tr></table></figure><h5 id="数据类和多重声明"><a href="#数据类和多重声明" class="headerlink" title="数据类和多重声明"></a>数据类和多重声明</h5><p>组件函数允许数据类在多重声明中使用：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> jane = User(<span class="string">"jane"</span>, <span class="number">35</span>)</span><br><span class="line"><span class="keyword">val</span> (name, age) = jane</span><br><span class="line">println(<span class="string">"<span class="variable">$name</span>, <span class="variable">$age</span> years of age"</span>) <span class="comment">//打印出 "Jane, 35 years of age"</span></span><br></pre></td></tr></table></figure><h5 id="标准数据类"><a href="#标准数据类" class="headerlink" title="标准数据类"></a>标准数据类</h5><p>标准库提供了 Pair 和 Triple 。在大多数情形中，命名数据类是更好的设计选择，因为这样代码可读性更强而且提供了有意义的名字和属性。</p><h4 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h4><p>像 java 一样，Kotlin 中可以拥有类型参数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span>&lt;<span class="type">T</span>&gt;</span>(t: T)&#123;</span><br><span class="line"><span class="keyword">var</span> value = t</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通常来说，创建一个这样类的实例，我们需要提供类型参数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> box: Box&lt;<span class="built_in">Int</span>&gt; = Box&lt;<span class="built_in">Int</span>&gt;(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>但如果类型有可能是推断的，比如来自构造函数的参数或者通过其它的一些方式，一个可以忽略类型的参数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> box = Box(<span class="number">1</span>)<span class="comment">//1是 Int 型，因此编译器会推导出我们调用的是 Box&lt;Int&gt;</span></span><br></pre></td></tr></table></figure><h5 id="变动"><a href="#变动" class="headerlink" title="变动"></a>变动</h5><p>java 类型系统最狡猾的一部分就是通配符类型。但 kotlin 没有，代替它的是两种其它的东西：声明变化和类型预测(declaration-site variance and type projections)。<br>首先，我们想想为什么 java 需要这些神秘的通配符。这个问题在Effective Java,条目18中是这样解释的：使用界限通配符增加 API 的灵活性。首先 java 中的泛型是不变的，这就意味着 List 不是 List 的子类型。为什么呢，如果 List 不是不变的，就会引发下面的问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java</span></span><br><span class="line">List&lt;String&gt; strs = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">List&lt;Object&gt; objs = strs; <span class="comment">// !!! The cause of the upcoming problem sits here. Java prohibits this!</span></span><br><span class="line">objs.add(<span class="number">1</span>); <span class="comment">// Here we put an Integer into a list of Strings</span></span><br><span class="line">String s = strs.get(<span class="number">0</span>); <span class="comment">// !!! ClassCastException: Cannot cast Integer to String</span></span><br></pre></td></tr></table></figure><p>因此 java 禁止了这样的事情来保证运行时安全。但这有些其它影响。比如， Collection 接口的 addAll() 方法。这个方法的签名在哪呢？直观来讲是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt; ... </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addAdd</span><span class="params">(Collection&lt;E&gt; items)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但接下来我们就不能做下面这些简单事情了：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java</span></span><br><span class="line">void copyAll(Collection&lt;Object&gt; to, Collection&lt;String&gt; from)&#123;</span><br><span class="line">to.addAll(from);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是为什么 addAll() 的签名是下面这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt; ... </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addAll</span><span class="params">(Colletion&lt;? extend E&gt; items)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个通配符参数 ? extends T 意味着这个方法接受一些 T 类型的子类而非 T 类型本身。这就是说我们可以安全的读 T’s (这里表示 T 子类元素的集合)，但不能写，因为我们不知道 T 的子类究竟是什么样的，针对这样的限制，我们很想要这样的行为： Collection 是 Collection 的子类。</p><p>In “clever words”, the wildcard with an extends-bound (upper bound) makes the type covariant.<br>The key to understanding why this trick works is rather simple: if you can only take items from a collection, then using a collection of Strings and reading Objects from it is fine. Conversely, if you can only put items into the collection, it’s OK to take a collection of Objects and put Strings into it: in Java we have List a supertype of List.</p><h4 id="嵌套类"><a href="#嵌套类" class="headerlink" title="嵌套类"></a>嵌套类</h4><p>类可以嵌套在其他类中</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> bar: <span class="built_in">Int</span> = <span class="number">1</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Nested</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> = <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">val</span> demo = Outer.Nested().foo() <span class="comment">//==2</span></span><br></pre></td></tr></table></figure><h5 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h5><p>类可以标记为 inner 这样就可以访问外部类的成员。内部类拥有外部类的一个对象引用：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> bar: <span class="built_in">Int</span> = <span class="number">1</span></span><br><span class="line">    <span class="keyword">inner</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> = bar</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">val</span> demo = Outer().Inner().foo() <span class="comment">//==1</span></span><br></pre></td></tr></table></figure><h5 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h5><p>匿名内部类的实例是通过 对象表达式 创建的：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">window.addMouseListener(<span class="keyword">object</span>: MouseAdapter() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">mouseClicked</span><span class="params">(e: <span class="type">MouseEvent</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">mouseEntered</span><span class="params">(e: <span class="type">MouseEvent</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>如果对象是函数式的 java 接口的实例（比如只有一个抽象方法的 java 接口），你可以用一个带接口类型的 lambda 表达式创建它。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> listener = ActionListener &#123; println(<span class="string">"clicked"</span>) &#125;</span><br></pre></td></tr></table></figure><h4 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h4><p>枚举类最基本的用法就是实现类型安全的枚举</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">Direction</span> </span>&#123;</span><br><span class="line">NORTH,SOUTH,WEST</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个自举常量都是一个对象。枚举常量通过逗号分开。</p><h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><p>因为每个枚举都是枚举类的一个实例，它们是可以初始化的。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">Color</span></span>(<span class="keyword">val</span> rgb: <span class="built_in">Int</span>) &#123;</span><br><span class="line">    RED(<span class="number">0xFF0000</span>),</span><br><span class="line">    GREEN(<span class="number">0x00FF00</span>),</span><br><span class="line">    BLUE(<span class="number">0x0000FF</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="匿名类"><a href="#匿名类" class="headerlink" title="匿名类"></a>匿名类</h5><p>枚举实例也可以声明它们自己的匿名类</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">ProtocolState</span> </span>&#123;</span><br><span class="line">    WAITING &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">signal</span><span class="params">()</span></span> = Taking</span><br><span class="line">    &#125;,</span><br><span class="line">    Taking&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">signal</span><span class="params">()</span></span> = WAITING</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">signal</span><span class="params">()</span></span>: ProtocolState</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以有对应的方法，以及复写基本方法。注意如果枚举定义了任何成员，你需要像在 java 中那样用分号 ; 把枚举常量定义和成员定义分开。</p><h5 id="使用枚举常量"><a href="#使用枚举常量" class="headerlink" title="使用枚举常量"></a>使用枚举常量</h5><p>像 java 一样，Kotlin 中的枚举类有合成方法允许列出枚举常量的定义并且通过名字获得枚举常量。这些方法的签名就在下面列了出来(假设枚举类名字是EnumClass)：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EnumClass.valueOf(value: String): EnumClass</span><br><span class="line">EnumClass.values(): Array&lt;EnumClass&gt;</span><br></pre></td></tr></table></figure><p>如果指定的名字在枚举类中没有任何匹配，那么 valueOf() 方法将会抛出参数异常。<br>每个枚举常量都有获取在枚举类中声明的名字和位置的方法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name(): Sting</span><br><span class="line">ordinal(): <span class="built_in">Int</span></span><br></pre></td></tr></table></figure><p>枚举类也实现了 Comparable 接口，比较时使用的是它们在枚举类定义的自然顺序。</p><h4 id="对象表达式和声明"><a href="#对象表达式和声明" class="headerlink" title="对象表达式和声明"></a>对象表达式和声明</h4><p>有时候我们想要创建一个对当前类有一点小修改的对象，但不想重新声明一个子类。java 用匿名内部类的概念解决这个问题。Kotlin 用对象表达式和对象声明巧妙的实现了这一概念。</p><h5 id="对象表达式"><a href="#对象表达式" class="headerlink" title="对象表达式"></a>对象表达式</h5><p>通过下面的方式可以创建继承自某种(或某些)匿名类的对象：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">window.addMouseListener(<span class="keyword">object</span>: MouseAdapter () &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">mouseClicked</span><span class="params">(e: <span class="type">MouseEvent</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>如果父类有构造函数，则必须传递相应的构造参数。多个父类可以用逗号隔开，跟在冒号后面：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>(x: <span class="built_in">Int</span>) &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">open</span> <span class="keyword">val</span> y: <span class="built_in">Int</span> = x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">B</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> ab = <span class="keyword">object</span> : A(<span class="number">1</span>), B &#123;</span><br><span class="line"><span class="keyword">override</span> <span class="keyword">val</span> y = <span class="number">14</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有时候我们只是需要一个没有父类的对象，我们可以这样写：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> adHoc = <span class="keyword">object</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> y: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">print(adHoc.x + adHoc.y)</span><br></pre></td></tr></table></figure><p>像 java 的匿名内部类一样，对象表达式可以访问闭合范围内的变量 (和 java 不一样的是，这些变量不用是 final 修饰的)</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">countClicks</span><span class="params">(windows: <span class="type">JComponent</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> clickCount = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> enterCount = <span class="number">0</span></span><br><span class="line">    window.addMouseListener(<span class="keyword">object</span> : MouseAdapter() &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">mouseClicked</span><span class="params">(e: <span class="type">MouseEvent</span>)</span></span> &#123;</span><br><span class="line">        clickCount++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">mouseEntered</span><span class="params">(e: <span class="type">MouseEvent</span>)</span></span>&#123;</span><br><span class="line">        enterCount++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="对象声明"><a href="#对象声明" class="headerlink" title="对象声明"></a>对象声明</h5><p>单例模式是一种很有用的模式，Kotln 中声明它很方便：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> DataProviderManager &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">registerDataProvider</span><span class="params">(provider: <span class="type">DataProvider</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> allDataProviders: Collection&lt;DataProvider&gt;</span><br><span class="line">    <span class="keyword">get</span>() = <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这叫做对象声明，跟在 object 关键字后面是对象名。和变量声明一样，对象声明并不是表达式，而且不能作为右值用在赋值语句。<br>想要访问这个类，直接通过名字来使用这个类：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DataProviderManager.registerDataProvider(...)</span><br></pre></td></tr></table></figure><p>这样类型的对象可以有父类型：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> DefaultListener : MouseAdapter() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">mouseClicked</span><span class="params">(e: <span class="type">MouseEvent</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">mouseEntered</span><span class="params">(e: <span class="type">MouseEvent</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：对象声明不可以是局部的(比如不可以直接在函数内部声明)，但可以在其它对象的声明或非内部类中进行内嵌入</p><h5 id="伴随对象-1"><a href="#伴随对象-1" class="headerlink" title="伴随对象"></a>伴随对象</h5><p>在类声明内部可以用 companion 关键字标记对象声明：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> Factory &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">create</span><span class="params">()</span></span>: MyClass = MyClass()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>伴随对象的成员可以通过类名做限定词直接使用：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> instance = MyClass.create()</span><br></pre></td></tr></table></figure><p>在使用了 companion 关键字时，伴随对象的名字可以省略：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，尽管伴随对象的成员很像其它语言中的静态成员，但在运行时它们任然是真正对象的成员实例，比如可以实现接口：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">inerface Factory&lt;T&gt; &#123;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">create</span><span class="params">()</span></span>: T</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> : Factory&lt;MyClass&gt; &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">create</span><span class="params">()</span></span>: MyClass = MyClass()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你在 JVM 上使用 @JvmStatic 注解，你可以有多个伴随对象生成为真实的静态方法和属性。参看 java interoperabillity。</p><h5 id="对象表达式和声明的区别"><a href="#对象表达式和声明的区别" class="headerlink" title="对象表达式和声明的区别"></a>对象表达式和声明的区别</h5><p>他俩之间只有一个特别重要的区别：</p><blockquote><p>对象表达式在我们使用的地方立即初始化并执行的<br>对象声明是懒加载的，是在我们第一次访问时初始化的。<br>伴随对象是在对应的类加载时初始化的，和 Java 的静态初始是对应的。</p></blockquote><h4 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h4><h5 id="类代理"><a href="#类代理" class="headerlink" title="类代理"></a>类代理</h5><p>代理模式 给实现继承提供了很好的代替方式， Kotlin 在语法上支持这一点，所以并不需要什么样板代码。 Derived 类可以继承 Base 接口并且指定一个对象代理它全部的公共方法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseImpl</span></span>(<span class="keyword">val</span> x: <span class="built_in">Int</span>) : Base &#123;</span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">print</span><span class="params">()</span></span> &#123; printz(x) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span></span>(b: Base) : Base <span class="keyword">by</span> b</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> b = BaseImpl(<span class="number">10</span>)</span><br><span class="line">    Derived(b).print()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Derived 的父类列表中的 by 从句会将 b 存储在 Derived 内部对象，并且编译器会生成 Base 的所有方法并转给 b 。</p><h4 id="代理属性-1"><a href="#代理属性-1" class="headerlink" title="代理属性"></a>代理属性</h4><p>很多常用属性，虽然我们可以在需要的时候手动实现它们，但更好的办法是一次实现多次使用，并放到库。比如：</p><blockquote><p>延迟属性：只在第一次访问是计算它的值 观察属性：监听者从这获取这个属性更新的通知 在 map 中存储的属性，而不是单独存在分开的字段</p></blockquote><p>为了满足这些情形，Kotllin 支持代理属性：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line"><span class="keyword">var</span> p: String <span class="keyword">by</span> Delegate()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>语法结构是： val/var :  by  在 by 后面的属性就是代理，这样这个属性的 get() 和 set() 方法就代理给了它。<br>属性代理不需要任何接口的实现，但必须要提供 get() 方法(如果是变量还需要set() 方法)。像这样：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Delegate</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">get</span><span class="params">(thisRef: <span class="type">Any</span>?, prop: <span class="type">PropertyMetadata</span>)</span></span>: String &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"<span class="variable">$thisRef</span>, thank you for delegating '<span class="subst">$&#123;prop.name&#125;</span>' to me !"</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">set</span><span class="params">(thisRef: <span class="type">Any</span>?, prop: <span class="type">PropertyMatada</span>, value: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">    println(<span class="string">"<span class="variable">$value</span> has been assigned to '<span class="subst">$&#123;prop.name&#125;</span> in <span class="variable">$thisRef</span>.'"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们从 p 也就是 Delegate 的代理，中读东西时，会调用 Delegate 的get() 函数，因此第一个参数是我们从 p 中读取的，第二个参数是 p 自己的一个描述。比如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> e = Example()</span><br><span class="line">pintln(e.p)</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Example@33a17727, thank you for delegating ‘p’ to me!</span><br></pre></td></tr></table></figure><p>同样当我们分配 p 时 set() 函数就会调动。前俩个参数所以一样的，第三个持有分配的值：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">e.p = <span class="string">"NEW"</span></span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NEW has been assigned to ‘p’ in Example@33a17727.</span><br></pre></td></tr></table></figure><h5 id="代理属性的要求"><a href="#代理属性的要求" class="headerlink" title="代理属性的要求"></a>代理属性的要求</h5><p>这里总结一些代理对象的要求。<br>只读属性 (val)，代理必须提供一个名字叫 get 的方法并接受如下参数：</p><blockquote><p>接收者–必须是相同的，或者是属性拥有者的子类型<br>元数据–必须是 PropertyMetadata 或这它的子类型</p></blockquote><p>这个函数必须返回同样的类型作为属性。<br>可变属性 (var)，代理必须添加一个叫 set 的函数并接受如下参数：</p><blockquote><p>接受者–与 get() 一样 元数据–与 get() 一样 新值–必须和属性类型一致或是它的字类型</p></blockquote><h5 id="标准代理"><a href="#标准代理" class="headerlink" title="标准代理"></a>标准代理</h5><p>kotlin.properties.Delegates 对象是标准库提供的一个工厂方法并提供了很多有用的代理</p><p>#####延迟</p><p>Delegate.lazy() 是一个接受 lamdba 并返回一个实现延迟属性的代理：第一次调用 get() 执行 lamdba 并传递 lazy() 并记下结果，随后调用 get() 并简单返回之前记下的值。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlin.properties.Delegates</span><br><span class="line"><span class="keyword">val</span> lazy: String <span class="keyword">by</span> Delegates.lazy &#123;</span><br><span class="line">    println(<span class="string">"computed!"</span>)</span><br><span class="line">    <span class="string">"Hello"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    println(lazy)</span><br><span class="line">    println(lazy)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你想要线程安全，使用 blockingLazy() : 它还是按照同样的方式工作，但保证了它的值只会在一个线程中计算，并且所有的线程都获取的同一个值。</p><h5 id="观察者"><a href="#观察者" class="headerlink" title="观察者"></a>观察者</h5><p>Delegates.observable() 需要俩个参数：一个初始值和一个修改者的 handler。每次我们分配属性时都会调用handler (在分配前执行)。它有三个参数：一个分配的属性，旧值，新值：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name: String <span class="keyword">by</span> Delegates.observable(<span class="string">"&lt;no name&gt;"</span>) &#123;</span><br><span class="line">    d.old,new -&gt; println(<span class="string">"<span class="variable">$old</span> -&gt; <span class="variable">$new</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> user = User()</span><br><span class="line">    user.name = <span class="string">"first"</span></span><br><span class="line">    user.name = <span class="string">"second"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果</p><blockquote><p>-&gt; first first -&gt; second</p></blockquote><p>如果你想能够截取它的分配并取消它，用 vetoable() 代替 observable()</p><h5 id="非空"><a href="#非空" class="headerlink" title="非空"></a>非空</h5><p>有时我们有一个非空的 var ，但我们在构造函数中没有一个合适的值，比如它必须稍后再分配。问题是你不能持有一个未初始化并且是非抽象的属性：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line"><span class="keyword">var</span> bar: Bat <span class="comment">//错误必须初始化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以用 null 初始化它，但我们不用每次访问时都检查它。</p><p>Delegates.notNull() 可以解决这个问题</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line"><span class="keyword">var</span> bar: Bar <span class="keyword">by</span> Delegates.notNull()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果这个属性在第一次写之前读，它就会抛出一个异常，只有分配之后才会正常。</p><h5 id="在-Map-中存储属性"><a href="#在-Map-中存储属性" class="headerlink" title="在 Map 中存储属性"></a>在 Map 中存储属性</h5><p>Delegates.mapVal() 拥有一个 map 实例并返回一个可以从 map 中读其中属性的代理。在应用中有很多这样的例子，比如解析 JSON 或者做其它的一些 “动态”的事情：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(<span class="keyword">val</span> map: Map&lt;String, Any?&gt;) &#123;</span><br><span class="line">    <span class="keyword">val</span> name: String <span class="keyword">by</span> Delegates.mapVal(map)</span><br><span class="line">    <span class="keyword">val</span> age: <span class="built_in">Int</span> <span class="keyword">by</span> Delegates.mapVal(map)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，构造函数持有一个 map :</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> user = User(mapOf (</span><br><span class="line">    <span class="string">"name"</span> to <span class="string">"John Doe"</span>,</span><br><span class="line">    <span class="string">"age"</span> to <span class="number">25</span></span><br><span class="line">))</span><br></pre></td></tr></table></figure><p>代理从这个 map 中取指(通过属性的名字)：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">println(user.name) <span class="comment">// Prints "John Doe"</span></span><br><span class="line">println(user.age) <span class="comment">// Prints 25</span></span><br></pre></td></tr></table></figure><p>var 可以用 mapVar</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;类和对象&quot;&gt;&lt;a href=&quot;#类和对象&quot; class=&quot;headerlink&quot; title=&quot;类和对象&quot;&gt;&lt;/a&gt;类和对象&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;类和继承&lt;/li&gt;
&lt;li&gt;属性和字段&lt;/li&gt;
&lt;li&gt;接口&lt;/li&gt;
&lt;li&gt;可见性修复&lt;/li&gt;
&lt;li&gt;扩展&lt;/li&gt;
&lt;li&gt;数据对象&lt;/li&gt;
&lt;li&gt;泛型&lt;/li&gt;
&lt;li&gt;嵌套类&lt;/li&gt;
&lt;li&gt;枚举类&lt;/li&gt;
&lt;li&gt;对象表达式和声明&lt;/li&gt;
&lt;li&gt;代理模式&lt;/li&gt;
&lt;li&gt;代理属性&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="learn" scheme="http://www.sanmaoliu.com/tags/learn/"/>
    
      <category term="Kotlin" scheme="http://www.sanmaoliu.com/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>cmd关闭被占用的端口命令</title>
    <link href="http://www.sanmaoliu.com/2018/05/08/port/"/>
    <id>http://www.sanmaoliu.com/2018/05/08/port/</id>
    <published>2018-05-08T01:05:00.000Z</published>
    <updated>2018-05-19T07:57:42.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>在运行hexo的时候，出现4000的端口占用的问题。如图：<br><img src="https://coding.net/u/sanmaoliu/p/pictures/git/raw/master/cmdClosePort.png" alt="图片描述"></p><a id="more"></a><h3 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h3><p>netstat -nao | findstr “4000”             查询4000端口，可以找到这个进程的PID</p><p>taskkill /pid 12345 /F                    关闭pid为12345的进程，就是关闭上面那个PID，查到的PID是什么就关闭什么</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h3&gt;&lt;p&gt;在运行hexo的时候，出现4000的端口占用的问题。如图：&lt;br&gt;&lt;img src=&quot;https://coding.net/u/sanmaoliu/p/pictures/git/raw/master/cmdClosePort.png&quot; alt=&quot;图片描述&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="cmd" scheme="http://www.sanmaoliu.com/tags/cmd/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin Lenrning(3章)</title>
    <link href="http://www.sanmaoliu.com/2018/05/07/Kotlin-Learning2/"/>
    <id>http://www.sanmaoliu.com/2018/05/07/Kotlin-Learning2/</id>
    <published>2018-05-07T01:12:25.000Z</published>
    <updated>2018-05-09T02:59:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>本章包含以下内容</p><ol><li>基本类型</li><li>包</li><li>控制流</li><li><p>返回与跳转</p><a id="more"></a></li></ol><h3 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h3><p>在 Kotlin 中，所有变量的成员方法和属性都是一个对象。一些类型是内建的，它们的实现是优化过的，但对用户来说它们就像普通的类一样。在这节中，我们将会讲到大多数的类型：数值，字符，布尔，以及数组。</p><h4 id="数值"><a href="#数值" class="headerlink" title="数值"></a>数值</h4><p>Kotlin 处理数值的方法和 java 很相似，但不是完全一样。比如，不存在隐式转换数值的精度，并且在字面上有一些小小的不同。Kotlin 提供了如下内建数值类型(和 java 很相似)：      </p><table><thead><tr><th>类型</th><th style="text-align:center">字宽</th></tr></thead><tbody><tr><td>Double</td><td style="text-align:center">64</td></tr><tr><td>Float</td><td style="text-align:center">32</td></tr><tr><td>Long</td><td style="text-align:center">64</td></tr><tr><td>Int</td><td style="text-align:center">32</td></tr><tr><td>Short</td><td style="text-align:center">16</td></tr><tr><td>Byte</td><td style="text-align:center">8</td></tr></tbody></table><p><strong>注意：</strong>字符在 Kotlin 中不是数值类型</p><h4 id="字面值常量"><a href="#字面值常量" class="headerlink" title="字面值常量"></a>字面值常量</h4><p>主要是以下几种字面值常量：<br><em>–数型: 123 –长整型要加大写 L : 123L –16进制： 0x0f –二进制： 0b00001011</em><br><strong>注意：</strong>Kotlin不支持８进制<br>Kotlin 也支持传统的浮点数表示：<br><em>– 默认 Doubles : 123.5 , 123.5e10 – Floats 要添加 f 或 F ：123.5f</em></p><h4 id="表示"><a href="#表示" class="headerlink" title="表示"></a>表示</h4><p>在 java 平台上，数值被 JVM 虚拟机以字节码的方式物理存储的，除非我们需要做可空标识(比如说 Int?) 或者涉及泛型。在后者中数值是装箱的。注意装箱过的数值是不保留特征的：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> a: <span class="built_in">Int</span> = <span class="number">10000</span></span><br><span class="line">print (a === a ) <span class="comment">//打印 'true'</span></span><br><span class="line"><span class="keyword">val</span> boxedA: <span class="built_in">Int</span>? =a</span><br><span class="line"><span class="keyword">val</span> anotherBoxedA: <span class="built_in">Int</span>? = a</span><br><span class="line">print (boxedA === anotherBoxedA ) <span class="comment">//注意这里打印的是 'false'</span></span><br></pre></td></tr></table></figure></p><p>另一方面，它们是值相等的：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> a: <span class="built_in">Int</span> = <span class="number">10000</span></span><br><span class="line">print(a == a) <span class="comment">// Prints 'true'</span></span><br><span class="line"><span class="keyword">val</span> boxedA: <span class="built_in">Int</span>? = a</span><br><span class="line"><span class="keyword">val</span> anotherBoxedA: <span class="built_in">Int</span>? = a</span><br><span class="line">print(boxedA == anotherBoxedA) <span class="comment">// Prints 'true'</span></span><br></pre></td></tr></table></figure></p><h4 id="显示转换"><a href="#显示转换" class="headerlink" title="显示转换"></a>显示转换</h4><p>由于不同的表示，短类型不是长类型的子类型。如果是的话我们就会碰到下面这样的麻烦了<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这是些伪代码，不能编译的</span></span><br><span class="line"><span class="keyword">val</span> a: <span class="built_in">Int</span>? =<span class="number">1</span> <span class="comment">//一个装箱过的 Int (java.lang.Integer)</span></span><br><span class="line"><span class="keyword">val</span> b: <span class="built_in">Long</span>? = a <span class="comment">// 一个隐式装箱的 Long (java.lang.Long)</span></span><br><span class="line">print( a == b )<span class="comment">// 很惊讶吧 这次打印出的是 'false' 这是由于 Long 类型的 equals() 只有和 Long 比较才会相同</span></span><br></pre></td></tr></table></figure></p><p>因此不止是恒等，有时候连等于都会悄悄丢失。<br>所以，短类型是不会隐式转换为长类型的。这意味着我们必须显式转换才能把Byte 赋值给 Int<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> b: <span class="built_in">Byte</span> = <span class="number">1</span> <span class="comment">// OK, literals are checked statically</span></span><br><span class="line"><span class="keyword">val</span> i: <span class="built_in">Int</span> = b <span class="comment">//ERROR</span></span><br></pre></td></tr></table></figure></p><p>我们可以通过显式转换把数值类型提升<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> i: <span class="built_in">Int</span> = b.toInt() <span class="comment">// 显式转换</span></span><br></pre></td></tr></table></figure></p><p>每个数值类型都支持下面的转换<br>toByte(): Byte<br>toShort(): Short<br>toInt(): Int<br>toLong(): Long<br>toFloat(): Float<br>toDouble(): Double<br>toChar(): Char<br>隐式转换一般情况下是不容易被发觉的，因为我们可以使用上下文推断出类型，并且算术运算会为合适的转换进行重载，比如<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> l = <span class="number">1</span>.toLong + <span class="number">1</span> <span class="comment">//Long + Int =&gt; Long</span></span><br></pre></td></tr></table></figure></p><h4 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h4><p>Kotlin支持标准的算术运算表达式，这些运算符被声明为相应类的成员。参看运算<br>符重载。<br>至于位运算，Kotlin 并没有提供特殊的操作符，只是提供了可以叫中缀形式的方<br>法，比如：<br><strong>val x = (1 shl 2) and 0x000FF000</strong><br>下面是全部的位运算操作符(只可以用在 Int 和 Long 类型)：</p><blockquote><p>shl(bits) – 带符号左移 (相当于 Java’s &lt;&lt; ) </p><p>shr(bits) – 带符号右移(相当于 Java’s &gt;&gt; ) </p><p>ushr(bits) – 无符号右移 (相当于 Java’s &gt;&gt;&gt; )</p><p>and(bits) – 按位与 </p><p>or(bits) – 按位或 </p><p>xor(bits) – 按位异或</p><p>inv(bits) – 按位翻转</p></blockquote><h4 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h4><p>字符类型用 Char 表示。不能直接当做数值来使用</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">check</span><span class="params">(c: <span class="type">Char</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">1</span>) &#123; <span class="comment">//ERROR: 类型不匹配</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字符是由单引号包裹的’1’，特殊的字符通过反斜杠\转义，下面的字符序列支持转义：\t,\b,\n,\r,\’,\”,\和$。编码任何其他字符，使用 Unicode 转义语法：\uFF00。我们可以将字符显示的转义为Int数字：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">decimalDigitValue</span><span class="params">(c: <span class="type">Char</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (c !<span class="keyword">in</span> <span class="string">'0'</span>..<span class="string">'9'</span>)</span><br><span class="line">        <span class="keyword">throw</span> IllegalArgumentException(<span class="string">"Out of range"</span>)</span><br><span class="line">    <span class="keyword">return</span> c.toInt() - <span class="string">'0'</span>.toInt() <span class="comment">//显示转换为数值类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和数值类型一样，需要一个可空引用时，字符会被装箱。特性不会被装箱保留。</p><h4 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h4><p>布尔值只有 true 或者 false<br>布尔值的内建操作包括</p><blockquote><p>|| – lazy disjunction &amp;&amp; – lazy conjunction</p></blockquote><h4 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h4><p>Arrays在 Kotlin 中由 Array 类表示，有 get 和 set 方法(通过运算符重载可以由[]调用)，以及 size 方法，以及一些常用的函数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Array</span>&lt;<span class="type">T</span>&gt; <span class="keyword">private</span> </span>() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">size</span><span class="params">()</span></span>: <span class="built_in">Int</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">get</span><span class="params">(index: <span class="type">Int</span>)</span></span>: T</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">set</span><span class="params">(Index: <span class="type">Int</span>, value: <span class="type">T</span>)</span></span>: Uint</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">iterator</span><span class="params">()</span></span>: Iterator&lt;T&gt;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以给库函数 arrayOf() 传递每一项的值来创建Array， arrayOf(1, 2, 3) 创建了一个[1, 2, 3] 这样的数组。也可以使用库函数 arrayOfNulls() 创建一个指定大小的空Array。或者通过指定Array大小并提供一个迭代器</p><p>(原文Another option is to use a factory function that takes the array size and the function that can return the initial value of each array element given its index)：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个 Array&lt;String&gt; 内容为 ["0", "1", "4", "9", "16"]</span></span><br><span class="line"><span class="keyword">val</span> asc = Array(<span class="number">5</span>, &#123;i -&gt; (i * i).toString() &#125;)</span><br></pre></td></tr></table></figure><p>像我们上面提到的， [] 操作符表示调用 get() set() 函数<br>注意：和 java 不一样，arrays 在 kotlin 中是不可变的。这意味这 kotlin 不允许我们把 Array 转为 Array ,这样就阻止了可能的运行时错误(但你可以使用 Array , 参看 Type Projections)<br>Kotlin 有专门的类来表示原始类型从而避免过度装箱： ByteArray, ShortArray,IntArray 等等。这些类与 Array 没有继承关系，但它们有一样的方法与属性。每个都有对应的库函数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> x: IntArray = intArray(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">x[<span class="number">0</span>] = x[<span class="number">1</span>] + x[<span class="number">2</span>]</span><br></pre></td></tr></table></figure><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>字符串是有 String 表示的。字符串是不变的。字符串的元素可以通过索引操作读取: s[i] 。字符串可以用 for 循环迭代：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (c <span class="keyword">in</span> str) &#123;</span><br><span class="line">println(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Kotlin 有俩种类型的 string ：一种是可以带分割符的，一种是可以包含新行以及任意文本的。带分割符的 string 很像 java 的 string:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> s = <span class="string">"Hello World!\n"</span></span><br></pre></td></tr></table></figure><p>整行String 是由三个引号包裹的(“””),不可以包含分割符但可以包含其它字符：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> text = <span class="string">"""</span></span><br><span class="line"><span class="string">for (c in "foo")</span></span><br><span class="line"><span class="string">print(c)</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><h4 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h4><p>字符串可以包含模板表达式。一个模板表达式由一个 $ 开始并包含另一个简单的名称：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> i = <span class="number">10</span></span><br><span class="line"><span class="keyword">val</span> s = <span class="string">"i = <span class="variable">$i</span>"</span> <span class="comment">// 识别为 "i = 10"</span></span><br></pre></td></tr></table></figure><p>或者是一个带大括号的表达式：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> s = <span class="string">"abc"</span></span><br><span class="line"><span class="keyword">val</span> str = <span class="string">"<span class="variable">$s</span>.length is <span class="subst">$&#123;s.length&#125;</span>"</span> <span class="comment">//识别为 "abc.length is 3"</span></span><br></pre></td></tr></table></figure><h4 id="包"><a href="#包" class="headerlink" title="包"></a>包</h4><p>一个源文件以包声明开始：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> foo.bar</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">bza</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Goo</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure><p>源文件的所有内容(比如类和函数)都被包声明包括。因此在上面的例子中，bza() 的全名应该是 <em>foo.bar.bza</em> ， Goo 的全名是<em>foo.bar.Goo</em> 。如果没有指定包名，那这个文件的内容就从属于没有名字的 “default” 包。</p><h4 id="Imports"><a href="#Imports" class="headerlink" title="Imports"></a>Imports</h4><p>除了模块中默认导入的包，每个文件都可以有它自己的导入指令。导入语法的声明在grammar中描述。<br>我们可以导入一个单独的名字，比如下面这样：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> foo.Bar <span class="comment">//Bar 现在可以不用条件就可以使用</span></span><br></pre></td></tr></table></figure><p>或者范围内的所有可用的内容 (包，类，对象，等等):</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> foo.*/ /foo 中的所有都可以使用</span><br></pre></td></tr></table></figure><p>如果命名有冲突，我们可以使用 as 关键字局部重命名解决冲突</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> foo.Bar <span class="comment">// Bar 可以使用</span></span><br><span class="line"><span class="keyword">import</span> bar.Bar <span class="keyword">as</span> bBar <span class="comment">// bBar 代表 'bar.Bar'</span></span><br></pre></td></tr></table></figure><h4 id="可见性和包嵌套"><a href="#可见性和包嵌套" class="headerlink" title="可见性和包嵌套"></a>可见性和包嵌套</h4><p>如果最顶的声明标注为 private , 那么它是自己对应包私有 (参看 Visibility Modifiers)。如果包内有私有的属性或方法，那它对所有的子包是可见的。<br>注意包外的的成员是默认不导入的，比如在导入 foo.bar 后我们不能获得 foo的成员</p><h3 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h3><h4 id="if-表达式"><a href="#if-表达式" class="headerlink" title="if 表达式"></a>if 表达式</h4><p>在 Kotlin 中，if 是表达式，比如它可以返回一个值。是除了condition ? then : else)之外的唯一一个三元表达式</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//传统用法</span></span><br><span class="line"><span class="keyword">var</span> max = a</span><br><span class="line"><span class="keyword">if</span> (a &lt; b)</span><br><span class="line">max = b</span><br><span class="line"></span><br><span class="line"><span class="comment">//带 else</span></span><br><span class="line"><span class="keyword">var</span> max: <span class="built_in">Int</span></span><br><span class="line"><span class="keyword">if</span> (a &gt; b)</span><br><span class="line">max = a</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">max = b</span><br><span class="line"></span><br><span class="line"><span class="comment">//作为表达式</span></span><br><span class="line"><span class="keyword">val</span> max = <span class="keyword">if</span> (a &gt; b) a <span class="keyword">else</span> b</span><br></pre></td></tr></table></figure><p>if 分支可以作为块，最后一个表达是是该块的值：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> max = <span class="keyword">if</span> (a &gt; b)&#123;</span><br><span class="line">print(<span class="string">"Choose a"</span>)</span><br><span class="line">a</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">print(<span class="string">"Choose b"</span>)</span><br><span class="line">b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 if 表达式只有一个分支，或者分支的结果是 Unit , 它的值就是 Unit 。</p><h4 id="When-表达式"><a href="#When-表达式" class="headerlink" title="When 表达式"></a>When 表达式</h4><p>when 取代了 C 风格语言的 switch 。最简单的用法像下面这样</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">when</span> (x) &#123;</span><br><span class="line">    <span class="number">1</span> -&gt; print(<span class="string">"x == 1"</span>)</span><br><span class="line">    <span class="number">2</span> -&gt; print(<span class="string">"x == 2"</span>)</span><br><span class="line">    <span class="keyword">else</span> -&gt; &#123; <span class="comment">//Note the block</span></span><br><span class="line">    print(<span class="string">"x is neither 1 nor 2"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>when会对所有的分支进行检查直到有一个条件满足。when 可以用做表达式或声明。如果用作表达式的话，那么满足条件的分支就是总表达式。如果用做声明，那么分支的的的值会被忽略。(像 if 表达式一样，每个分支是一个语句块，而且它的值就是最后一个表达式的值)</p><p>在其它分支都不匹配的时候默认匹配 else 分支。如果把 when 做为表达式的话else 分支是强制的，除非编译器可以提供所有覆盖所有可能的分支条件。</p><p>如果有分支可以用同样的方式处理的话，分支条件可以连在一起：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">when</span> (x) &#123;</span><br><span class="line">    <span class="number">0</span>,<span class="number">1</span> -&gt; print(<span class="string">"x == 0 or x == 1"</span>)</span><br><span class="line">    <span class="keyword">else</span> -&gt; print(<span class="string">"otherwise"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以用任意表达式作为分支的条件</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">when</span> (x) &#123;</span><br><span class="line">    parseInt(s) -&gt; print(<span class="string">"s encode x"</span>)</span><br><span class="line">    <span class="keyword">else</span> -&gt; print(<span class="string">"s does not encode x"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>甚至可以用 in 或者 !in 检查值是否值在一个集合中：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">when</span> (x) &#123;</span><br><span class="line">    <span class="keyword">in</span> <span class="number">1</span>..<span class="number">10</span> -&gt; print(<span class="string">"x is in the range"</span>)</span><br><span class="line">    <span class="keyword">in</span> validNumbers -&gt; print(<span class="string">"x is valid"</span>)</span><br><span class="line">    !<span class="keyword">in</span> <span class="number">10</span>..<span class="number">20</span> -&gt; print(<span class="string">"x is outside the range"</span>)</span><br><span class="line">    <span class="keyword">else</span> -&gt; print(<span class="string">"none of the above"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以用 is 或者 !is 来判断值是否是某个类型。注意，由于 smart casts ，你可以不用另外的检查就可以使用相应的属性或方法。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> hasPrefix = <span class="keyword">when</span> (x) &#123;</span><br><span class="line">    <span class="keyword">is</span> String -&gt; x.startsWith(<span class="string">"prefix"</span>)</span><br><span class="line">    <span class="keyword">else</span> -&gt; <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>when 也可以用来代替 if-else if 。如果没有任何参数提供，那么分支的条件就是简单的布尔表达式，当条件为真时执行相应的分支：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">when</span> &#123;</span><br><span class="line">    x.isOdd() -&gt; print(<span class="string">"x is odd"</span>)</span><br><span class="line">    x.isEven() -&gt; print(<span class="string">"x is even"</span>)</span><br><span class="line">    <span class="keyword">else</span> -&gt; print(<span class="string">"x is funny"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h4><p>for 循环通过任何提供的迭代器进行迭代。语法是下面这样的：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (item <span class="keyword">in</span> collection)</span><br><span class="line">print(item)</span><br></pre></td></tr></table></figure><p>内容可以是一个语句块</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (item: <span class="built_in">Int</span> <span class="keyword">in</span> ints)&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>像之前提到的， for 可以对任何提供的迭代器进行迭代，比如：</p><blockquote><p>has an instance- or extension-function iterator(), whose return type<br>has an instance- or extension-function next(), and<br>has an instance- or extension-function hasNext() that returns Boolean.</p></blockquote><p>如果你想通过 list 或者 array 的索引进行迭代，你可以这样做：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> array.indices)</span><br><span class="line">print(array[i])</span><br></pre></td></tr></table></figure><p>在没有其它对象创建的时候 “iteration through a range “ 会被自动编译成最优的实现。</p><h4 id="while-循环"><a href="#while-循环" class="headerlink" title="while 循环"></a>while 循环</h4><p>while 和 do…while 像往常那样</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    x--</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> y = retrieveData()</span><br><span class="line">&#125; <span class="keyword">while</span> (y != <span class="literal">null</span>) <span class="comment">// y 在这是可见的</span></span><br></pre></td></tr></table></figure><h4 id="在循环中使用-break-和-continue"><a href="#在循环中使用-break-和-continue" class="headerlink" title="在循环中使用 break 和 continue"></a>在循环中使用 break 和 continue</h4><p>kotlin 支持传统的 break 和 continue 操作符。</p><h3 id="返回与跳转"><a href="#返回与跳转" class="headerlink" title="返回与跳转"></a>返回与跳转</h3><p>Kotlin 有三种机构跳转操作符</p><blockquote><p>return break 结束最近的闭合循环 continue 跳到最近的闭合循环的下一次循环</p></blockquote><h4 id="break-和-continue-标签"><a href="#break-和-continue-标签" class="headerlink" title="break 和 continue 标签"></a>break 和 continue 标签</h4><p>在 Kotlin 中表达式可以添加标签。标签通过 @ 结尾来表示，比如： <em>abc@</em> ， <em>fooBar@</em> 都是有效的。使用标签语法只需像这样：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">loop@</span> <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span>..<span class="number">100</span>)&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们可以用标签实现 break 或者 continue 的快速跳转：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">loop@</span> <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span>..<span class="number">100</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (j <span class="keyword">in</span> i..<span class="number">100</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (...)</span><br><span class="line">        <span class="keyword">break</span><span class="symbol">@loop</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>break 是跳转标签后面的表达式，continue 是跳转到循环的下一次迭代。</p><h4 id="返回到标签处"><a href="#返回到标签处" class="headerlink" title="返回到标签处"></a>返回到标签处</h4><p>在字面函数，局部函数，以及对象表达式中，函数可以在 Kotlin 中被包裹。return允许我们返回到外层函数。最重要的例子就是从字面函数中返回，还记得我们之前的写法吗：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ints.forEach &#123;</span><br><span class="line">        <span class="keyword">if</span> (it == <span class="number">0</span>) <span class="keyword">return</span></span><br><span class="line">        print(it)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>return 表达式返回到最近的闭合函数，比如 foo (注意这样非局部返回仅仅可以在内联函数中使用)。如果我们需要从一个字面函数返回可以使用标签修饰 return :</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ints.forEach <span class="symbol">lit@</span> &#123;</span><br><span class="line">        it (it ==<span class="number">0</span>) <span class="keyword">return</span>＠lit</span><br><span class="line">        print(it)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在它仅仅从字面函数中返回。经常用一种更方便的含蓄的标签：比如用和传入的lambda 表达式名字相同的标签。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ints.forEach &#123;</span><br><span class="line">        <span class="keyword">if</span> (it ==<span class="number">0</span>) <span class="keyword">return</span><span class="symbol">@forEach</span></span><br><span class="line">        print(it)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，我们可以用函数表达式替代字面函数。在函数表达式中使用 return 语句可以从函数表达式中返回。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ints.forEach(<span class="function"><span class="title">fun</span><span class="params">(value: <span class="type">Int</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="number">0</span>) <span class="keyword">return</span></span><br><span class="line">        print(value)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当返回一个值时，解析器给了一个参考，比如(原文When returning a value, the parser gives preference to the qualified return, i.e.)：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span><span class="symbol">@a</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>命名函数自动定义标签：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">foo outer() &#123;</span><br><span class="line">    foo <span class="keyword">inner</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span><span class="symbol">@outer</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;基础&quot;&gt;&lt;a href=&quot;#基础&quot; class=&quot;headerlink&quot; title=&quot;基础&quot;&gt;&lt;/a&gt;基础&lt;/h2&gt;&lt;p&gt;本章包含以下内容&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;基本类型&lt;/li&gt;
&lt;li&gt;包&lt;/li&gt;
&lt;li&gt;控制流&lt;/li&gt;
&lt;li&gt;&lt;p&gt;返回与跳转&lt;/p&gt;
    
    </summary>
    
    
      <category term="learn" scheme="http://www.sanmaoliu.com/tags/learn/"/>
    
      <category term="Kotlin" scheme="http://www.sanmaoliu.com/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>HashSet去除内容相同的对象</title>
    <link href="http://www.sanmaoliu.com/2018/05/04/HashSet%E5%8E%BB%E9%99%A4%E5%86%85%E5%AE%B9%E7%9B%B8%E5%90%8C%E7%9A%84%E5%AF%B9%E8%B1%A1/"/>
    <id>http://www.sanmaoliu.com/2018/05/04/HashSet去除内容相同的对象/</id>
    <published>2018-05-04T06:14:38.000Z</published>
    <updated>2018-05-19T08:05:12.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>四月份做了一个 <a href="http://www.qulishi.com/renwu" target="_blank" rel="noopener">趣历史</a> 网站的轻应用。用jsoup对那个网站进行下载解析作为数据源。然后遇到了一个问题。</p><p><img src="https://coding.net/u/sanmaoliu/p/pictures/git/raw/master/5.4hashset1.jpg?raw=true" alt="图片描述"></p><p>如图会在两个板块出现同一篇文章。这时候就想到了使用Set来去除重复内容。</p><a id="more"></a><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">String wenzhangming;</span><br><span class="line">String wenzhangUrl;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> String <span class="title">getWenzhangming</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> wenzhangming;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWenzhangming</span><span class="params">(String wenzhangming)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">this</span>.wenzhangming = wenzhangming;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> String <span class="title">getWenzhangUrl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> wenzhangUrl;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWenzhangUrl</span><span class="params">(String wenzhangUrl)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">this</span>.wenzhangUrl = wenzhangUrl;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="title">Wenzhang</span><span class="params">(String wenzhangming, String wenzhangUrl)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">this</span>.wenzhangming = wenzhangming;</span><br><span class="line">          <span class="keyword">this</span>.wenzhangUrl = wenzhangUrl;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p><em>Wenzhang</em>包含这两个字段。然后</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;QulishiPersonBean.Wenzhang&gt; wenzhangs = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">                Elements select4 = parse.select(<span class="string">"ul.newslist"</span>);</span><br><span class="line">                select4 = select4.select(<span class="string">"li"</span>);</span><br><span class="line">                QulishiPersonBean bean = <span class="keyword">new</span> QulishiPersonBean();</span><br><span class="line">                <span class="keyword">for</span> (Element element : select4) &#123;</span><br><span class="line">                    wenzhangs.add(bean.new Wenzhang(element.text().trim(),element.select(<span class="string">"a"</span>).attr(<span class="string">"href"</span>).trim()));</span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure><p>这样之后发现并没有排除重复的内容，两篇相同的文章还是出现了。</p><p>最后发现了是需要重写equal和hashcode方法，才能实现排除重复这个功能。因为不重写这两个方法的话，add对象会调用equal直接比较两个对象，因为对象的引用不同就认为不相等，所以就不能比较内容相等咯。</p><p>所以我们去重写这两个方法吧。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">          <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">          Wenzhang wenzhang = (Wenzhang) o;</span><br><span class="line">          <span class="keyword">return</span> Objects.equals(wenzhangming, wenzhang.wenzhangming) &amp;&amp;</span><br><span class="line">                  Objects.equals(wenzhangUrl, wenzhang.wenzhangUrl);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> Objects.hash(wenzhangming,wenzhangUrl);</span><br><span class="line">          <span class="comment">/*int result = 17;</span></span><br><span class="line"><span class="comment">          result = 31 * result + wenzhangming.hashCode();</span></span><br><span class="line"><span class="comment">          result = 31 * result + wenzhangUrl.hashCode();</span></span><br><span class="line"><span class="comment">          return result;*/</span></span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>hashCode的注释部分是具体实现转成hashcode的方法，我们只需要调用Objects.hash就可以了。</p><p>重新运行成功解决。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;四月份做了一个 &lt;a href=&quot;http://www.qulishi.com/renwu&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;趣历史&lt;/a&gt; 网站的轻应用。用jsoup对那个网站进行下载解析作为数据源。然后遇到了一个问题。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://coding.net/u/sanmaoliu/p/pictures/git/raw/master/5.4hashset1.jpg?raw=true&quot; alt=&quot;图片描述&quot;&gt;&lt;/p&gt;
&lt;p&gt;如图会在两个板块出现同一篇文章。这时候就想到了使用Set来去除重复内容。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://www.sanmaoliu.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin Lenrning(1,2章)</title>
    <link href="http://www.sanmaoliu.com/2018/05/04/Kotlin-Learning1/"/>
    <id>http://www.sanmaoliu.com/2018/05/04/Kotlin-Learning1/</id>
    <published>2018-05-04T01:01:28.000Z</published>
    <updated>2018-05-09T02:53:02.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p><em>Kotlin</em> 是一个实用性很强的语言，专注于互通，安全，简洁，工具健全…<br>无缝支持 Java+Kotlin 项目，可以更少的使用样版代码，确保类型安全。<br>    <a id="more"></a></p><h2 id="准备开始"><a href="#准备开始" class="headerlink" title="准备开始"></a>准备开始</h2><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><h4 id="定义包名"><a href="#定义包名" class="headerlink" title="定义包名"></a>定义包名</h4><p>在源文件的开头定义包名：<br>包名不必和文件夹路径一致：源文件可以放在任意位置。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> my.demo    </span><br><span class="line"><span class="keyword">import</span> java.util.*    </span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><h4 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h4><p>定义一个函数接受两个 int 型参数，返回值为 int:<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">sum</span><span class="params">(a: <span class="type">Int</span> , b: <span class="type">Int</span>)</span></span> : <span class="built_in">Int</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>该函数只有一个表达式函数体以及一个自推导型的返回值：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">sum</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span> = a + b</span><br></pre></td></tr></table></figure></p><p>返回一个没有意义的值:<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printSum</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span>: <span class="built_in">Unit</span>&#123;</span><br><span class="line">    print( a + b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Uint 的返回类型可以省略:<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printSum</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span>&#123;</span><br><span class="line">    print( a + b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="定义局部变量"><a href="#定义局部变量" class="headerlink" title="定义局部变量"></a>定义局部变量</h4><h5 id="声明常量："><a href="#声明常量：" class="headerlink" title="声明常量："></a>声明常量：</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> a: <span class="built_in">Int</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">val</span> b = <span class="number">1</span> <span class="comment">//推导出Int型</span></span><br><span class="line"><span class="keyword">val</span> c: <span class="built_in">Int</span> <span class="comment">//当没有初始化值时必须声明 类型</span></span><br><span class="line">c = <span class="number">1</span> <span class="comment">// 赋值</span></span><br></pre></td></tr></table></figure><h5 id="变量："><a href="#变量：" class="headerlink" title="变量："></a>变量：</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">5</span> <span class="comment">//推导出Int型</span></span><br><span class="line">x += <span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><p>与 java 和 javaScript 一样，Kotlin 支持单行注释和块注释。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单行注释</span></span><br><span class="line"><span class="comment">/* 哈哈哈哈</span></span><br><span class="line"><span class="comment">这是块注释 */</span></span><br></pre></td></tr></table></figure></p><p>与 java 不同的是 Kotlin 的 块注释可以级联。</p><h4 id="使用字符串模板"><a href="#使用字符串模板" class="headerlink" title="使用字符串模板"></a>使用字符串模板</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (args.size == <span class="number">0</span>) <span class="keyword">return</span></span><br><span class="line">        print(<span class="string">"First argument: <span class="subst">$&#123;args[<span class="number">0</span>]&#125;</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用条件表达式"><a href="#使用条件表达式" class="headerlink" title="使用条件表达式"></a>使用条件表达式</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">max</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (a &gt; b)</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把if当表达式：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">max</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span> = <span class="keyword">if</span> (a &gt; b) a <span class="keyword">else</span> b</span><br></pre></td></tr></table></figure></p><h4 id="使用可空变量以及空值检查"><a href="#使用可空变量以及空值检查" class="headerlink" title="使用可空变量以及空值检查"></a>使用可空变量以及空值检查</h4><p>当空值可能出现时应该明确指出该引用可空。<br>下面的函数是当 str 中不包含整数时返回空:<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">parseInt</span><span class="params">(str : <span class="type">String</span>)</span></span>: <span class="built_in">Int</span>?&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用一个返回可空值的函数：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (args.size &lt;<span class="number">2</span> )&#123;</span><br><span class="line">        print(<span class="string">"Two integers expected"</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">val</span> x = parseInt(args[<span class="number">0</span>])</span><br><span class="line"><span class="keyword">val</span> y = parseInt(args[<span class="number">1</span>])</span><br><span class="line"><span class="comment">//直接使用 x*y 会产生错误因为它们中有可能会有空值</span></span><br><span class="line"><span class="keyword">if</span> (x != <span class="literal">null</span> &amp;&amp; y !=<span class="literal">null</span>)&#123;</span><br><span class="line"><span class="comment">//x 和 y 将会在空值检测后自动转换为非空值</span></span><br><span class="line">    print(x * y)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>或者这样<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">if</span> (x == <span class="literal">null</span>) &#123;</span><br><span class="line">    print(<span class="string">"Wrong number format in '<span class="subst">$&#123;args[<span class="number">0</span>]&#125;</span>' "</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (y == <span class="literal">null</span>) &#123;</span><br><span class="line">    print(<span class="string">"Wrong number format in '<span class="subst">$&#123;args[<span class="number">1</span>]&#125;</span>' "</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//x 和 y 将会在空值检测后自动转换为非空值</span></span><br><span class="line">print(x * y)</span><br></pre></td></tr></table></figure></p><h4 id="使用值检查并自动转换"><a href="#使用值检查并自动转换" class="headerlink" title="使用值检查并自动转换"></a>使用值检查并自动转换</h4><p>使用 is 操作符检查一个表达式是否是某个类型的实例。如果对不可变的局部变量或属性进行过了类型检查，就没有必要明确转换：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getStringLength</span><span class="params">(obj: <span class="type">Any</span>)</span></span>: <span class="built_in">Int</span>? &#123;</span><br><span class="line">    <span class="keyword">if</span> ( obj <span class="keyword">is</span> string )&#123;</span><br><span class="line">        <span class="comment">//obj 将会在这个分支中自动转换为 String 类型</span></span><br><span class="line">        <span class="keyword">return</span> obj.length</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// obj 在种类检查外仍然是 Any 类型</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>或者这样<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getStringLength</span><span class="params">(obj: <span class="type">Any</span>)</span></span>: <span class="built_in">Int</span>? &#123;</span><br><span class="line">    <span class="keyword">if</span> ( obj <span class="keyword">is</span> string )</span><br><span class="line">        <span class="keyword">return</span> obj.length</span><br><span class="line">        <span class="comment">//obj 将会在这个分支中自动转换为 String 类型</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>甚至可以这样<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getStringLength</span><span class="params">(obj: <span class="type">Any</span>)</span></span>: <span class="built_in">Int</span>? &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj <span class="keyword">is</span> String &amp;&amp; obj.length &gt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> obj.Length</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="使用循环"><a href="#使用循环" class="headerlink" title="使用循环"></a>使用循环</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (arg <span class="keyword">in</span> args)</span><br><span class="line">    print(arg)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> args.indices)</span><br><span class="line">    print(args[i])</span><br></pre></td></tr></table></figure></p><h4 id="使用-while-循环"><a href="#使用-while-循环" class="headerlink" title="使用 while 循环"></a>使用 while 循环</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">Atring</span>&gt;)</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; args.size)&#123;</span><br><span class="line">        print(args[i++])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用-when-表达式"><a href="#使用-when-表达式" class="headerlink" title="使用 when 表达式"></a>使用 when 表达式</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">cases</span><span class="params">(obj: <span class="type">Any</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">when</span> (obj) &#123;</span><br><span class="line">    <span class="number">1</span> -&gt; print(<span class="string">"one"</span>)</span><br><span class="line">    <span class="string">"hello"</span> -&gt; print(<span class="string">"Greeting"</span>)</span><br><span class="line">    <span class="keyword">is</span> <span class="built_in">Long</span> -&gt; print(<span class="string">"Long"</span>)</span><br><span class="line">    !<span class="keyword">is</span> <span class="built_in">Long</span> -&gt; print(<span class="string">"Not a string"</span>)</span><br><span class="line">    <span class="keyword">else</span> -&gt; print(<span class="string">"Unknown"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用ranges"><a href="#使用ranges" class="headerlink" title="使用ranges"></a>使用ranges</h4><p>检查 in 操作符检查数值是否在某个范围内：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x <span class="keyword">in</span> <span class="number">1</span>..y-<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">"OK"</span>)</span><br></pre></td></tr></table></figure></p><p>检查数值是否在范围外：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x !<span class="keyword">in</span> <span class="number">0</span>..array.lastIndex)</span><br><span class="line">    print(<span class="string">"Out"</span>)</span><br></pre></td></tr></table></figure></p><h4 id="使用集合"><a href="#使用集合" class="headerlink" title="使用集合"></a>使用集合</h4><p>对一个集合进行迭代：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (name <span class="keyword">in</span> names)</span><br><span class="line">    println(name)</span><br></pre></td></tr></table></figure></p><p>使用 in 操作符检查集合中是否包含某个对象<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (text <span class="keyword">in</span> names) <span class="comment">//将会调用nemes.contains(text)方法</span></span><br><span class="line">    print(<span class="string">"Yes)</span></span><br></pre></td></tr></table></figure></p><p>使用字面函数过滤和映射集合：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">names</span><br><span class="line">.filter &#123; it.startsWith(<span class="string">"A"</span>) &#125;</span><br><span class="line">.sortedBy &#123; it &#125;</span><br><span class="line">.map &#123; it.toUpperCase() &#125;</span><br><span class="line">.forEach &#123; print(it) &#125;</span><br></pre></td></tr></table></figure></p><h3 id="习惯用语"><a href="#习惯用语" class="headerlink" title="习惯用语"></a>习惯用语</h3><h4 id="创建DTO’s-POJO’s-POCO’s-数据类"><a href="#创建DTO’s-POJO’s-POCO’s-数据类" class="headerlink" title="创建DTO’s(POJO’s/POCO’s) 数据类"></a>创建DTO’s(POJO’s/POCO’s) 数据类</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span></span>(<span class="keyword">val</span> name: String,<span class="keyword">val</span> email: String)</span><br></pre></td></tr></table></figure><p>给 Customer 类提供如下方法：<br>–为所有属性添加 getters ，如果为 var 类型同时添加 setters – equals() -<br>-haseCode() – toString() – copy() – component1() – component1() .</p><h4 id="函数默认值"><a href="#函数默认值" class="headerlink" title="函数默认值"></a>函数默认值</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">(a: <span class="type">Int</span> = <span class="number">0</span>, b: <span class="type">String</span> = <span class="string">""</span>)</span></span> &#123;...&#125;</span><br></pre></td></tr></table></figure><h4 id="过滤-list"><a href="#过滤-list" class="headerlink" title="过滤 list"></a>过滤 list</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> positives = list.filter &#123; x -&gt; x &gt;<span class="number">0</span> &#125;</span><br></pre></td></tr></table></figure><p>或者更短：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> positives = list.filter &#123; it &gt; <span class="number">0</span> &#125;</span><br></pre></td></tr></table></figure></p><h4 id="字符串插值"><a href="#字符串插值" class="headerlink" title="字符串插值"></a>字符串插值</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println( <span class="string">"Name <span class="variable">$name</span>"</span> )</span><br></pre></td></tr></table></figure><h4 id="实例检查"><a href="#实例检查" class="headerlink" title="实例检查"></a>实例检查</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">when</span> (x) &#123;</span><br><span class="line">    <span class="keyword">is</span> Foo -&gt; ...</span><br><span class="line">    <span class="keyword">is</span> Bar -&gt; ...</span><br><span class="line">    <span class="keyword">else</span> -&gt; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="遍历-map-list"><a href="#遍历-map-list" class="headerlink" title="遍历 map/list"></a>遍历 map/list</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ((k, v) <span class="keyword">in</span> map) &#123;</span><br><span class="line">    print(<span class="string">"<span class="variable">$k</span> -&gt; <span class="variable">$v</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>k,v 可以随便命名</p><h4 id="使用-ranges"><a href="#使用-ranges" class="headerlink" title="使用 ranges"></a>使用 ranges</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span>..<span class="number">100</span>) &#123; ... &#125;</span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">2</span>..<span class="number">10</span>) &#123; ... &#125;</span><br></pre></td></tr></table></figure><h4 id="只读-list"><a href="#只读-list" class="headerlink" title="只读 list"></a>只读 list</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>)</span><br></pre></td></tr></table></figure><h4 id="只读map"><a href="#只读map" class="headerlink" title="只读map"></a>只读map</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> map = mapOf(<span class="string">"a"</span> to <span class="number">1</span>, <span class="string">"b"</span> to <span class="number">2</span>, <span class="string">"c"</span> to <span class="number">3</span>)</span><br></pre></td></tr></table></figure><h4 id="访问-map"><a href="#访问-map" class="headerlink" title="访问 map"></a>访问 map</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">println(map[<span class="string">"key"</span>])</span><br><span class="line">map[<span class="string">"key"</span>] = value</span><br></pre></td></tr></table></figure><h4 id="懒属性-延迟加载"><a href="#懒属性-延迟加载" class="headerlink" title="懒属性(延迟加载)"></a>懒属性(延迟加载)</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> p: String <span class="keyword">by</span> lazy &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="扩展函数"><a href="#扩展函数" class="headerlink" title="扩展函数"></a>扩展函数</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> String.<span class="title">spcaceToCamelCase</span><span class="params">()</span></span> &#123; ... &#125;</span><br><span class="line"><span class="string">"Convert this to camelcase"</span>.spcaceToCamelCase()</span><br></pre></td></tr></table></figure><h4 id="创建单例模式"><a href="#创建单例模式" class="headerlink" title="创建单例模式"></a>创建单例模式</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> Resource &#123;</span><br><span class="line">    <span class="keyword">val</span> name = <span class="string">"Name"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="如果为空则…-的简写"><a href="#如果为空则…-的简写" class="headerlink" title="如果为空则… 的简写"></a>如果为空则… 的简写</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> files = File(<span class="string">"Test"</span>).listFiles()</span><br><span class="line">println(files?.size)</span><br></pre></td></tr></table></figure><h4 id="如果为空…否则…-的简写"><a href="#如果为空…否则…-的简写" class="headerlink" title="如果为空…否则… 的简写"></a>如果为空…否则… 的简写</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> files = File(<span class="string">"test"</span>).listFiles()</span><br><span class="line">println(files?.size ?: <span class="string">"empty"</span>)</span><br></pre></td></tr></table></figure><h4 id="如果声明为空执行某操作"><a href="#如果声明为空执行某操作" class="headerlink" title="如果声明为空执行某操作"></a>如果声明为空执行某操作</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> <span class="keyword">data</span> = ...</span><br><span class="line"><span class="keyword">val</span> email = <span class="keyword">data</span>[<span class="string">"email"</span>] ?: <span class="keyword">throw</span> IllegalStateException(<span class="string">"Email is missing!"</span>)</span><br></pre></td></tr></table></figure><h4 id="如果不为空执行某操作"><a href="#如果不为空执行某操作" class="headerlink" title="如果不为空执行某操作"></a>如果不为空执行某操作</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> date = ...</span><br><span class="line"><span class="keyword">data</span>?.let&#123;</span><br><span class="line">...<span class="comment">//如果不为空执行该语句块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="返回-when-判断"><a href="#返回-when-判断" class="headerlink" title="返回 when 判断"></a>返回 when 判断</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">transform</span><span class="params">(color: <span class="type">String</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">when</span>(color) &#123;</span><br><span class="line">        <span class="string">"Red"</span> -&gt; <span class="number">0</span></span><br><span class="line">        <span class="string">"Green"</span> -&gt; <span class="number">1</span></span><br><span class="line">        <span class="string">"Blue"</span> -&gt; <span class="number">2</span></span><br><span class="line">    <span class="keyword">else</span> -&gt; <span class="keyword">throw</span> IllegalArgumentException(<span class="string">"Invalid color param value"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="try-catch-表达式"><a href="#try-catch-表达式" class="headerlink" title="try-catch 表达式"></a>try-catch 表达式</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> result = <span class="keyword">try</span> &#123;</span><br><span class="line">    count()</span><br><span class="line">    &#125;<span class="keyword">catch</span> (e: ArithmeticException) &#123;</span><br><span class="line">        <span class="keyword">throw</span> IllegaStateException(e)</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//处理 result</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="if-表达式"><a href="#if-表达式" class="headerlink" title="if 表达式"></a>if 表达式</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">(param: <span class="type">Int</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> result = <span class="keyword">if</span> (param == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="string">"one"</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (param == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="string">"two"</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="string">"three"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法使用生成器模式返回-Unit"><a href="#方法使用生成器模式返回-Unit" class="headerlink" title="方法使用生成器模式返回 Unit"></a>方法使用生成器模式返回 Unit</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">arrOfMinusOnes</span><span class="params">(size: <span class="type">Int</span>)</span></span>: IntArray&#123;</span><br><span class="line">    <span class="keyword">return</span> IntArray(size).apply&#123; fill(-<span class="number">1</span>) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="只有一个表达式的函数"><a href="#只有一个表达式的函数" class="headerlink" title="只有一个表达式的函数"></a>只有一个表达式的函数</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">theAnswer</span><span class="params">()</span></span> = <span class="number">42</span></span><br></pre></td></tr></table></figure><p>与下面的语句是等效的<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">theAnswer</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个可以和其它习惯用语组合成高效简洁的代码。譬如说 when 表达式：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">transform</span><span class="params">(color: <span class="type">String</span>)</span></span>: <span class="built_in">Int</span> = <span class="keyword">when</span> (color) &#123;</span><br><span class="line">    <span class="string">"Red"</span> -&gt; <span class="number">0</span></span><br><span class="line">    <span class="string">"Green"</span> -&gt; <span class="number">1</span></span><br><span class="line">    <span class="string">"Blue"</span> -&gt; <span class="number">2</span></span><br><span class="line">    <span class="keyword">else</span> -&gt; <span class="keyword">throw</span> IllegalArgumentException(<span class="string">"Invalid color param value"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="利用-with-调用一个对象实例的多个方法"><a href="#利用-with-调用一个对象实例的多个方法" class="headerlink" title="利用 with 调用一个对象实例的多个方法"></a>利用 with 调用一个对象实例的多个方法</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Turtle</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">penDown</span><span class="params">()</span></span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">penUp</span><span class="params">()</span></span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">turn</span><span class="params">(degrees: <span class="type">Double</span>)</span></span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">forward</span><span class="params">(pixels: <span class="type">Double</span>)</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">val</span> myTurtle = Turtle()</span><br><span class="line">with(myTurtle) &#123; <span class="comment">//draw a 100 pix square</span></span><br><span class="line">penDown()</span><br><span class="line"><span class="keyword">for</span>(i <span class="keyword">in</span> <span class="number">1</span>..<span class="number">4</span>) &#123;</span><br><span class="line">    forward(<span class="number">100.0</span>)</span><br><span class="line">    turn(<span class="number">90.0</span>)</span><br><span class="line">&#125;</span><br><span class="line">penUp()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Java-7’s-try-with-resources"><a href="#Java-7’s-try-with-resources" class="headerlink" title="Java 7’s try with resources"></a>Java 7’s try with resources</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> stream = Files.newInputStream(Paths.<span class="keyword">get</span>(<span class="string">"/some/file.txt"</span>))</span><br><span class="line">stream.buffered().reader().use &#123; reader -&gt;</span><br><span class="line">    println(reader.readText())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="编码风格"><a href="#编码风格" class="headerlink" title="编码风格"></a>编码风格</h3><h4 id="命名风格"><a href="#命名风格" class="headerlink" title="命名风格"></a>命名风格</h4><p>如果对 java 默认的代码风格有疑惑，比如下面这些 ：</p><ul><li>使用骆驼命名法(在命名中避免下划线)</li><li>类型名称首字母大写</li><li>方法和属性首字母小写</li><li>缩进用四个空格</li><li>public 方法要写说明文档，这样它就可以出现在 Kotllin Doc 中 </li></ul><h4 id="冒号"><a href="#冒号" class="headerlink" title="冒号"></a>冒号</h4><p>在冒号区分类型和父类型中要有空格，在实例和类型之间是没有空格的：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Foo</span>&lt;<span class="type">out T : Any</span>&gt; : <span class="type">Bar &#123;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">(a: <span class="type">Int</span>)</span></span>: T</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Lambdas"><a href="#Lambdas" class="headerlink" title="Lambdas"></a>Lambdas</h4><p>在 Lambdas 表达式中，大括号与表达式间要有空格，箭头与参数和函数体间要有空格。尽可能的把 lambda 放在括号外面传入<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.filter &#123; it &gt; <span class="number">10</span> &#125;.map &#123; element -&gt; element * <span class="number">2</span> &#125;</span><br></pre></td></tr></table></figure></p><p>在 lambdas 中建议使用<strong> it </strong> 而不是申明参数。有嵌套多个参数的 lambdas 中参数是必须明确申明的</p><h4 id="Unit"><a href="#Unit" class="headerlink" title="Unit"></a>Unit</h4><p>如果函数返回 Unit ，返回类型应该省略：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;基本介绍&quot;&gt;&lt;a href=&quot;#基本介绍&quot; class=&quot;headerlink&quot; title=&quot;基本介绍&quot;&gt;&lt;/a&gt;基本介绍&lt;/h2&gt;&lt;p&gt;&lt;em&gt;Kotlin&lt;/em&gt; 是一个实用性很强的语言，专注于互通，安全，简洁，工具健全…&lt;br&gt;无缝支持 Java+Kotlin 项目，可以更少的使用样版代码，确保类型安全。&lt;br&gt;
    
    </summary>
    
    
      <category term="learn" scheme="http://www.sanmaoliu.com/tags/learn/"/>
    
      <category term="Kotlin" scheme="http://www.sanmaoliu.com/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>狗咬吕洞宾，不识好人心的故事</title>
    <link href="http://www.sanmaoliu.com/2018/05/03/story5.3/"/>
    <id>http://www.sanmaoliu.com/2018/05/03/story5.3/</id>
    <published>2018-05-03T01:10:11.000Z</published>
    <updated>2018-05-03T02:33:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>吕洞宾成仙得道之前，原是个读书人。他的好友中有个同乡叫苟杳。苟杳父母双亡，家境贫寒，但为人忠厚，是一个老诚君子，读书又很勤奋。吕洞宾很赏识他，与他结拜为金兰兄弟，并请他到自己家中居住，希望他能刻苦读书，以后能有个出头之日。<br>    <a id="more"></a><br>一天，吕洞宾家来了一位姓林的客人，见苟杳一表人材，读书用功，便对吕洞宾说，想把妹妹许配给苟杳。吕洞宾深怕苟杳贪恋床笫之欢误了锦绣前程，连忙推托。没料到，苟杳本人听说林家小姐貌美，执意要应允这门亲事。吕洞宾思索良久同意了。他对苟杳说：“贤弟既然主意已定，我不阻拦，不过成亲之后，我要先陪新娘子睡三宿。”苟杳听了大吃一惊。寄人篱下，怎得不低头?再说，婚礼的一切花费都得仰仗吕家，谁让自己一贫如洗呢?思前想后，还是咬咬牙答应了。苟杳成亲这天，吕洞宾喜气洋洋，跑前跑后张罗一切。而苟杳却无脸见人，干脆躲到一边。到了晚上，送走了宾客，吕洞宾进了洞房。只见新娘子头盖红纱，倚床而坐。吕洞宾不去掀那红盖头，也不说话，只管坐在灯下埋头读书。林小姐等到半夜，丈夫还是不上床，只好自己和衣睡下了。天明醒来，丈夫早已不见。一连三夜都是这样，可苦坏了林小姐，回头再说苟杳，好不容易熬过了三天，刚进洞房，见娘子正伤心落泪，低头哭着说：“郎君为何一连三夜都不上床同眠，只顾对灯读书，天黑而来，天明而去?”这一问，问得苟杳目瞪口呆。新娘子抬起头来一看，更是惊诧莫名：怎么丈夫换了个人?半天，夫妻俩才恍然大悟。苟杳双脚一跺，仰天大笑：“原来哥哥怕我贪欢，忘了读书，用此法来激励我啊！”林小姐也是心中欢喜，对吕洞宾充满了敬意。夫妻俩都说：吕兄此恩，将来一定要报答。</p><p>几年后，苟杳果然金榜题名，做了大官。夫妻俩与吕洞宾一家洒泪而别，赴任而去，一晃八年过去了。这年夏天，吕家不慎失火，偌大一份家财化灰烬。吕洞宾和妻子只好在残砖破瓦搭就的茅屋里寄身，不用说，日子过得是够难的。吕洞宾只好出门去找苟杳帮忙。一路上历尽千辛万苦，终于找上了苟杳府。苟杳对吕洞宾家遭大火非常同情，热情接待了他，可就是不提帮忙的事。吕洞宾一住几个月，一点银子也没拿到。吕洞宾仰天长叹：“人情薄如纸，一阔脸就变，滔滔然天下皆是也!”一气之下，不辞而别。回到家乡，吕洞宾老远就见自家的破茅屋换成了新瓦房，大为诧异：自己远离，子幼妻弱，怎能大兴土木?及至走近家门，更是惊得三魂走了两魄：大门两旁竟贴了白纸。家里死了人?他慌忙进屋，见屋里停着一口棺材，妻子披麻戴孝，正在嚎陶大哭。吕洞宾愣了半天：她为哪个戴孝?轻轻叫一声：“娘子。”娘子回头一看，惊恐万状，颤颤抖抖地叫道：“你，你是人还是鬼?”吕洞宾更觉诧异：“娘子怎出此言?我好好地回来了，如何是鬼?”娘子端详了半天，才敢相信真是吕洞宾回来了，说：“哎呀！当真吓死我了！这不会是在梦中吧?”原来，吕洞宾离家不久，就有一帮人来帮他盖房子，盖完了房子就走了。前天中午，又有一帮人抬来一口棺材，说是吕洞宾在苟杳家病死了。妻子一听，天塌地陷，哭得死去活来。今天正哭着，不想吕洞宾竟回来了。吕洞宾心下明白：都是苟杳玩的把戏。他操起一把利斧，狠劈棺材。“咔嚓”一声，棺材劈开了，里面竟全是金银财宝，还有一封信。吕洞宾展开信读道：“苟杳不是负心郎，路送金银家盖房。你让我妻守空房，我让你妻哭断肠。”吕洞宾如梦初醒，苦笑一声：“贤弟，你这一帮，可帮得我好苦啊!”从此，吕苟两家倍加亲热。</p><p>这就是俗话常说的“苟杳吕洞宾，不识好人心”，因为“苟杳”与“狗咬”同音，传来传去竟成了“狗咬吕洞宾，不识好人心”。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;吕洞宾成仙得道之前，原是个读书人。他的好友中有个同乡叫苟杳。苟杳父母双亡，家境贫寒，但为人忠厚，是一个老诚君子，读书又很勤奋。吕洞宾很赏识他，与他结拜为金兰兄弟，并请他到自己家中居住，希望他能刻苦读书，以后能有个出头之日。&lt;br&gt;
    
    </summary>
    
    
      <category term="story" scheme="http://www.sanmaoliu.com/tags/story/"/>
    
  </entry>
  
  <entry>
    <title>Diary 5.2</title>
    <link href="http://www.sanmaoliu.com/2018/05/02/diray5.2/"/>
    <id>http://www.sanmaoliu.com/2018/05/02/diray5.2/</id>
    <published>2018-05-02T01:10:11.000Z</published>
    <updated>2018-05-02T07:58:42.000Z</updated>
    
    <content type="html"><![CDATA[<ol><li>记录上周hexo+GitHub部署博客任务；</li><li>公众号文章更新；</li><li>CSDN更新Kotlin学习；</li><li>读书笔记；</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;记录上周hexo+GitHub部署博客任务；&lt;/li&gt;
&lt;li&gt;公众号文章更新；&lt;/li&gt;
&lt;li&gt;CSDN更新Kotlin学习；&lt;/li&gt;
&lt;li&gt;读书笔记；&lt;/li&gt;
&lt;/ol&gt;

      
    
    </summary>
    
    
      <category term="diray" scheme="http://www.sanmaoliu.com/tags/diray/"/>
    
  </entry>
  
  <entry>
    <title>MarkDown学习记录</title>
    <link href="http://www.sanmaoliu.com/2018/04/28/MarkDown-Learning/"/>
    <id>http://www.sanmaoliu.com/2018/04/28/MarkDown-Learning/</id>
    <published>2018-04-28T03:50:11.000Z</published>
    <updated>2018-05-02T02:21:24.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="A-First-Level-Header"><a href="#A-First-Level-Header" class="headerlink" title="A First Level Header"></a>A First Level Header</h1><h2 id="A-Second-Level-Header"><a href="#A-Second-Level-Header" class="headerlink" title="A Second Level Header"></a>A Second Level Header</h2><p>Now is the time for all good men to come to<br>the aid of their country. This is just a<br>regular paragraph.</p><p>The quick brown fox jumped over the lazy<br>dog’s back.</p><a id="more"></a><h3 id="Header-3"><a href="#Header-3" class="headerlink" title="Header 3"></a>Header 3</h3><blockquote><p>This is a blockquote.</p><p>This is the second paragraph in the blockquote.</p><h2 id="This-is-an-H2-in-a-blockquote"><a href="#This-is-an-H2-in-a-blockquote" class="headerlink" title="This is an H2 in a blockquote"></a>This is an H2 in a blockquote</h2></blockquote><p>Some of these words <em>are emphasized</em>.<br>Some of these words <em>are emphasized also</em>.<br>Use two asterisks for <strong>strong emphasis</strong>.<br>Or, if you prefer, <strong>use two underscores instead</strong>.</p><ul><li>Candy.</li><li>Gum.</li><li>Booze.</li></ul><ol><li>Red</li><li>Green</li><li>Blue</li></ol><ul><li><p>A list item.</p><p>With multiple paragraphs.</p></li><li><p>Another item in the list.</p></li></ul><p>This is an <a href="http://example.com/" target="_blank" rel="noopener">example link</a>.</p><p>This is an <a href="http://example.com/" title="With a Title" target="_blank" rel="noopener">example link</a>.</p><p>I get 10 times more traffic from <a href="http://google.com/" title="Google" target="_blank" rel="noopener">Google</a> than from<br><a href="http://search.yahoo.com/" title="Yahoo Search" target="_blank" rel="noopener">Yahoo</a> or <a href="http://search.msn.com/" title="MSN Search" target="_blank" rel="noopener">MSN</a>.</p><p>I start my morning with a cup of coffee and<br>[The New York Times][NY Times].</p><p><img src="/assets/img/head.jpg" alt="alt text"></p><p>I strongly recommend against using any <code>&lt;blink&gt;</code> tags.</p><p>I wish SmartyPants used named entities like <code>&amp;mdash;</code><br>instead of decimal-encoded entites like <code>&amp;#8212;</code>.</p><p>If you want your page to validate under XHTML 1.0 Strict,<br>you’ve got to put paragraph tags in your blockquotes:</p><blockquote><br><p>For example.</p><br></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;A-First-Level-Header&quot;&gt;&lt;a href=&quot;#A-First-Level-Header&quot; class=&quot;headerlink&quot; title=&quot;A First Level Header&quot;&gt;&lt;/a&gt;A First Level Header&lt;/h1&gt;&lt;h2 id=&quot;A-Second-Level-Header&quot;&gt;&lt;a href=&quot;#A-Second-Level-Header&quot; class=&quot;headerlink&quot; title=&quot;A Second Level Header&quot;&gt;&lt;/a&gt;A Second Level Header&lt;/h2&gt;&lt;p&gt;Now is the time for all good men to come to&lt;br&gt;the aid of their country. This is just a&lt;br&gt;regular paragraph.&lt;/p&gt;
&lt;p&gt;The quick brown fox jumped over the lazy&lt;br&gt;dog’s back.&lt;/p&gt;
    
    </summary>
    
    
      <category term="learn" scheme="http://www.sanmaoliu.com/tags/learn/"/>
    
  </entry>
  
</feed>
